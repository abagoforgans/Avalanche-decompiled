contract main {




// =====================  Runtime code  =====================


#
#  - withdraw(uint256 arg1)
#  - getReward()
#  - exit()
#
const sub_709d483c(?) = 0x12725ce34f9d66fc1eca33caf39712bd76b400000000000000


address owner;
uint256 stor1;
address rewardTokenAddress;
address stakingTokenAddress;
address rewardDistributionAddress;
uint256 rewardDuration;
uint256 sub_a70c1966;
uint256 startTime;
uint256 periodFinish;
uint256 rewardRate;
uint256 rewardPerTokenStored;
uint256 lastUpdateTime;
uint256 sub_f02d520b;
uint256 totalStakes;
uint256 sub_e7690c44;
array of uint256 sub_155b0a71;
mapping of struct sub_183ddbfb;
mapping of uint256 accountStakes;

function accountStakes(address arg1) payable {
    require calldata.size - 4 >= 32
    return accountStakes[arg1]
}

function rewardDistribution() payable {
    return rewardDistributionAddress
}

function sub_155b0a71(?) payable {
    require calldata.size - 4 >= 32
    require arg1 < sub_155b0a71.length
    return sub_155b0a71[arg1]
}

function sub_183ddbfb(?) payable {
    require calldata.size - 4 >= 32
    return sub_183ddbfb[arg1].field_0, sub_183ddbfb[arg1].field_256, sub_183ddbfb[arg1].field_512, sub_183ddbfb[arg1].field_768
}

function stakingToken() payable {
    return stakingTokenAddress
}

function startTime() payable {
    return startTime
}

function rewardRate() payable {
    return rewardRate
}

function owner() payable {
    return owner
}

function sub_a70c1966(?) payable {
    return sub_a70c1966
}

function totalStakes() payable {
    return totalStakes
}

function lastUpdateTime() payable {
    return lastUpdateTime
}

function rewardPerTokenStored() payable {
    return rewardPerTokenStored
}

function sub_e7690c44(?) payable {
    return sub_e7690c44
}

function periodFinish() payable {
    return periodFinish
}

function sub_f02d520b(?) payable {
    return sub_f02d520b
}

function rewardDuration() payable {
    return rewardDuration
}

function rewardToken() payable {
    return rewardTokenAddress
}

function _fallback() payable {
    revert
}

function isOwner() payable {
    return (msg.sender == owner)
}

function lastTimeRewardApplicable() payable {
    if block.timestamp < periodFinish:
        return block.timestamp
    return periodFinish
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function _setCooldownTime(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    sub_f02d520b = arg1
    emit NewCooldownTime(sub_f02d520b, arg1);
}

function _setRewardDistribution(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    rewardDistributionAddress = arg1
    emit NewRewardDistribution(rewardDistributionAddress, arg1);
}

function getRewardForDuration() payable {
    if not rewardRate:
        return 0
    if rewardDuration * rewardRate / rewardRate != rewardDuration:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[197 len 31]
    return (rewardDuration * rewardRate)
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    38,
                    0xfe4f776e61626c653a206e6577206f776e657220697320746865207a65726f20616464726573,
                    mem[202 len 26]
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function rewardPerToken() payable {
    if 0 == totalStakes:
        return rewardPerTokenStored
    if block.timestamp < periodFinish:
        if lastUpdateTime > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.timestamp - lastUpdateTime:
            if not totalStakes:
                revert with 0, 'SafeMath: division by zero'
            if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                revert with 0, 'SafeMath: addition overflow'
            return ((0 / totalStakes) + rewardPerTokenStored)
        if (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) / block.timestamp - lastUpdateTime != rewardRate:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        if not (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate):
            if not totalStakes:
                revert with 0, 'SafeMath: division by zero'
            if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                revert with 0, 'SafeMath: addition overflow'
            return ((0 / totalStakes) + rewardPerTokenStored)
        if (10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        if not totalStakes:
            revert with 0, 'SafeMath: division by zero'
        if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
            revert with 0, 'SafeMath: addition overflow'
        return (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored)
    if lastUpdateTime > periodFinish:
        revert with 0, 'SafeMath: subtraction overflow'
    if not periodFinish - lastUpdateTime:
        if not totalStakes:
            revert with 0, 'SafeMath: division by zero'
        if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
            revert with 0, 'SafeMath: addition overflow'
        return ((0 / totalStakes) + rewardPerTokenStored)
    if (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) / periodFinish - lastUpdateTime != rewardRate:
        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
    if not (periodFinish * rewardRate) - (lastUpdateTime * rewardRate):
        if not totalStakes:
            revert with 0, 'SafeMath: division by zero'
        if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
            revert with 0, 'SafeMath: addition overflow'
        return ((0 / totalStakes) + rewardPerTokenStored)
    if (10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
    if not totalStakes:
        revert with 0, 'SafeMath: division by zero'
    if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
        revert with 0, 'SafeMath: addition overflow'
    return (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored)
}

function _setRewardReleasePeriod(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if totalStakes != 0:
        if block.timestamp < periodFinish:
            if lastUpdateTime > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.timestamp - lastUpdateTime:
                if not totalStakes:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                    revert with 0, 'SafeMath: addition overflow'
                rewardPerTokenStored += 0 / totalStakes
            else:
                if (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) / block.timestamp - lastUpdateTime != rewardRate:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                if not (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate):
                    if not totalStakes:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                        revert with 0, 'SafeMath: addition overflow'
                    rewardPerTokenStored += 0 / totalStakes
                else:
                    if (10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                    if not totalStakes:
                        revert with 0, 'SafeMath: division by zero'
                    if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                        revert with 0, 'SafeMath: addition overflow'
                    rewardPerTokenStored += (10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes
        else:
            if lastUpdateTime > periodFinish:
                revert with 0, 'SafeMath: subtraction overflow'
            if not periodFinish - lastUpdateTime:
                if not totalStakes:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                    revert with 0, 'SafeMath: addition overflow'
                rewardPerTokenStored += 0 / totalStakes
            else:
                if (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) / periodFinish - lastUpdateTime != rewardRate:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                if not (periodFinish * rewardRate) - (lastUpdateTime * rewardRate):
                    if not totalStakes:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                        revert with 0, 'SafeMath: addition overflow'
                    rewardPerTokenStored += 0 / totalStakes
                else:
                    if (10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                    if not totalStakes:
                        revert with 0, 'SafeMath: division by zero'
                    if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                        revert with 0, 'SafeMath: addition overflow'
                    rewardPerTokenStored += (10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes
    if block.timestamp < periodFinish:
        lastUpdateTime = block.timestamp
    else:
        lastUpdateTime = periodFinish
    sub_a70c1966 = arg1
    emit NewRewardReleasePeriod(sub_a70c1966, arg1);
}

function _setRewardDuration(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if 0 == totalStakes:
        if block.timestamp < periodFinish:
            lastUpdateTime = block.timestamp
        else:
            lastUpdateTime = periodFinish
        rewardDuration = arg1
        if block.timestamp <= startTime:
            if not rewardRate:
                if not rewardDuration:
                    revert with 0, 'SafeMath: division by zero'
                rewardRate = 0 / rewardDuration
            else:
                if rewardDuration * rewardRate / rewardRate != rewardDuration:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if not rewardDuration:
                    revert with 0, 'SafeMath: division by zero'
                rewardRate = rewardDuration * rewardRate / rewardDuration
            lastUpdateTime = startTime
            if rewardDuration + startTime < startTime:
                revert with 0, 'SafeMath: addition overflow'
            periodFinish = rewardDuration + startTime
        else:
            if block.timestamp >= periodFinish:
                rewardRate = 0
            else:
                if block.timestamp > periodFinish:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not periodFinish - block.timestamp:
                    if not rewardDuration:
                        revert with 0, 'SafeMath: division by zero'
                    rewardRate = 0 / rewardDuration
                else:
                    if (periodFinish * rewardRate) - (block.timestamp * rewardRate) / periodFinish - block.timestamp != rewardRate:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                    if not rewardDuration:
                        revert with 0, 'SafeMath: division by zero'
                    rewardRate = (periodFinish * rewardRate) - (block.timestamp * rewardRate) / rewardDuration
            lastUpdateTime = block.timestamp
            if rewardDuration + block.timestamp < block.timestamp:
                revert with 0, 'SafeMath: addition overflow'
            periodFinish = rewardDuration + block.timestamp
    else:
        if block.timestamp < periodFinish:
            if lastUpdateTime > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.timestamp - lastUpdateTime:
                if not totalStakes:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                    revert with 0, 'SafeMath: addition overflow'
                rewardPerTokenStored += 0 / totalStakes
            else:
                if (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) / block.timestamp - lastUpdateTime != rewardRate:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                if not (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate):
                    if not totalStakes:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                        revert with 0, 'SafeMath: addition overflow'
                    rewardPerTokenStored += 0 / totalStakes
                else:
                    if (10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                    if not totalStakes:
                        revert with 0, 'SafeMath: division by zero'
                    if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                        revert with 0, 'SafeMath: addition overflow'
                    rewardPerTokenStored += (10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes
        else:
            if lastUpdateTime > periodFinish:
                revert with 0, 'SafeMath: subtraction overflow'
            if not periodFinish - lastUpdateTime:
                if not totalStakes:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                    revert with 0, 'SafeMath: addition overflow'
                rewardPerTokenStored += 0 / totalStakes
            else:
                if (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) / periodFinish - lastUpdateTime != rewardRate:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                if not (periodFinish * rewardRate) - (lastUpdateTime * rewardRate):
                    if not totalStakes:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                        revert with 0, 'SafeMath: addition overflow'
                    rewardPerTokenStored += 0 / totalStakes
                else:
                    if (10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                    if not totalStakes:
                        revert with 0, 'SafeMath: division by zero'
                    if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                        revert with 0, 'SafeMath: addition overflow'
                    rewardPerTokenStored += (10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes
        if block.timestamp < periodFinish:
            lastUpdateTime = block.timestamp
        else:
            lastUpdateTime = periodFinish
        rewardDuration = arg1
        if block.timestamp <= startTime:
            if not rewardRate:
                if not rewardDuration:
                    revert with 0, 'SafeMath: division by zero'
                rewardRate = 0 / rewardDuration
            else:
                if rewardDuration * rewardRate / rewardRate != rewardDuration:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if not rewardDuration:
                    revert with 0, 'SafeMath: division by zero'
                rewardRate = rewardDuration * rewardRate / rewardDuration
            lastUpdateTime = startTime
            if rewardDuration + startTime < startTime:
                revert with 0, 'SafeMath: addition overflow'
            periodFinish = rewardDuration + startTime
        else:
            if block.timestamp >= periodFinish:
                rewardRate = 0
            else:
                if block.timestamp > periodFinish:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not periodFinish - block.timestamp:
                    if not rewardDuration:
                        revert with 0, 'SafeMath: division by zero'
                    rewardRate = 0 / rewardDuration
                else:
                    if (periodFinish * rewardRate) - (block.timestamp * rewardRate) / periodFinish - block.timestamp != rewardRate:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if not rewardDuration:
                        revert with 0, 'SafeMath: division by zero'
                    rewardRate = (periodFinish * rewardRate) - (block.timestamp * rewardRate) / rewardDuration
            lastUpdateTime = block.timestamp
            if rewardDuration + block.timestamp < block.timestamp:
                revert with 0, 'SafeMath: addition overflow'
            periodFinish = rewardDuration + block.timestamp
    emit NewRewardDuration(rewardDuration, arg1);
}

function notifyRewardAmount(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if rewardDistributionAddress != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x7243616c6c6572206973206e6f742072657761726420646973747269627574696f,
                    mem[197 len 31]
    if 0 == totalStakes:
        if block.timestamp < periodFinish:
            lastUpdateTime = block.timestamp
        else:
            lastUpdateTime = periodFinish
        if block.timestamp <= startTime:
            if arg1 >= 0x12725ce34f9d66fc1eca33caf39712bd76b400000000000000:
                revert with 0, 'reward rate will overflow'
            if not rewardDuration:
                revert with 0, 'SafeMath: division by zero'
            rewardRate = arg1 / rewardDuration
            lastUpdateTime = startTime
            if rewardDuration + startTime < startTime:
                revert with 0, 'SafeMath: addition overflow'
            periodFinish = rewardDuration + startTime
        else:
            if block.timestamp >= periodFinish:
                if arg1 >= 0x12725ce34f9d66fc1eca33caf39712bd76b400000000000000:
                    revert with 0, 'reward rate will overflow'
                if not rewardDuration:
                    revert with 0, 'SafeMath: division by zero'
                rewardRate = arg1 / rewardDuration
            else:
                if block.timestamp > periodFinish:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not periodFinish - block.timestamp:
                    if arg1 < arg1:
                        revert with 0, 'SafeMath: addition overflow'
                    if arg1 >= 0x12725ce34f9d66fc1eca33caf39712bd76b400000000000000:
                        revert with 0, 'reward rate will overflow'
                    if arg1 < arg1:
                        revert with 0, 'SafeMath: addition overflow'
                    if not rewardDuration:
                        revert with 0, 'SafeMath: division by zero'
                    rewardRate = arg1 / rewardDuration
                else:
                    if (periodFinish * rewardRate) - (block.timestamp * rewardRate) / periodFinish - block.timestamp != rewardRate:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                    if (periodFinish * rewardRate) - (block.timestamp * rewardRate) + arg1 < arg1:
                        revert with 0, 'SafeMath: addition overflow'
                    if (periodFinish * rewardRate) - (block.timestamp * rewardRate) + arg1 >= 0x12725ce34f9d66fc1eca33caf39712bd76b400000000000000:
                        revert with 0, 'reward rate will overflow'
                    if (periodFinish * rewardRate) - (block.timestamp * rewardRate) + arg1 < arg1:
                        revert with 0, 'SafeMath: addition overflow'
                    if not rewardDuration:
                        revert with 0, 'SafeMath: division by zero'
                    rewardRate = (periodFinish * rewardRate) - (block.timestamp * rewardRate) + arg1 / rewardDuration
            lastUpdateTime = block.timestamp
            if rewardDuration + block.timestamp < block.timestamp:
                revert with 0, 'SafeMath: addition overflow'
            periodFinish = rewardDuration + block.timestamp
    else:
        if block.timestamp < periodFinish:
            if lastUpdateTime > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.timestamp - lastUpdateTime:
                if not totalStakes:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                    revert with 0, 'SafeMath: addition overflow'
                rewardPerTokenStored += 0 / totalStakes
            else:
                if (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) / block.timestamp - lastUpdateTime != rewardRate:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                if not (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate):
                    if not totalStakes:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                        revert with 0, 'SafeMath: addition overflow'
                    rewardPerTokenStored += 0 / totalStakes
                else:
                    if (10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                    if not totalStakes:
                        revert with 0, 'SafeMath: division by zero'
                    if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                        revert with 0, 'SafeMath: addition overflow'
                    rewardPerTokenStored += (10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes
        else:
            if lastUpdateTime > periodFinish:
                revert with 0, 'SafeMath: subtraction overflow'
            if not periodFinish - lastUpdateTime:
                if not totalStakes:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                    revert with 0, 'SafeMath: addition overflow'
                rewardPerTokenStored += 0 / totalStakes
            else:
                if (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) / periodFinish - lastUpdateTime != rewardRate:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                if not (periodFinish * rewardRate) - (lastUpdateTime * rewardRate):
                    if not totalStakes:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                        revert with 0, 'SafeMath: addition overflow'
                    rewardPerTokenStored += 0 / totalStakes
                else:
                    if (10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                    if not totalStakes:
                        revert with 0, 'SafeMath: division by zero'
                    if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                        revert with 0, 'SafeMath: addition overflow'
                    rewardPerTokenStored += (10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes
        if block.timestamp < periodFinish:
            lastUpdateTime = block.timestamp
        else:
            lastUpdateTime = periodFinish
        if block.timestamp <= startTime:
            if arg1 >= 0x12725ce34f9d66fc1eca33caf39712bd76b400000000000000:
                revert with 0, 'reward rate will overflow'
            if not rewardDuration:
                revert with 0, 'SafeMath: division by zero'
            rewardRate = arg1 / rewardDuration
            lastUpdateTime = startTime
            if rewardDuration + startTime < startTime:
                revert with 0, 'SafeMath: addition overflow'
            periodFinish = rewardDuration + startTime
        else:
            if block.timestamp >= periodFinish:
                if arg1 >= 0x12725ce34f9d66fc1eca33caf39712bd76b400000000000000:
                    revert with 0, 'reward rate will overflow'
                if not rewardDuration:
                    revert with 0, 'SafeMath: division by zero'
                rewardRate = arg1 / rewardDuration
            else:
                if block.timestamp > periodFinish:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not periodFinish - block.timestamp:
                    if arg1 < arg1:
                        revert with 0, 'SafeMath: addition overflow'
                    if arg1 >= 0x12725ce34f9d66fc1eca33caf39712bd76b400000000000000:
                        revert with 0, 'reward rate will overflow'
                    if arg1 < arg1:
                        revert with 0, 'SafeMath: addition overflow'
                    if not rewardDuration:
                        revert with 0, 'SafeMath: division by zero'
                    rewardRate = arg1 / rewardDuration
                else:
                    if (periodFinish * rewardRate) - (block.timestamp * rewardRate) / periodFinish - block.timestamp != rewardRate:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if (periodFinish * rewardRate) - (block.timestamp * rewardRate) + arg1 < arg1:
                        revert with 0, 'SafeMath: addition overflow'
                    if (periodFinish * rewardRate) - (block.timestamp * rewardRate) + arg1 >= 0x12725ce34f9d66fc1eca33caf39712bd76b400000000000000:
                        revert with 0, 'reward rate will overflow'
                    if (periodFinish * rewardRate) - (block.timestamp * rewardRate) + arg1 < arg1:
                        revert with 0, 'SafeMath: addition overflow'
                    if not rewardDuration:
                        revert with 0, 'SafeMath: division by zero'
                    rewardRate = (periodFinish * rewardRate) - (block.timestamp * rewardRate) + arg1 / rewardDuration
            lastUpdateTime = block.timestamp
            if rewardDuration + block.timestamp < block.timestamp:
                revert with 0, 'SafeMath: addition overflow'
            periodFinish = rewardDuration + block.timestamp
    emit RewardAdded(arg1);
}

function earned(address arg1) payable {
    require calldata.size - 4 >= 32
    mem[192] = 0
    mem[0] = arg1
    mem[32] = 16
    mem[64] = 352
    mem[224] = sub_183ddbfb[address(arg1)].field_0
    mem[256] = sub_183ddbfb[address(arg1)].field_256
    mem[288] = sub_183ddbfb[address(arg1)].field_512
    mem[320] = sub_183ddbfb[address(arg1)].field_768
    idx = sub_183ddbfb[address(arg1)].field_768
    s = sub_183ddbfb[address(arg1)].field_512
    t = sub_183ddbfb[address(arg1)].field_256
    while idx < sub_e7690c44:
        require idx < sub_155b0a71.length
        mem[0] = 15
        if not t:
            _290 = mem[64]
            mem[64] = mem[64] + 64
            mem[_290] = 26
            mem[_290 + 32] = 'SafeMath: division by zero'
            require idx < sub_155b0a71.length
            mem[0] = 15
            if not s:
                _338 = mem[64]
                mem[64] = mem[64] + 64
                mem[_338] = 26
                mem[_338 + 32] = 'SafeMath: division by zero'
                idx = idx + 1
                s = 0
                t = 0
                continue 
            if sub_155b0a71[idx] * s / s != sub_155b0a71[idx]:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _344 = mem[64]
            mem[64] = mem[64] + 64
            mem[_344] = 26
            mem[_344 + 32] = 'SafeMath: division by zero'
            idx = idx + 1
            s = sub_155b0a71[idx] * s / 10^18
            t = 0
            continue 
        if sub_155b0a71[idx] * t / t != sub_155b0a71[idx]:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _295 = mem[64]
        mem[64] = mem[64] + 64
        mem[_295] = 26
        mem[_295 + 32] = 'SafeMath: division by zero'
        require idx < sub_155b0a71.length
        mem[0] = 15
        if not s:
            _343 = mem[64]
            mem[64] = mem[64] + 64
            mem[_343] = 26
            mem[_343 + 32] = 'SafeMath: division by zero'
            idx = idx + 1
            s = 0
            t = sub_155b0a71[idx] * t / 10^18
            continue 
        if sub_155b0a71[idx] * s / s != sub_155b0a71[idx]:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _345 = mem[64]
        mem[64] = mem[64] + 64
        mem[_345] = 26
        mem[_345 + 32] = 'SafeMath: division by zero'
        idx = idx + 1
        s = sub_155b0a71[idx] * s / 10^18
        t = sub_155b0a71[idx] * t / 10^18
        continue 
    if 0 == totalStakes:
        _287 = mem[64]
        mem[64] = mem[64] + 64
        mem[_287] = 30
        mem[_287 + 32] = 'SafeMath: subtraction overflow'
        if t > rewardPerTokenStored:
            revert with 0, 'SafeMath: subtraction overflow'
        if not accountStakes[address(arg1)]:
            if s < 0:
                revert with 0, 'SafeMath: addition overflow'
            return s
        if (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / accountStakes[address(arg1)] != rewardPerTokenStored - t:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if s + ((rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18) < (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18:
            revert with 0, 'SafeMath: addition overflow'
        return (s + ((rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18))
    if block.timestamp < periodFinish:
        _296 = mem[64]
        mem[64] = mem[64] + 64
        mem[_296] = 30
        mem[_296 + 32] = 'SafeMath: subtraction overflow'
        if lastUpdateTime > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.timestamp - lastUpdateTime:
            _346 = mem[64]
            mem[64] = mem[64] + 64
            mem[_346] = 26
            mem[_346 + 32] = 'SafeMath: division by zero'
            if not totalStakes:
                revert with 0, 'SafeMath: division by zero'
            if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                revert with 0, 'SafeMath: addition overflow'
            _416 = mem[64]
            mem[64] = mem[64] + 64
            mem[_416] = 30
            mem[_416 + 32] = 'SafeMath: subtraction overflow'
            if t > (0 / totalStakes) + rewardPerTokenStored:
                revert with 0, 'SafeMath: subtraction overflow'
            if not accountStakes[address(arg1)]:
                if s < 0:
                    revert with 0, 'SafeMath: addition overflow'
                return s
            if (0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / accountStakes[address(arg1)] != (0 / totalStakes) + rewardPerTokenStored - t:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if s + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18) < (0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18:
                revert with 0, 'SafeMath: addition overflow'
            return (s + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18))
        if (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) / block.timestamp - lastUpdateTime != rewardRate:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if not (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate):
            _351 = mem[64]
            mem[64] = mem[64] + 64
            mem[_351] = 26
            mem[_351 + 32] = 'SafeMath: division by zero'
            if not totalStakes:
                revert with 0, 'SafeMath: division by zero'
            if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                revert with 0, 'SafeMath: addition overflow'
            _419 = mem[64]
            mem[64] = mem[64] + 64
            mem[_419] = 30
            mem[_419 + 32] = 'SafeMath: subtraction overflow'
            if t > (0 / totalStakes) + rewardPerTokenStored:
                revert with 0, 'SafeMath: subtraction overflow'
            if not accountStakes[address(arg1)]:
                if s < 0:
                    revert with 0, 'SafeMath: addition overflow'
                return s
            if (0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / accountStakes[address(arg1)] != (0 / totalStakes) + rewardPerTokenStored - t:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if s + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18) < (0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18:
                revert with 0, 'SafeMath: addition overflow'
            return (s + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18))
        if (10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _362 = mem[64]
        mem[64] = mem[64] + 64
        mem[_362] = 26
        mem[_362 + 32] = 'SafeMath: division by zero'
        if not totalStakes:
            revert with 0, 'SafeMath: division by zero'
        if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
            revert with 0, 'SafeMath: addition overflow'
        _425 = mem[64]
        mem[64] = mem[64] + 64
        mem[_425] = 30
        mem[_425 + 32] = 'SafeMath: subtraction overflow'
        if t > ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored:
            revert with 0, 'SafeMath: subtraction overflow'
        if not accountStakes[address(arg1)]:
            if s < 0:
                revert with 0, 'SafeMath: addition overflow'
            return s
        if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / accountStakes[address(arg1)] != ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored - t:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18) < ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18:
            revert with 0, 'SafeMath: addition overflow'
        return (s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18))
    _305 = mem[64]
    mem[64] = mem[64] + 64
    mem[_305] = 30
    mem[_305 + 32] = 'SafeMath: subtraction overflow'
    if lastUpdateTime > periodFinish:
        revert with 0, 'SafeMath: subtraction overflow'
    if not periodFinish - lastUpdateTime:
        _355 = mem[64]
        mem[64] = mem[64] + 64
        mem[_355] = 26
        mem[_355 + 32] = 'SafeMath: division by zero'
        if not totalStakes:
            revert with 0, 'SafeMath: division by zero'
        if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
            revert with 0, 'SafeMath: addition overflow'
        _423 = mem[64]
        mem[64] = mem[64] + 64
        mem[_423] = 30
        mem[_423 + 32] = 'SafeMath: subtraction overflow'
        if t > (0 / totalStakes) + rewardPerTokenStored:
            revert with 0, 'SafeMath: subtraction overflow'
        if not accountStakes[address(arg1)]:
            if s < 0:
                revert with 0, 'SafeMath: addition overflow'
            return s
        if (0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / accountStakes[address(arg1)] != (0 / totalStakes) + rewardPerTokenStored - t:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if s + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18) < (0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18:
            revert with 0, 'SafeMath: addition overflow'
        return (s + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18))
    if (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) / periodFinish - lastUpdateTime != rewardRate:
        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
    if not (periodFinish * rewardRate) - (lastUpdateTime * rewardRate):
        _367 = mem[64]
        mem[64] = mem[64] + 64
        mem[_367] = 26
        mem[_367 + 32] = 'SafeMath: division by zero'
        if not totalStakes:
            revert with 0, 'SafeMath: division by zero'
        if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
            revert with 0, 'SafeMath: addition overflow'
        _431 = mem[64]
        mem[64] = mem[64] + 64
        mem[_431] = 30
        mem[_431 + 32] = 'SafeMath: subtraction overflow'
        if t > (0 / totalStakes) + rewardPerTokenStored:
            revert with 0, 'SafeMath: subtraction overflow'
        if not accountStakes[address(arg1)]:
            if s < 0:
                revert with 0, 'SafeMath: addition overflow'
            return s
        if (0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / accountStakes[address(arg1)] != (0 / totalStakes) + rewardPerTokenStored - t:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if s + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18) < (0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18:
            revert with 0, 'SafeMath: addition overflow'
        return (s + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18))
    if (10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
    _380 = mem[64]
    mem[64] = mem[64] + 64
    mem[_380] = 26
    mem[_380 + 32] = 'SafeMath: division by zero'
    if not totalStakes:
        revert with 0, 'SafeMath: division by zero'
    if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
        revert with 0, 'SafeMath: addition overflow'
    _447 = mem[64]
    mem[64] = mem[64] + 64
    mem[_447] = 30
    mem[_447 + 32] = 'SafeMath: subtraction overflow'
    if t > ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored:
        revert with 0, 'SafeMath: subtraction overflow'
    if not accountStakes[address(arg1)]:
        if s < 0:
            revert with 0, 'SafeMath: addition overflow'
        return s
    if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / accountStakes[address(arg1)] != ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored - t:
        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
    if s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18) < ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18:
        revert with 0, 'SafeMath: addition overflow'
    return (s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18))
}

function _changeRewardToken(address arg1, uint256 arg2, address arg3) payable {
    require calldata.size - 4 >= 96
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if 0 == totalStakes:
        if block.timestamp < periodFinish:
            lastUpdateTime = block.timestamp
        else:
            lastUpdateTime = periodFinish
        if block.timestamp <= periodFinish:
            revert with 0, 'period not finished yet'
        if not rewardPerTokenStored:
            rewardPerTokenStored = 0
        else:
            if arg2 * rewardPerTokenStored / rewardPerTokenStored != arg2:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            rewardPerTokenStored = arg2 * rewardPerTokenStored / 10^18
        if not rewardRate:
            rewardRate = 0
        else:
            if arg2 * rewardRate / rewardRate != arg2:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            rewardRate = arg2 * rewardRate / 10^18
        sub_155b0a71.length++
        sub_155b0a71[sub_155b0a71.length] = arg2
        sub_e7690c44++
        require ext_code.size(rewardTokenAddress)
        staticcall rewardTokenAddress.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(rewardTokenAddress):
            revert with 0, 'SafeERC20: call to non-contract'
        if not ext_code.hash(rewardTokenAddress):
            revert with 0, 'SafeERC20: call to non-contract'
        mem[324 len 64] = unknown_0xa9059cbb(?????), address(arg3) << 64, 0, ext_call.return_data[0 len 28]
        call rewardTokenAddress with:
             gas gas_remaining wei
            args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[388 len 4]
        if not return_data.size:
            require not ext_call.success
            revert with 0, 'SafeERC20: low-level call failed'
        mem[356 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size:
            require return_data.size >= 32
            if not mem[356]:
                revert with 0, 
                            32,
                            42,
                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[ceil32(return_data.size) + 435 len 22]
        rewardTokenAddress = arg1
        if not ext_call.return_data[0]:
            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(rewardTokenAddress):
                revert with 0, 'SafeERC20: call to non-contract'
            if not ext_code.hash(rewardTokenAddress):
                revert with 0, 'SafeERC20: call to non-contract'
            mem[ceil32(return_data.size) + 521 len 96] = unknown_0x23b872dd(?????), address(arg3) << 64, 0, address(this.address), 0
            mem[ceil32(return_data.size) + 645 len 4] = 0
            call rewardTokenAddress with:
                 gas gas_remaining wei
                args 0, mem[ceil32(return_data.size) + 617 len 4]
            if not return_data.size:
                require not ext_call.success
                revert with 0, 'SafeERC20: low-level call failed'
            mem[ceil32(return_data.size) + 553 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                revert with 0, 
                            'SafeERC20: low-level call failed',
                            mem[(2 * ceil32(return_data.size)) + 622 len (2 * ceil32(return_data.size)) - (2 * ceil32(return_data.size))]
            if return_data.size:
                require return_data.size >= 32
                if not mem[ceil32(return_data.size) + 553]:
                    revert with 0, 
                                32,
                                42,
                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[(2 * ceil32(return_data.size)) + 632 len (2 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 22]
            emit NewRewardToken(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, address arg6):
                                rewardTokenAddress,
                                address(arg1),
                                arg2,
                                ext_call.return_data[0],
                                0,
                                address(arg3),
                                mem[(2 * ceil32(return_data.size)) + 714 len (2 * ceil32(return_data.size)) - (2 * ceil32(return_data.size))],
        else:
            if arg2 * ext_call.return_data[0] / ext_call.return_data[0] != arg2:
                revert with 0, 
                            32,
                            33,
                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[ceil32(return_data.size) + 426 len 31]
            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(rewardTokenAddress):
                revert with 0, 'SafeERC20: call to non-contract'
            if not ext_code.hash(rewardTokenAddress):
                revert with 0, 'SafeERC20: call to non-contract'
            mem[ceil32(return_data.size) + 521 len 96] = unknown_0x23b872dd(?????), address(arg3) << 64, 0, address(this.address), Mask(224, 32, arg2 * ext_call.return_data[0] / 10^18) >> 32
            mem[ceil32(return_data.size) + 645 len 4] = Mask(32, 64, arg2 * ext_call.return_data[0] / 10^18) >> 64
            call rewardTokenAddress with:
                 gas gas_remaining wei
                args Mask(224, 32, arg2 * ext_call.return_data[0] / 10^18) << 480, mem[ceil32(return_data.size) + 617 len 4]
            if not return_data.size:
                require not ext_call.success
                revert with 0, 'SafeERC20: low-level call failed'
            mem[ceil32(return_data.size) + 553 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                revert with 0, 
                            'SafeERC20: low-level call failed',
                            mem[(2 * ceil32(return_data.size)) + 622 len (2 * ceil32(return_data.size)) - (2 * ceil32(return_data.size))]
            if return_data.size:
                require return_data.size >= 32
                if not mem[ceil32(return_data.size) + 553]:
                    revert with 0, 
                                32,
                                42,
                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[(2 * ceil32(return_data.size)) + 632 len (2 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 22]
            emit NewRewardToken(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, address arg6):
                                rewardTokenAddress,
                                address(arg1),
                                arg2,
                                ext_call.return_data[0],
                                arg2 * ext_call.return_data[0] / 10^18,
                                address(arg3),
                                mem[(2 * ceil32(return_data.size)) + 714 len (2 * ceil32(return_data.size)) - (2 * ceil32(return_data.size))],
    else:
        if block.timestamp < periodFinish:
            if lastUpdateTime > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.timestamp - lastUpdateTime:
                if not totalStakes:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                    revert with 0, 'SafeMath: addition overflow'
                rewardPerTokenStored += 0 / totalStakes
            else:
                if (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) / block.timestamp - lastUpdateTime != rewardRate:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                if not (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate):
                    if not totalStakes:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                        revert with 0, 'SafeMath: addition overflow'
                    rewardPerTokenStored += 0 / totalStakes
                else:
                    if (10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                    if not totalStakes:
                        revert with 0, 'SafeMath: division by zero'
                    if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                        revert with 0, 'SafeMath: addition overflow'
                    rewardPerTokenStored += (10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes
        else:
            if lastUpdateTime > periodFinish:
                revert with 0, 'SafeMath: subtraction overflow'
            if not periodFinish - lastUpdateTime:
                if not totalStakes:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                    revert with 0, 'SafeMath: addition overflow'
                rewardPerTokenStored += 0 / totalStakes
            else:
                if (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) / periodFinish - lastUpdateTime != rewardRate:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                if not (periodFinish * rewardRate) - (lastUpdateTime * rewardRate):
                    if not totalStakes:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                        revert with 0, 'SafeMath: addition overflow'
                    rewardPerTokenStored += 0 / totalStakes
                else:
                    if (10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                    if not totalStakes:
                        revert with 0, 'SafeMath: division by zero'
                    if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                        revert with 0, 'SafeMath: addition overflow'
                    rewardPerTokenStored += (10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes
        if block.timestamp < periodFinish:
            lastUpdateTime = block.timestamp
        else:
            lastUpdateTime = periodFinish
        if block.timestamp <= periodFinish:
            revert with 0, 'period not finished yet'
        if not rewardPerTokenStored:
            rewardPerTokenStored = 0
        else:
            if arg2 * rewardPerTokenStored / rewardPerTokenStored != arg2:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            rewardPerTokenStored = arg2 * rewardPerTokenStored / 10^18
        if not rewardRate:
            rewardRate = 0
        else:
            if arg2 * rewardRate / rewardRate != arg2:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            rewardRate = arg2 * rewardRate / 10^18
        sub_155b0a71.length++
        sub_155b0a71[sub_155b0a71.length] = arg2
        sub_e7690c44++
        require ext_code.size(rewardTokenAddress)
        staticcall rewardTokenAddress.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(rewardTokenAddress):
            revert with 0, 'SafeERC20: call to non-contract'
        if not ext_code.hash(rewardTokenAddress):
            revert with 0, 'SafeERC20: call to non-contract'
        mem[452 len 64] = unknown_0xa9059cbb(?????), address(arg3) << 64, 0, ext_call.return_data[0 len 28]
        call rewardTokenAddress with:
             gas gas_remaining wei
            args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[516 len 4]
        if not return_data.size:
            require not ext_call.success
            revert with 0, 'SafeERC20: low-level call failed'
        mem[484 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size:
            require return_data.size >= 32
            if not mem[484]:
                revert with 0, 
                            32,
                            42,
                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[ceil32(return_data.size) + 563 len 22]
        rewardTokenAddress = arg1
        if not ext_call.return_data[0]:
            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(rewardTokenAddress):
                revert with 0, 'SafeERC20: call to non-contract'
            if not ext_code.hash(rewardTokenAddress):
                revert with 0, 'SafeERC20: call to non-contract'
            mem[ceil32(return_data.size) + 649 len 96] = unknown_0x23b872dd(?????), address(arg3) << 64, 0, address(this.address), 0
            mem[ceil32(return_data.size) + 773 len 4] = 0
            call rewardTokenAddress with:
                 gas gas_remaining wei
                args 0, mem[ceil32(return_data.size) + 745 len 4]
            if not return_data.size:
                require not ext_call.success
                revert with 0, 'SafeERC20: low-level call failed'
            mem[ceil32(return_data.size) + 681 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                revert with 0, 
                            'SafeERC20: low-level call failed',
                            mem[(2 * ceil32(return_data.size)) + 750 len (2 * ceil32(return_data.size)) - (2 * ceil32(return_data.size))]
            if return_data.size:
                require return_data.size >= 32
                if not mem[ceil32(return_data.size) + 681]:
                    revert with 0, 
                                32,
                                42,
                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[(2 * ceil32(return_data.size)) + 760 len (2 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 22]
            emit NewRewardToken(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, address arg6):
                                rewardTokenAddress,
                                address(arg1),
                                arg2,
                                ext_call.return_data[0],
                                0,
                                address(arg3),
                                mem[(2 * ceil32(return_data.size)) + 842 len (2 * ceil32(return_data.size)) - (2 * ceil32(return_data.size))],
        else:
            if arg2 * ext_call.return_data[0] / ext_call.return_data[0] != arg2:
                revert with 0, 
                            32,
                            33,
                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[ceil32(return_data.size) + 554 len 31]
            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(rewardTokenAddress):
                revert with 0, 'SafeERC20: call to non-contract'
            if not ext_code.hash(rewardTokenAddress):
                revert with 0, 'SafeERC20: call to non-contract'
            mem[ceil32(return_data.size) + 649 len 96] = unknown_0x23b872dd(?????), address(arg3) << 64, 0, address(this.address), Mask(224, 32, arg2 * ext_call.return_data[0] / 10^18) >> 32
            mem[ceil32(return_data.size) + 773 len 4] = Mask(32, 64, arg2 * ext_call.return_data[0] / 10^18) >> 64
            call rewardTokenAddress with:
                 gas gas_remaining wei
                args Mask(224, 32, arg2 * ext_call.return_data[0] / 10^18) << 480, mem[ceil32(return_data.size) + 745 len 4]
            if not return_data.size:
                require not ext_call.success
                revert with 0, 'SafeERC20: low-level call failed'
            mem[ceil32(return_data.size) + 681 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                revert with 0, 
                            'SafeERC20: low-level call failed',
                            mem[(2 * ceil32(return_data.size)) + 750 len (2 * ceil32(return_data.size)) - (2 * ceil32(return_data.size))]
            if return_data.size:
                require return_data.size >= 32
                if not mem[ceil32(return_data.size) + 681]:
                    revert with 0, 
                                32,
                                42,
                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[(2 * ceil32(return_data.size)) + 760 len (2 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 22]
            emit NewRewardToken(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, address arg6):
                                rewardTokenAddress,
                                address(arg1),
                                arg2,
                                ext_call.return_data[0],
                                arg2 * ext_call.return_data[0] / 10^18,
                                address(arg3),
                                mem[(2 * ceil32(return_data.size)) + 842 len (2 * ceil32(return_data.size)) - (2 * ceil32(return_data.size))],
}

function claimable(address arg1) payable {
    require calldata.size - 4 >= 32
    mem[192] = 0
    mem[0] = arg1
    mem[32] = 16
    mem[64] = 352
    mem[224] = sub_183ddbfb[address(arg1)].field_0
    mem[256] = sub_183ddbfb[address(arg1)].field_256
    mem[288] = sub_183ddbfb[address(arg1)].field_512
    mem[320] = sub_183ddbfb[address(arg1)].field_768
    idx = sub_183ddbfb[address(arg1)].field_768
    s = sub_183ddbfb[address(arg1)].field_512
    t = sub_183ddbfb[address(arg1)].field_256
    while idx < sub_e7690c44:
        require idx < sub_155b0a71.length
        mem[0] = 15
        if not t:
            _864 = mem[64]
            mem[64] = mem[64] + 64
            mem[_864] = 26
            mem[_864 + 32] = 'SafeMath: division by zero'
            require idx < sub_155b0a71.length
            mem[0] = 15
            if not s:
                _912 = mem[64]
                mem[64] = mem[64] + 64
                mem[_912] = 26
                mem[_912 + 32] = 'SafeMath: division by zero'
                idx = idx + 1
                s = 0
                t = 0
                continue 
            if sub_155b0a71[idx] * s / s != sub_155b0a71[idx]:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _918 = mem[64]
            mem[64] = mem[64] + 64
            mem[_918] = 26
            mem[_918 + 32] = 'SafeMath: division by zero'
            idx = idx + 1
            s = sub_155b0a71[idx] * s / 10^18
            t = 0
            continue 
        if sub_155b0a71[idx] * t / t != sub_155b0a71[idx]:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _869 = mem[64]
        mem[64] = mem[64] + 64
        mem[_869] = 26
        mem[_869 + 32] = 'SafeMath: division by zero'
        require idx < sub_155b0a71.length
        mem[0] = 15
        if not s:
            _917 = mem[64]
            mem[64] = mem[64] + 64
            mem[_917] = 26
            mem[_917 + 32] = 'SafeMath: division by zero'
            idx = idx + 1
            s = 0
            t = sub_155b0a71[idx] * t / 10^18
            continue 
        if sub_155b0a71[idx] * s / s != sub_155b0a71[idx]:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _919 = mem[64]
        mem[64] = mem[64] + 64
        mem[_919] = 26
        mem[_919 + 32] = 'SafeMath: division by zero'
        idx = idx + 1
        s = sub_155b0a71[idx] * s / 10^18
        t = sub_155b0a71[idx] * t / 10^18
        continue 
    if 0 == totalStakes:
        _861 = mem[64]
        mem[64] = mem[64] + 64
        mem[_861] = 30
        mem[_861 + 32] = 'SafeMath: subtraction overflow'
        if t > rewardPerTokenStored:
            revert with 0, 'SafeMath: subtraction overflow'
        mem[0] = arg1
        mem[32] = 17
        if not accountStakes[address(arg1)]:
            _899 = mem[64]
            mem[64] = mem[64] + 64
            mem[_899] = 26
            mem[_899 + 32] = 'SafeMath: division by zero'
            if s < 0:
                revert with 0, 'SafeMath: addition overflow'
            mem[0] = arg1
            mem[32] = 16
            _944 = mem[64]
            mem[64] = mem[64] + 64
            mem[_944] = 30
            mem[_944 + 32] = 'SafeMath: subtraction overflow'
            if sub_183ddbfb[address(arg1)].field_0 > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow'
            if sub_a70c1966 != 0:
                if not s:
                    if not sub_a70c1966:
                        revert with 0, 'SafeMath: division by zero'
                    if 0 / sub_a70c1966 <= s:
                        return (0 / sub_a70c1966)
                else:
                    if (block.timestamp * s) - (sub_183ddbfb[address(arg1)].field_0 * s) / s != block.timestamp - sub_183ddbfb[address(arg1)].field_0:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not sub_a70c1966:
                        revert with 0, 'SafeMath: division by zero'
                    if (block.timestamp * s) - (sub_183ddbfb[address(arg1)].field_0 * s) / sub_a70c1966 <= s:
                        return ((block.timestamp * s) - (sub_183ddbfb[address(arg1)].field_0 * s) / sub_a70c1966)
            return s
        if (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / accountStakes[address(arg1)] != rewardPerTokenStored - t:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _906 = mem[64]
        mem[64] = mem[64] + 64
        mem[_906] = 26
        mem[_906 + 32] = 'SafeMath: division by zero'
        if s + ((rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18) < (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18:
            revert with 0, 'SafeMath: addition overflow'
        mem[0] = arg1
        mem[32] = 16
        _958 = mem[64]
        mem[64] = mem[64] + 64
        mem[_958] = 30
        mem[_958 + 32] = 'SafeMath: subtraction overflow'
        if sub_183ddbfb[address(arg1)].field_0 > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow'
        if sub_a70c1966 != 0:
            if not s + ((rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18):
                if not sub_a70c1966:
                    revert with 0, 'SafeMath: division by zero'
                if 0 / sub_a70c1966 <= s + ((rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18):
                    return (0 / sub_a70c1966)
            else:
                if (s * block.timestamp) + ((rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * block.timestamp) - (s * sub_183ddbfb[address(arg1)].field_0) - ((rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * sub_183ddbfb[address(arg1)].field_0) / s + ((rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18) != block.timestamp - sub_183ddbfb[address(arg1)].field_0:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not sub_a70c1966:
                    revert with 0, 'SafeMath: division by zero'
                if (s * block.timestamp) + ((rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * block.timestamp) - (s * sub_183ddbfb[address(arg1)].field_0) - ((rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * sub_183ddbfb[address(arg1)].field_0) / sub_a70c1966 <= s + ((rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18):
                    return ((s * block.timestamp) + ((rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * block.timestamp) - (s * sub_183ddbfb[address(arg1)].field_0) - ((rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * sub_183ddbfb[address(arg1)].field_0) / sub_a70c1966)
        return (s + ((rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18))
    if block.timestamp < periodFinish:
        _870 = mem[64]
        mem[64] = mem[64] + 64
        mem[_870] = 30
        mem[_870 + 32] = 'SafeMath: subtraction overflow'
        if lastUpdateTime > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.timestamp - lastUpdateTime:
            _920 = mem[64]
            mem[64] = mem[64] + 64
            mem[_920] = 26
            mem[_920 + 32] = 'SafeMath: division by zero'
            if not totalStakes:
                revert with 0, 'SafeMath: division by zero'
            if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                revert with 0, 'SafeMath: addition overflow'
            _1011 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1011] = 30
            mem[_1011 + 32] = 'SafeMath: subtraction overflow'
            if t > (0 / totalStakes) + rewardPerTokenStored:
                revert with 0, 'SafeMath: subtraction overflow'
            mem[0] = arg1
            mem[32] = 17
            if not accountStakes[address(arg1)]:
                _1120 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1120] = 26
                mem[_1120 + 32] = 'SafeMath: division by zero'
                if s < 0:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = arg1
                mem[32] = 16
                _1189 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1189] = 30
                mem[_1189 + 32] = 'SafeMath: subtraction overflow'
                if sub_183ddbfb[address(arg1)].field_0 > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow'
                if sub_a70c1966 != 0:
                    if not s:
                        if not sub_a70c1966:
                            revert with 0, 'SafeMath: division by zero'
                        if 0 / sub_a70c1966 <= s:
                            return (0 / sub_a70c1966)
                    else:
                        if (block.timestamp * s) - (sub_183ddbfb[address(arg1)].field_0 * s) / s != block.timestamp - sub_183ddbfb[address(arg1)].field_0:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not sub_a70c1966:
                            revert with 0, 'SafeMath: division by zero'
                        if (block.timestamp * s) - (sub_183ddbfb[address(arg1)].field_0 * s) / sub_a70c1966 <= s:
                            return ((block.timestamp * s) - (sub_183ddbfb[address(arg1)].field_0 * s) / sub_a70c1966)
                return s
            if (0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / accountStakes[address(arg1)] != (0 / totalStakes) + rewardPerTokenStored - t:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _1142 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1142] = 26
            mem[_1142 + 32] = 'SafeMath: division by zero'
            if s + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18) < (0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18:
                revert with 0, 'SafeMath: addition overflow'
            mem[0] = arg1
            mem[32] = 16
            _1200 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1200] = 30
            mem[_1200 + 32] = 'SafeMath: subtraction overflow'
            if sub_183ddbfb[address(arg1)].field_0 > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow'
            if sub_a70c1966 != 0:
                if not s + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18):
                    if not sub_a70c1966:
                        revert with 0, 'SafeMath: division by zero'
                    if 0 / sub_a70c1966 <= s + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18):
                        return (0 / sub_a70c1966)
                else:
                    if (s * block.timestamp) + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * block.timestamp) - (s * sub_183ddbfb[address(arg1)].field_0) - ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * sub_183ddbfb[address(arg1)].field_0) / s + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18) != block.timestamp - sub_183ddbfb[address(arg1)].field_0:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not sub_a70c1966:
                        revert with 0, 'SafeMath: division by zero'
                    if (s * block.timestamp) + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * block.timestamp) - (s * sub_183ddbfb[address(arg1)].field_0) - ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * sub_183ddbfb[address(arg1)].field_0) / sub_a70c1966 <= s + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18):
                        return ((s * block.timestamp) + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * block.timestamp) - (s * sub_183ddbfb[address(arg1)].field_0) - ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * sub_183ddbfb[address(arg1)].field_0) / sub_a70c1966)
            return (s + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18))
        if (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) / block.timestamp - lastUpdateTime != rewardRate:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if not (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate):
            _925 = mem[64]
            mem[64] = mem[64] + 64
            mem[_925] = 26
            mem[_925 + 32] = 'SafeMath: division by zero'
            if not totalStakes:
                revert with 0, 'SafeMath: division by zero'
            if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                revert with 0, 'SafeMath: addition overflow'
            _1021 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1021] = 30
            mem[_1021 + 32] = 'SafeMath: subtraction overflow'
            if t > (0 / totalStakes) + rewardPerTokenStored:
                revert with 0, 'SafeMath: subtraction overflow'
            mem[0] = arg1
            mem[32] = 17
            if not accountStakes[address(arg1)]:
                _1141 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1141] = 26
                mem[_1141 + 32] = 'SafeMath: division by zero'
                if s < 0:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = arg1
                mem[32] = 16
                _1199 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1199] = 30
                mem[_1199 + 32] = 'SafeMath: subtraction overflow'
                if sub_183ddbfb[address(arg1)].field_0 > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow'
                if sub_a70c1966 != 0:
                    if not s:
                        if not sub_a70c1966:
                            revert with 0, 'SafeMath: division by zero'
                        if 0 / sub_a70c1966 <= s:
                            return (0 / sub_a70c1966)
                    else:
                        if (block.timestamp * s) - (sub_183ddbfb[address(arg1)].field_0 * s) / s != block.timestamp - sub_183ddbfb[address(arg1)].field_0:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not sub_a70c1966:
                            revert with 0, 'SafeMath: division by zero'
                        if (block.timestamp * s) - (sub_183ddbfb[address(arg1)].field_0 * s) / sub_a70c1966 <= s:
                            return ((block.timestamp * s) - (sub_183ddbfb[address(arg1)].field_0 * s) / sub_a70c1966)
                return s
            if (0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / accountStakes[address(arg1)] != (0 / totalStakes) + rewardPerTokenStored - t:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _1159 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1159] = 26
            mem[_1159 + 32] = 'SafeMath: division by zero'
            if s + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18) < (0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18:
                revert with 0, 'SafeMath: addition overflow'
            mem[0] = arg1
            mem[32] = 16
            _1215 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1215] = 30
            mem[_1215 + 32] = 'SafeMath: subtraction overflow'
            if sub_183ddbfb[address(arg1)].field_0 > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow'
            if sub_a70c1966 != 0:
                if not s + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18):
                    if not sub_a70c1966:
                        revert with 0, 'SafeMath: division by zero'
                    if 0 / sub_a70c1966 <= s + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18):
                        return (0 / sub_a70c1966)
                else:
                    if (s * block.timestamp) + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * block.timestamp) - (s * sub_183ddbfb[address(arg1)].field_0) - ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * sub_183ddbfb[address(arg1)].field_0) / s + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18) != block.timestamp - sub_183ddbfb[address(arg1)].field_0:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not sub_a70c1966:
                        revert with 0, 'SafeMath: division by zero'
                    if (s * block.timestamp) + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * block.timestamp) - (s * sub_183ddbfb[address(arg1)].field_0) - ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * sub_183ddbfb[address(arg1)].field_0) / sub_a70c1966 <= s + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18):
                        return ((s * block.timestamp) + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * block.timestamp) - (s * sub_183ddbfb[address(arg1)].field_0) - ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * sub_183ddbfb[address(arg1)].field_0) / sub_a70c1966)
            return (s + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18))
        if (10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _935 = mem[64]
        mem[64] = mem[64] + 64
        mem[_935] = 26
        mem[_935 + 32] = 'SafeMath: division by zero'
        if not totalStakes:
            revert with 0, 'SafeMath: division by zero'
        if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
            revert with 0, 'SafeMath: addition overflow'
        _1034 = mem[64]
        mem[64] = mem[64] + 64
        mem[_1034] = 30
        mem[_1034 + 32] = 'SafeMath: subtraction overflow'
        if t > ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored:
            revert with 0, 'SafeMath: subtraction overflow'
        mem[0] = arg1
        mem[32] = 17
        if not accountStakes[address(arg1)]:
            _1158 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1158] = 26
            mem[_1158 + 32] = 'SafeMath: division by zero'
            if s < 0:
                revert with 0, 'SafeMath: addition overflow'
            mem[0] = arg1
            mem[32] = 16
            _1214 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1214] = 30
            mem[_1214 + 32] = 'SafeMath: subtraction overflow'
            if sub_183ddbfb[address(arg1)].field_0 > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow'
            if sub_a70c1966 != 0:
                if not s:
                    if not sub_a70c1966:
                        revert with 0, 'SafeMath: division by zero'
                    if 0 / sub_a70c1966 <= s:
                        return (0 / sub_a70c1966)
                else:
                    if (block.timestamp * s) - (sub_183ddbfb[address(arg1)].field_0 * s) / s != block.timestamp - sub_183ddbfb[address(arg1)].field_0:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not sub_a70c1966:
                        revert with 0, 'SafeMath: division by zero'
                    if (block.timestamp * s) - (sub_183ddbfb[address(arg1)].field_0 * s) / sub_a70c1966 <= s:
                        return ((block.timestamp * s) - (sub_183ddbfb[address(arg1)].field_0 * s) / sub_a70c1966)
            return s
        if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / accountStakes[address(arg1)] != ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored - t:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _1170 = mem[64]
        mem[64] = mem[64] + 64
        mem[_1170] = 26
        mem[_1170 + 32] = 'SafeMath: division by zero'
        if s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18) < ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18:
            revert with 0, 'SafeMath: addition overflow'
        mem[0] = arg1
        mem[32] = 16
        _1239 = mem[64]
        mem[64] = mem[64] + 64
        mem[_1239] = 30
        mem[_1239 + 32] = 'SafeMath: subtraction overflow'
        if sub_183ddbfb[address(arg1)].field_0 > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow'
        if sub_a70c1966 != 0:
            if not s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18):
                if not sub_a70c1966:
                    revert with 0, 'SafeMath: division by zero'
                if 0 / sub_a70c1966 <= s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18):
                    return (0 / sub_a70c1966)
            else:
                if (s * block.timestamp) + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * block.timestamp) - (s * sub_183ddbfb[address(arg1)].field_0) - (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * sub_183ddbfb[address(arg1)].field_0) / s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18) != block.timestamp - sub_183ddbfb[address(arg1)].field_0:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not sub_a70c1966:
                    revert with 0, 'SafeMath: division by zero'
                if (s * block.timestamp) + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * block.timestamp) - (s * sub_183ddbfb[address(arg1)].field_0) - (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * sub_183ddbfb[address(arg1)].field_0) / sub_a70c1966 <= s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18):
                    return ((s * block.timestamp) + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * block.timestamp) - (s * sub_183ddbfb[address(arg1)].field_0) - (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * sub_183ddbfb[address(arg1)].field_0) / sub_a70c1966)
        return (s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18))
    _879 = mem[64]
    mem[64] = mem[64] + 64
    mem[_879] = 30
    mem[_879 + 32] = 'SafeMath: subtraction overflow'
    if lastUpdateTime > periodFinish:
        revert with 0, 'SafeMath: subtraction overflow'
    if not periodFinish - lastUpdateTime:
        _929 = mem[64]
        mem[64] = mem[64] + 64
        mem[_929] = 26
        mem[_929 + 32] = 'SafeMath: division by zero'
        if not totalStakes:
            revert with 0, 'SafeMath: division by zero'
        if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
            revert with 0, 'SafeMath: addition overflow'
        _1025 = mem[64]
        mem[64] = mem[64] + 64
        mem[_1025] = 30
        mem[_1025 + 32] = 'SafeMath: subtraction overflow'
        if t > (0 / totalStakes) + rewardPerTokenStored:
            revert with 0, 'SafeMath: subtraction overflow'
        mem[0] = arg1
        mem[32] = 17
        if not accountStakes[address(arg1)]:
            _1145 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1145] = 26
            mem[_1145 + 32] = 'SafeMath: division by zero'
            if s < 0:
                revert with 0, 'SafeMath: addition overflow'
            mem[0] = arg1
            mem[32] = 16
            _1208 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1208] = 30
            mem[_1208 + 32] = 'SafeMath: subtraction overflow'
            if sub_183ddbfb[address(arg1)].field_0 > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow'
            if sub_a70c1966 != 0:
                if not s:
                    if not sub_a70c1966:
                        revert with 0, 'SafeMath: division by zero'
                    if 0 / sub_a70c1966 <= s:
                        return (0 / sub_a70c1966)
                else:
                    if (block.timestamp * s) - (sub_183ddbfb[address(arg1)].field_0 * s) / s != block.timestamp - sub_183ddbfb[address(arg1)].field_0:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not sub_a70c1966:
                        revert with 0, 'SafeMath: division by zero'
                    if (block.timestamp * s) - (sub_183ddbfb[address(arg1)].field_0 * s) / sub_a70c1966 <= s:
                        return ((block.timestamp * s) - (sub_183ddbfb[address(arg1)].field_0 * s) / sub_a70c1966)
            return s
        if (0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / accountStakes[address(arg1)] != (0 / totalStakes) + rewardPerTokenStored - t:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _1161 = mem[64]
        mem[64] = mem[64] + 64
        mem[_1161] = 26
        mem[_1161 + 32] = 'SafeMath: division by zero'
        if s + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18) < (0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18:
            revert with 0, 'SafeMath: addition overflow'
        mem[0] = arg1
        mem[32] = 16
        _1227 = mem[64]
        mem[64] = mem[64] + 64
        mem[_1227] = 30
        mem[_1227 + 32] = 'SafeMath: subtraction overflow'
        if sub_183ddbfb[address(arg1)].field_0 > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow'
        if sub_a70c1966 != 0:
            if not s + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18):
                if not sub_a70c1966:
                    revert with 0, 'SafeMath: division by zero'
                if 0 / sub_a70c1966 <= s + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18):
                    return (0 / sub_a70c1966)
            else:
                if (s * block.timestamp) + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * block.timestamp) - (s * sub_183ddbfb[address(arg1)].field_0) - ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * sub_183ddbfb[address(arg1)].field_0) / s + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18) != block.timestamp - sub_183ddbfb[address(arg1)].field_0:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not sub_a70c1966:
                    revert with 0, 'SafeMath: division by zero'
                if (s * block.timestamp) + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * block.timestamp) - (s * sub_183ddbfb[address(arg1)].field_0) - ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * sub_183ddbfb[address(arg1)].field_0) / sub_a70c1966 <= s + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18):
                    return ((s * block.timestamp) + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * block.timestamp) - (s * sub_183ddbfb[address(arg1)].field_0) - ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * sub_183ddbfb[address(arg1)].field_0) / sub_a70c1966)
        return (s + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18))
    if (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) / periodFinish - lastUpdateTime != rewardRate:
        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
    if not (periodFinish * rewardRate) - (lastUpdateTime * rewardRate):
        _940 = mem[64]
        mem[64] = mem[64] + 64
        mem[_940] = 26
        mem[_940 + 32] = 'SafeMath: division by zero'
        if not totalStakes:
            revert with 0, 'SafeMath: division by zero'
        if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
            revert with 0, 'SafeMath: addition overflow'
        _1040 = mem[64]
        mem[64] = mem[64] + 64
        mem[_1040] = 30
        mem[_1040 + 32] = 'SafeMath: subtraction overflow'
        if t > (0 / totalStakes) + rewardPerTokenStored:
            revert with 0, 'SafeMath: subtraction overflow'
        mem[0] = arg1
        mem[32] = 17
        if not accountStakes[address(arg1)]:
            _1160 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1160] = 26
            mem[_1160 + 32] = 'SafeMath: division by zero'
            if s < 0:
                revert with 0, 'SafeMath: addition overflow'
            mem[0] = arg1
            mem[32] = 16
            _1226 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1226] = 30
            mem[_1226 + 32] = 'SafeMath: subtraction overflow'
            if sub_183ddbfb[address(arg1)].field_0 > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow'
            if sub_a70c1966 != 0:
                if not s:
                    if not sub_a70c1966:
                        revert with 0, 'SafeMath: division by zero'
                    if 0 / sub_a70c1966 <= s:
                        return (0 / sub_a70c1966)
                else:
                    if (block.timestamp * s) - (sub_183ddbfb[address(arg1)].field_0 * s) / s != block.timestamp - sub_183ddbfb[address(arg1)].field_0:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not sub_a70c1966:
                        revert with 0, 'SafeMath: division by zero'
                    if (block.timestamp * s) - (sub_183ddbfb[address(arg1)].field_0 * s) / sub_a70c1966 <= s:
                        return ((block.timestamp * s) - (sub_183ddbfb[address(arg1)].field_0 * s) / sub_a70c1966)
            return s
        if (0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / accountStakes[address(arg1)] != (0 / totalStakes) + rewardPerTokenStored - t:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _1172 = mem[64]
        mem[64] = mem[64] + 64
        mem[_1172] = 26
        mem[_1172 + 32] = 'SafeMath: division by zero'
        if s + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18) < (0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18:
            revert with 0, 'SafeMath: addition overflow'
        mem[0] = arg1
        mem[32] = 16
        _1253 = mem[64]
        mem[64] = mem[64] + 64
        mem[_1253] = 30
        mem[_1253 + 32] = 'SafeMath: subtraction overflow'
        if sub_183ddbfb[address(arg1)].field_0 > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow'
        if sub_a70c1966 != 0:
            if not s + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18):
                if not sub_a70c1966:
                    revert with 0, 'SafeMath: division by zero'
                if 0 / sub_a70c1966 <= s + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18):
                    return (0 / sub_a70c1966)
            else:
                if (s * block.timestamp) + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * block.timestamp) - (s * sub_183ddbfb[address(arg1)].field_0) - ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * sub_183ddbfb[address(arg1)].field_0) / s + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18) != block.timestamp - sub_183ddbfb[address(arg1)].field_0:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not sub_a70c1966:
                    revert with 0, 'SafeMath: division by zero'
                if (s * block.timestamp) + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * block.timestamp) - (s * sub_183ddbfb[address(arg1)].field_0) - ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * sub_183ddbfb[address(arg1)].field_0) / sub_a70c1966 <= s + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18):
                    return ((s * block.timestamp) + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * block.timestamp) - (s * sub_183ddbfb[address(arg1)].field_0) - ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * sub_183ddbfb[address(arg1)].field_0) / sub_a70c1966)
        return (s + ((0 / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18))
    if (10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
    _953 = mem[64]
    mem[64] = mem[64] + 64
    mem[_953] = 26
    mem[_953 + 32] = 'SafeMath: division by zero'
    if not totalStakes:
        revert with 0, 'SafeMath: division by zero'
    if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
        revert with 0, 'SafeMath: addition overflow'
    _1061 = mem[64]
    mem[64] = mem[64] + 64
    mem[_1061] = 30
    mem[_1061 + 32] = 'SafeMath: subtraction overflow'
    if t > ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored:
        revert with 0, 'SafeMath: subtraction overflow'
    mem[0] = arg1
    mem[32] = 17
    if not accountStakes[address(arg1)]:
        _1171 = mem[64]
        mem[64] = mem[64] + 64
        mem[_1171] = 26
        mem[_1171 + 32] = 'SafeMath: division by zero'
        if s < 0:
            revert with 0, 'SafeMath: addition overflow'
        mem[0] = arg1
        mem[32] = 16
        _1252 = mem[64]
        mem[64] = mem[64] + 64
        mem[_1252] = 30
        mem[_1252 + 32] = 'SafeMath: subtraction overflow'
        if sub_183ddbfb[address(arg1)].field_0 > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow'
        if sub_a70c1966 != 0:
            if not s:
                if not sub_a70c1966:
                    revert with 0, 'SafeMath: division by zero'
                if 0 / sub_a70c1966 <= s:
                    return (0 / sub_a70c1966)
            else:
                if (block.timestamp * s) - (sub_183ddbfb[address(arg1)].field_0 * s) / s != block.timestamp - sub_183ddbfb[address(arg1)].field_0:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not sub_a70c1966:
                    revert with 0, 'SafeMath: division by zero'
                if (block.timestamp * s) - (sub_183ddbfb[address(arg1)].field_0 * s) / sub_a70c1966 <= s:
                    return ((block.timestamp * s) - (sub_183ddbfb[address(arg1)].field_0 * s) / sub_a70c1966)
        return s
    if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / accountStakes[address(arg1)] != ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored - t:
        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
    _1177 = mem[64]
    mem[64] = mem[64] + 64
    mem[_1177] = 26
    mem[_1177 + 32] = 'SafeMath: division by zero'
    if s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18) < ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18:
        revert with 0, 'SafeMath: addition overflow'
    mem[0] = arg1
    mem[32] = 16
    _1285 = mem[64]
    mem[64] = mem[64] + 64
    mem[_1285] = 30
    mem[_1285 + 32] = 'SafeMath: subtraction overflow'
    if sub_183ddbfb[address(arg1)].field_0 > block.timestamp:
        revert with 0, 'SafeMath: subtraction overflow'
    if sub_a70c1966 != 0:
        if not s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18):
            if not sub_a70c1966:
                revert with 0, 'SafeMath: division by zero'
            if 0 / sub_a70c1966 <= s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18):
                return (0 / sub_a70c1966)
        else:
            if (s * block.timestamp) + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * block.timestamp) - (s * sub_183ddbfb[address(arg1)].field_0) - (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * sub_183ddbfb[address(arg1)].field_0) / s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18) != block.timestamp - sub_183ddbfb[address(arg1)].field_0:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not sub_a70c1966:
                revert with 0, 'SafeMath: division by zero'
            if (s * block.timestamp) + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * block.timestamp) - (s * sub_183ddbfb[address(arg1)].field_0) - (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * sub_183ddbfb[address(arg1)].field_0) / sub_a70c1966 <= s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18):
                return ((s * block.timestamp) + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * block.timestamp) - (s * sub_183ddbfb[address(arg1)].field_0) - (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18 * sub_183ddbfb[address(arg1)].field_0) / sub_a70c1966)
    return (s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(arg1)]) + (rewardPerTokenStored * accountStakes[address(arg1)]) - (t * accountStakes[address(arg1)]) / 10^18))
}

function stake(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    stor1++
    if block.timestamp < startTime:
        revert with 0, 'not started yet'
    if 0 == totalStakes:
        if block.timestamp < periodFinish:
            lastUpdateTime = block.timestamp
            if not msg.sender:
                if arg1 <= 0:
                    revert with 0, 'staking 0'
                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                    revert with 0, 'SafeERC20: call to non-contract'
                if not ext_code.hash(stakingTokenAddress):
                    revert with 0, 'SafeERC20: call to non-contract'
                mem[228 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg1) >> 32
                mem[352 len 4] = uint32(arg1)
                call stakingTokenAddress with:
                     gas gas_remaining wei
                    args Mask(224, 32, arg1) << 480, mem[324 len 4]
                if not return_data.size:
                    if not ext_call.success:
                        revert with 0, 'SafeERC20: low-level call failed'
                    if not unknown_0x23b872dd(?????), Mask(224, 32, msg.sender) >> 32:
                        revert with 0, 
                                    32,
                                    42,
                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[338 len 14],
                                    uint32(arg1),
                                    mem[356 len 4]
                else:
                    mem[260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        if not mem[260]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[ceil32(return_data.size) + 339 len 22]
            else:
                mem[96] = 0
                mem[128] = 0
                mem[160] = 0
                mem[192] = 0
                mem[0] = msg.sender
                mem[32] = 16
                mem[64] = 352
                mem[224] = sub_183ddbfb[address(msg.sender)].field_0
                mem[256] = sub_183ddbfb[address(msg.sender)].field_256
                mem[288] = sub_183ddbfb[address(msg.sender)].field_512
                mem[320] = sub_183ddbfb[address(msg.sender)].field_768
                idx = sub_183ddbfb[address(msg.sender)].field_768
                s = sub_183ddbfb[address(msg.sender)].field_512
                t = sub_183ddbfb[address(msg.sender)].field_256
                while idx < sub_e7690c44:
                    require idx < sub_155b0a71.length
                    mem[0] = 15
                    if not t:
                        _32489 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32489] = 26
                        mem[_32489 + 32] = 'SafeMath: division by zero'
                        require idx < sub_155b0a71.length
                        mem[0] = 15
                        if not s:
                            _33722 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33722] = 26
                            mem[_33722 + 32] = 'SafeMath: division by zero'
                            idx = idx + 1
                            s = 0
                            t = 0
                            continue 
                        if sub_155b0a71[idx] * s / s != sub_155b0a71[idx]:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _33806 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33806] = 26
                        mem[_33806 + 32] = 'SafeMath: division by zero'
                        idx = idx + 1
                        s = sub_155b0a71[idx] * s / 10^18
                        t = 0
                        continue 
                    if sub_155b0a71[idx] * t / t != sub_155b0a71[idx]:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _32614 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32614] = 26
                    mem[_32614 + 32] = 'SafeMath: division by zero'
                    require idx < sub_155b0a71.length
                    mem[0] = 15
                    if not s:
                        _33805 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33805] = 26
                        mem[_33805 + 32] = 'SafeMath: division by zero'
                        idx = idx + 1
                        s = 0
                        t = sub_155b0a71[idx] * t / 10^18
                        continue 
                    if sub_155b0a71[idx] * s / s != sub_155b0a71[idx]:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _33823 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_33823] = 26
                    mem[_33823 + 32] = 'SafeMath: division by zero'
                    idx = idx + 1
                    s = sub_155b0a71[idx] * s / 10^18
                    t = sub_155b0a71[idx] * t / 10^18
                    continue 
                if 0 == totalStakes:
                    _32417 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32417] = 30
                    mem[_32417 + 32] = 'SafeMath: subtraction overflow'
                    if t > rewardPerTokenStored:
                        revert with 0, 'SafeMath: subtraction overflow'
                    mem[0] = msg.sender
                    mem[32] = 17
                    if not accountStakes[address(msg.sender)]:
                        _33407 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33407] = 26
                        mem[_33407 + 32] = 'SafeMath: division by zero'
                        if s < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        sub_183ddbfb[address(msg.sender)].field_512 = s
                        sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                        sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                        if sub_183ddbfb[address(msg.sender)].field_0:
                            if arg1 <= 0:
                                revert with 0, 'staking 0'
                            _34455 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = this.address
                            mem[mem[64] + 100] = arg1
                            _34456 = mem[64]
                            mem[mem[64]] = 100
                            mem[64] = mem[64] + 132
                            mem[_34456 + 32 len 4] = unknown_0x23b872dd(?????)
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                revert with 0, 'SafeERC20: call to non-contract'
                            if not ext_code.hash(stakingTokenAddress):
                                revert with 0, 'SafeERC20: call to non-contract'
                            _35099 = mem[_34456]
                            mem[_34455 + 132 len floor32(mem[_34456])] = mem[_34456 + 32 len floor32(mem[_34456])]
                            mem[_34455 + floor32(mem[_34456]) + -(mem[_34456] % 32) + 164 len mem[_34456] % 32] = mem[_34456 + -(mem[_34456] % 32) + floor32(mem[_34456]) + 64 len mem[_34456] % 32]
                            call stakingTokenAddress.mem[_34455 + 132 len 4] with:
                                 gas gas_remaining wei
                                args mem[_34455 + 136 len _35099 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if mem[96]:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_34455 + 242 len 22]
                            else:
                                mem[_34455 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[_34455 + 164]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_34455 + ceil32(return_data.size) + 243 len 22]
                        else:
                            sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                            if arg1 <= 0:
                                revert with 0, 'staking 0'
                            _34648 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = this.address
                            mem[mem[64] + 100] = arg1
                            _34649 = mem[64]
                            mem[mem[64]] = 100
                            mem[64] = mem[64] + 132
                            mem[_34649 + 32 len 4] = unknown_0x23b872dd(?????)
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                revert with 0, 'SafeERC20: call to non-contract'
                            if not ext_code.hash(stakingTokenAddress):
                                revert with 0, 'SafeERC20: call to non-contract'
                            _35201 = mem[_34649]
                            mem[_34648 + 132 len floor32(mem[_34649])] = mem[_34649 + 32 len floor32(mem[_34649])]
                            mem[_34648 + floor32(mem[_34649]) + -(mem[_34649] % 32) + 164 len mem[_34649] % 32] = mem[_34649 + -(mem[_34649] % 32) + floor32(mem[_34649]) + 64 len mem[_34649] % 32]
                            call stakingTokenAddress.mem[_34648 + 132 len 4] with:
                                 gas gas_remaining wei
                                args mem[_34648 + 136 len _35201 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if mem[96]:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_34648 + 242 len 22]
                            else:
                                mem[_34648 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[_34648 + 164]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_34648 + ceil32(return_data.size) + 243 len 22]
                    else:
                        if (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != rewardPerTokenStored - t:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _33659 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33659] = 26
                        mem[_33659 + 32] = 'SafeMath: division by zero'
                        if s + ((rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        sub_183ddbfb[address(msg.sender)].field_512 = s + ((rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                        sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                        sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                        if sub_183ddbfb[address(msg.sender)].field_0:
                            if arg1 <= 0:
                                revert with 0, 'staking 0'
                            _34777 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = this.address
                            mem[mem[64] + 100] = arg1
                            _34778 = mem[64]
                            mem[mem[64]] = 100
                            mem[64] = mem[64] + 132
                            mem[_34778 + 32 len 4] = unknown_0x23b872dd(?????)
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                revert with 0, 'SafeERC20: call to non-contract'
                            if not ext_code.hash(stakingTokenAddress):
                                revert with 0, 'SafeERC20: call to non-contract'
                            _35360 = mem[_34778]
                            mem[_34777 + 132 len floor32(mem[_34778])] = mem[_34778 + 32 len floor32(mem[_34778])]
                            mem[_34777 + floor32(mem[_34778]) + -(mem[_34778] % 32) + 164 len mem[_34778] % 32] = mem[_34778 + -(mem[_34778] % 32) + floor32(mem[_34778]) + 64 len mem[_34778] % 32]
                            call stakingTokenAddress.mem[_34777 + 132 len 4] with:
                                 gas gas_remaining wei
                                args mem[_34777 + 136 len _35360 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if mem[96]:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_34777 + 242 len 22]
                            else:
                                mem[_34777 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[_34777 + 164]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_34777 + ceil32(return_data.size) + 243 len 22]
                        else:
                            sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                            if arg1 <= 0:
                                revert with 0, 'staking 0'
                            _34918 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = this.address
                            mem[mem[64] + 100] = arg1
                            _34919 = mem[64]
                            mem[mem[64]] = 100
                            mem[64] = mem[64] + 132
                            mem[_34919 + 32 len 4] = unknown_0x23b872dd(?????)
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                revert with 0, 'SafeERC20: call to non-contract'
                            if not ext_code.hash(stakingTokenAddress):
                                revert with 0, 'SafeERC20: call to non-contract'
                            _35579 = mem[_34919]
                            mem[_34918 + 132 len floor32(mem[_34919])] = mem[_34919 + 32 len floor32(mem[_34919])]
                            mem[_34918 + floor32(mem[_34919]) + -(mem[_34919] % 32) + 164 len mem[_34919] % 32] = mem[_34919 + -(mem[_34919] % 32) + floor32(mem[_34919]) + 64 len mem[_34919] % 32]
                            call stakingTokenAddress.mem[_34918 + 132 len 4] with:
                                 gas gas_remaining wei
                                args mem[_34918 + 136 len _35579 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if mem[96]:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_34918 + 242 len 22]
                            else:
                                mem[_34918 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[_34918 + 164]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_34918 + ceil32(return_data.size) + 243 len 22]
                else:
                    if block.timestamp < periodFinish:
                        _32657 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32657] = 30
                        mem[_32657 + 32] = 'SafeMath: subtraction overflow'
                        if lastUpdateTime > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.timestamp - lastUpdateTime:
                            _33861 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33861] = 26
                            mem[_33861 + 32] = 'SafeMath: division by zero'
                            if not totalStakes:
                                revert with 0, 'SafeMath: division by zero'
                            if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                revert with 0, 'SafeMath: addition overflow'
                            _35197 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35197] = 30
                            mem[_35197 + 32] = 'SafeMath: subtraction overflow'
                            if t > (0 / totalStakes) + rewardPerTokenStored:
                                revert with 0, 'SafeMath: subtraction overflow'
                            mem[0] = msg.sender
                            mem[32] = 17
                            if not accountStakes[address(msg.sender)]:
                                _37563 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_37563] = 26
                                mem[_37563 + 32] = 'SafeMath: division by zero'
                                if s < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                if sub_183ddbfb[address(msg.sender)].field_0:
                                    if arg1 <= 0:
                                        revert with 0, 'staking 0'
                                    _40521 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = this.address
                                    mem[mem[64] + 100] = arg1
                                    _40522 = mem[64]
                                    mem[mem[64]] = 100
                                    mem[64] = mem[64] + 132
                                    mem[_40522 + 32 len 4] = unknown_0x23b872dd(?????)
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    _41712 = mem[_40522]
                                    mem[_40521 + 132 len floor32(mem[_40522])] = mem[_40522 + 32 len floor32(mem[_40522])]
                                    mem[_40521 + floor32(mem[_40522]) + -(mem[_40522] % 32) + 164 len mem[_40522] % 32] = mem[_40522 + -(mem[_40522] % 32) + floor32(mem[_40522]) + 64 len mem[_40522] % 32]
                                    call stakingTokenAddress.mem[_40521 + 132 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_40521 + 136 len _41712 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_40521 + 242 len 22]
                                    else:
                                        mem[_40521 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[_40521 + 164]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_40521 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                    if arg1 <= 0:
                                        revert with 0, 'staking 0'
                                    _40667 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = this.address
                                    mem[mem[64] + 100] = arg1
                                    _40668 = mem[64]
                                    mem[mem[64]] = 100
                                    mem[64] = mem[64] + 132
                                    mem[_40668 + 32 len 4] = unknown_0x23b872dd(?????)
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    _42009 = mem[_40668]
                                    mem[_40667 + 132 len floor32(mem[_40668])] = mem[_40668 + 32 len floor32(mem[_40668])]
                                    mem[_40667 + floor32(mem[_40668]) + -(mem[_40668] % 32) + 164 len mem[_40668] % 32] = mem[_40668 + -(mem[_40668] % 32) + floor32(mem[_40668]) + 64 len mem[_40668] % 32]
                                    call stakingTokenAddress.mem[_40667 + 132 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_40667 + 136 len _42009 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_40667 + 242 len 22]
                                    else:
                                        mem[_40667 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[_40667 + 164]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_40667 + ceil32(return_data.size) + 243 len 22]
                            else:
                                if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _38038 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38038] = 26
                                mem[_38038 + 32] = 'SafeMath: division by zero'
                                if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                if sub_183ddbfb[address(msg.sender)].field_0:
                                    if arg1 <= 0:
                                        revert with 0, 'staking 0'
                                    _40870 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = this.address
                                    mem[mem[64] + 100] = arg1
                                    _40871 = mem[64]
                                    mem[mem[64]] = 100
                                    mem[64] = mem[64] + 132
                                    mem[_40871 + 32 len 4] = unknown_0x23b872dd(?????)
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    _42451 = mem[_40871]
                                    mem[_40870 + 132 len floor32(mem[_40871])] = mem[_40871 + 32 len floor32(mem[_40871])]
                                    mem[_40870 + floor32(mem[_40871]) + -(mem[_40871] % 32) + 164 len mem[_40871] % 32] = mem[_40871 + -(mem[_40871] % 32) + floor32(mem[_40871]) + 64 len mem[_40871] % 32]
                                    call stakingTokenAddress.mem[_40870 + 132 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_40870 + 136 len _42451 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_40870 + 242 len 22]
                                    else:
                                        mem[_40870 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[_40870 + 164]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_40870 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                    if arg1 <= 0:
                                        revert with 0, 'staking 0'
                                    _41106 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = this.address
                                    mem[mem[64] + 100] = arg1
                                    _41107 = mem[64]
                                    mem[mem[64]] = 100
                                    mem[64] = mem[64] + 132
                                    mem[_41107 + 32 len 4] = unknown_0x23b872dd(?????)
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    _42850 = mem[_41107]
                                    mem[_41106 + 132 len floor32(mem[_41107])] = mem[_41107 + 32 len floor32(mem[_41107])]
                                    mem[_41106 + floor32(mem[_41107]) + -(mem[_41107] % 32) + 164 len mem[_41107] % 32] = mem[_41107 + -(mem[_41107] % 32) + floor32(mem[_41107]) + 64 len mem[_41107] % 32]
                                    call stakingTokenAddress.mem[_41106 + 132 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_41106 + 136 len _42850 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_41106 + 242 len 22]
                                    else:
                                        mem[_41106 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[_41106 + 164]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_41106 + ceil32(return_data.size) + 243 len 22]
                        else:
                            if (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) / block.timestamp - lastUpdateTime != rewardRate:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate):
                                _33979 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33979] = 26
                                mem[_33979 + 32] = 'SafeMath: division by zero'
                                if not totalStakes:
                                    revert with 0, 'SafeMath: division by zero'
                                if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                    revert with 0, 'SafeMath: addition overflow'
                                _35571 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35571] = 30
                                mem[_35571 + 32] = 'SafeMath: subtraction overflow'
                                if t > (0 / totalStakes) + rewardPerTokenStored:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 17
                                if not accountStakes[address(msg.sender)]:
                                    _38037 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38037] = 26
                                    mem[_38037 + 32] = 'SafeMath: division by zero'
                                    if s < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_183ddbfb[address(msg.sender)].field_512 = s
                                    sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                    sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                    if sub_183ddbfb[address(msg.sender)].field_0:
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _40865 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _40866 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_40866 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _42445 = mem[_40866]
                                        mem[_40865 + 132 len floor32(mem[_40866])] = mem[_40866 + 32 len floor32(mem[_40866])]
                                        mem[_40865 + floor32(mem[_40866]) + -(mem[_40866] % 32) + 164 len mem[_40866] % 32] = mem[_40866 + -(mem[_40866] % 32) + floor32(mem[_40866]) + 64 len mem[_40866] % 32]
                                        call stakingTokenAddress.mem[_40865 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_40865 + 136 len _42445 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_40865 + 242 len 22]
                                        else:
                                            mem[_40865 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_40865 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_40865 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _41103 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _41104 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_41104 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _42844 = mem[_41104]
                                        mem[_41103 + 132 len floor32(mem[_41104])] = mem[_41104 + 32 len floor32(mem[_41104])]
                                        mem[_41103 + floor32(mem[_41104]) + -(mem[_41104] % 32) + 164 len mem[_41104] % 32] = mem[_41104 + -(mem[_41104] % 32) + floor32(mem[_41104]) + 64 len mem[_41104] % 32]
                                        call stakingTokenAddress.mem[_41103 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_41103 + 136 len _42844 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_41103 + 242 len 22]
                                        else:
                                            mem[_41103 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_41103 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_41103 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _38498 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38498] = 26
                                    mem[_38498 + 32] = 'SafeMath: division by zero'
                                    if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                    sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                    sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                    if sub_183ddbfb[address(msg.sender)].field_0:
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _41378 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _41379 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_41379 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _43386 = mem[_41379]
                                        mem[_41378 + 132 len floor32(mem[_41379])] = mem[_41379 + 32 len floor32(mem[_41379])]
                                        mem[_41378 + floor32(mem[_41379]) + -(mem[_41379] % 32) + 164 len mem[_41379] % 32] = mem[_41379 + -(mem[_41379] % 32) + floor32(mem[_41379]) + 64 len mem[_41379] % 32]
                                        call stakingTokenAddress.mem[_41378 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_41378 + 136 len _43386 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_41378 + 242 len 22]
                                        else:
                                            mem[_41378 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_41378 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_41378 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _41706 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _41707 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_41707 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _44006 = mem[_41707]
                                        mem[_41706 + 132 len floor32(mem[_41707])] = mem[_41707 + 32 len floor32(mem[_41707])]
                                        mem[_41706 + floor32(mem[_41707]) + -(mem[_41707] % 32) + 164 len mem[_41707] % 32] = mem[_41707 + -(mem[_41707] % 32) + floor32(mem[_41707]) + 64 len mem[_41707] % 32]
                                        call stakingTokenAddress.mem[_41706 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_41706 + 136 len _44006 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_41706 + 242 len 22]
                                        else:
                                            mem[_41706 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_41706 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_41706 + ceil32(return_data.size) + 243 len 22]
                            else:
                                if (10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _34129 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34129] = 26
                                mem[_34129 + 32] = 'SafeMath: division by zero'
                                if not totalStakes:
                                    revert with 0, 'SafeMath: division by zero'
                                if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                    revert with 0, 'SafeMath: addition overflow'
                                _35939 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35939] = 30
                                mem[_35939 + 32] = 'SafeMath: subtraction overflow'
                                if t > ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 17
                                if not accountStakes[address(msg.sender)]:
                                    _38497 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38497] = 26
                                    mem[_38497 + 32] = 'SafeMath: division by zero'
                                    if s < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_183ddbfb[address(msg.sender)].field_512 = s
                                    sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                    sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                    if sub_183ddbfb[address(msg.sender)].field_0:
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _41373 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _41374 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_41374 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _43380 = mem[_41374]
                                        mem[_41373 + 132 len floor32(mem[_41374])] = mem[_41374 + 32 len floor32(mem[_41374])]
                                        mem[_41373 + floor32(mem[_41374]) + -(mem[_41374] % 32) + 164 len mem[_41374] % 32] = mem[_41374 + -(mem[_41374] % 32) + floor32(mem[_41374]) + 64 len mem[_41374] % 32]
                                        call stakingTokenAddress.mem[_41373 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_41373 + 136 len _43380 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_41373 + 242 len 22]
                                        else:
                                            mem[_41373 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_41373 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_41373 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _41703 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _41704 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_41704 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _44000 = mem[_41704]
                                        mem[_41703 + 132 len floor32(mem[_41704])] = mem[_41704 + 32 len floor32(mem[_41704])]
                                        mem[_41703 + floor32(mem[_41704]) + -(mem[_41704] % 32) + 164 len mem[_41704] % 32] = mem[_41704 + -(mem[_41704] % 32) + floor32(mem[_41704]) + 64 len mem[_41704] % 32]
                                        call stakingTokenAddress.mem[_41703 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_41703 + 136 len _44000 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_41703 + 242 len 22]
                                        else:
                                            mem[_41703 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_41703 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_41703 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored - t:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39057 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39057] = 26
                                    mem[_39057 + 32] = 'SafeMath: division by zero'
                                    if s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_183ddbfb[address(msg.sender)].field_512 = s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                    sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                    sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                    if sub_183ddbfb[address(msg.sender)].field_0:
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _42001 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _42002 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_42002 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _44630 = mem[_42002]
                                        mem[_42001 + 132 len floor32(mem[_42002])] = mem[_42002 + 32 len floor32(mem[_42002])]
                                        mem[_42001 + floor32(mem[_42002]) + -(mem[_42002] % 32) + 164 len mem[_42002] % 32] = mem[_42002 + -(mem[_42002] % 32) + floor32(mem[_42002]) + 64 len mem[_42002] % 32]
                                        call stakingTokenAddress.mem[_42001 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_42001 + 136 len _44630 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_42001 + 242 len 22]
                                        else:
                                            mem[_42001 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_42001 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_42001 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _42439 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _42440 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_42440 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _45440 = mem[_42440]
                                        mem[_42439 + 132 len floor32(mem[_42440])] = mem[_42440 + 32 len floor32(mem[_42440])]
                                        mem[_42439 + floor32(mem[_42440]) + -(mem[_42440] % 32) + 164 len mem[_42440] % 32] = mem[_42440 + -(mem[_42440] % 32) + floor32(mem[_42440]) + 64 len mem[_42440] % 32]
                                        call stakingTokenAddress.mem[_42439 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_42439 + 136 len _45440 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_42439 + 242 len 22]
                                        else:
                                            mem[_42439 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_42439 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_42439 + ceil32(return_data.size) + 243 len 22]
                    else:
                        _32864 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32864] = 30
                        mem[_32864 + 32] = 'SafeMath: subtraction overflow'
                        if lastUpdateTime > periodFinish:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not periodFinish - lastUpdateTime:
                            _33983 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33983] = 26
                            mem[_33983 + 32] = 'SafeMath: division by zero'
                            if not totalStakes:
                                revert with 0, 'SafeMath: division by zero'
                            if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                revert with 0, 'SafeMath: addition overflow'
                            _35575 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35575] = 30
                            mem[_35575 + 32] = 'SafeMath: subtraction overflow'
                            if t > (0 / totalStakes) + rewardPerTokenStored:
                                revert with 0, 'SafeMath: subtraction overflow'
                            mem[0] = msg.sender
                            mem[32] = 17
                            if not accountStakes[address(msg.sender)]:
                                _38041 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38041] = 26
                                mem[_38041 + 32] = 'SafeMath: division by zero'
                                if s < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                if sub_183ddbfb[address(msg.sender)].field_0:
                                    if arg1 <= 0:
                                        revert with 0, 'staking 0'
                                    _40875 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = this.address
                                    mem[mem[64] + 100] = arg1
                                    _40876 = mem[64]
                                    mem[mem[64]] = 100
                                    mem[64] = mem[64] + 132
                                    mem[_40876 + 32 len 4] = unknown_0x23b872dd(?????)
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    _42469 = mem[_40876]
                                    mem[_40875 + 132 len floor32(mem[_40876])] = mem[_40876 + 32 len floor32(mem[_40876])]
                                    mem[_40875 + floor32(mem[_40876]) + -(mem[_40876] % 32) + 164 len mem[_40876] % 32] = mem[_40876 + -(mem[_40876] % 32) + floor32(mem[_40876]) + 64 len mem[_40876] % 32]
                                    call stakingTokenAddress.mem[_40875 + 132 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_40875 + 136 len _42469 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_40875 + 242 len 22]
                                    else:
                                        mem[_40875 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[_40875 + 164]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_40875 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                    if arg1 <= 0:
                                        revert with 0, 'staking 0'
                                    _41113 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = this.address
                                    mem[mem[64] + 100] = arg1
                                    _41114 = mem[64]
                                    mem[mem[64]] = 100
                                    mem[64] = mem[64] + 132
                                    mem[_41114 + 32 len 4] = unknown_0x23b872dd(?????)
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    _42866 = mem[_41114]
                                    mem[_41113 + 132 len floor32(mem[_41114])] = mem[_41114 + 32 len floor32(mem[_41114])]
                                    mem[_41113 + floor32(mem[_41114]) + -(mem[_41114] % 32) + 164 len mem[_41114] % 32] = mem[_41114 + -(mem[_41114] % 32) + floor32(mem[_41114]) + 64 len mem[_41114] % 32]
                                    call stakingTokenAddress.mem[_41113 + 132 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_41113 + 136 len _42866 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_41113 + 242 len 22]
                                    else:
                                        mem[_41113 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[_41113 + 164]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_41113 + ceil32(return_data.size) + 243 len 22]
                            else:
                                if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _38500 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38500] = 26
                                mem[_38500 + 32] = 'SafeMath: division by zero'
                                if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                if sub_183ddbfb[address(msg.sender)].field_0:
                                    if arg1 <= 0:
                                        revert with 0, 'staking 0'
                                    _41388 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = this.address
                                    mem[mem[64] + 100] = arg1
                                    _41389 = mem[64]
                                    mem[mem[64]] = 100
                                    mem[64] = mem[64] + 132
                                    mem[_41389 + 32 len 4] = unknown_0x23b872dd(?????)
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    _43410 = mem[_41389]
                                    mem[_41388 + 132 len floor32(mem[_41389])] = mem[_41389 + 32 len floor32(mem[_41389])]
                                    mem[_41388 + floor32(mem[_41389]) + -(mem[_41389] % 32) + 164 len mem[_41389] % 32] = mem[_41389 + -(mem[_41389] % 32) + floor32(mem[_41389]) + 64 len mem[_41389] % 32]
                                    call stakingTokenAddress.mem[_41388 + 132 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_41388 + 136 len _43410 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_41388 + 242 len 22]
                                    else:
                                        mem[_41388 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[_41388 + 164]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_41388 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                    if arg1 <= 0:
                                        revert with 0, 'staking 0'
                                    _41722 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = this.address
                                    mem[mem[64] + 100] = arg1
                                    _41723 = mem[64]
                                    mem[mem[64]] = 100
                                    mem[64] = mem[64] + 132
                                    mem[_41723 + 32 len 4] = unknown_0x23b872dd(?????)
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    _44034 = mem[_41723]
                                    mem[_41722 + 132 len floor32(mem[_41723])] = mem[_41723 + 32 len floor32(mem[_41723])]
                                    mem[_41722 + floor32(mem[_41723]) + -(mem[_41723] % 32) + 164 len mem[_41723] % 32] = mem[_41723 + -(mem[_41723] % 32) + floor32(mem[_41723]) + 64 len mem[_41723] % 32]
                                    call stakingTokenAddress.mem[_41722 + 132 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_41722 + 136 len _44034 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_41722 + 242 len 22]
                                    else:
                                        mem[_41722 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[_41722 + 164]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_41722 + ceil32(return_data.size) + 243 len 22]
                        else:
                            if (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) / periodFinish - lastUpdateTime != rewardRate:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not (periodFinish * rewardRate) - (lastUpdateTime * rewardRate):
                                _34134 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34134] = 26
                                mem[_34134 + 32] = 'SafeMath: division by zero'
                                if not totalStakes:
                                    revert with 0, 'SafeMath: division by zero'
                                if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                    revert with 0, 'SafeMath: addition overflow'
                                _35945 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35945] = 30
                                mem[_35945 + 32] = 'SafeMath: subtraction overflow'
                                if t > (0 / totalStakes) + rewardPerTokenStored:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 17
                                if not accountStakes[address(msg.sender)]:
                                    _38499 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38499] = 26
                                    mem[_38499 + 32] = 'SafeMath: division by zero'
                                    if s < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_183ddbfb[address(msg.sender)].field_512 = s
                                    sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                    sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                    if sub_183ddbfb[address(msg.sender)].field_0:
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _41383 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _41384 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_41384 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _43404 = mem[_41384]
                                        mem[_41383 + 132 len floor32(mem[_41384])] = mem[_41384 + 32 len floor32(mem[_41384])]
                                        mem[_41383 + floor32(mem[_41384]) + -(mem[_41384] % 32) + 164 len mem[_41384] % 32] = mem[_41384 + -(mem[_41384] % 32) + floor32(mem[_41384]) + 64 len mem[_41384] % 32]
                                        call stakingTokenAddress.mem[_41383 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_41383 + 136 len _43404 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_41383 + 242 len 22]
                                        else:
                                            mem[_41383 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_41383 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_41383 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _41719 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _41720 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_41720 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _44028 = mem[_41720]
                                        mem[_41719 + 132 len floor32(mem[_41720])] = mem[_41720 + 32 len floor32(mem[_41720])]
                                        mem[_41719 + floor32(mem[_41720]) + -(mem[_41720] % 32) + 164 len mem[_41720] % 32] = mem[_41720 + -(mem[_41720] % 32) + floor32(mem[_41720]) + 64 len mem[_41720] % 32]
                                        call stakingTokenAddress.mem[_41719 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_41719 + 136 len _44028 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_41719 + 242 len 22]
                                        else:
                                            mem[_41719 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_41719 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_41719 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39059 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39059] = 26
                                    mem[_39059 + 32] = 'SafeMath: division by zero'
                                    if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                    sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                    sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                    if sub_183ddbfb[address(msg.sender)].field_0:
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _42017 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _42018 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_42018 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _44660 = mem[_42018]
                                        mem[_42017 + 132 len floor32(mem[_42018])] = mem[_42018 + 32 len floor32(mem[_42018])]
                                        mem[_42017 + floor32(mem[_42018]) + -(mem[_42018] % 32) + 164 len mem[_42018] % 32] = mem[_42018 + -(mem[_42018] % 32) + floor32(mem[_42018]) + 64 len mem[_42018] % 32]
                                        call stakingTokenAddress.mem[_42017 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_42017 + 136 len _44660 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_42017 + 242 len 22]
                                        else:
                                            mem[_42017 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_42017 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_42017 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _42463 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _42464 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_42464 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _45478 = mem[_42464]
                                        mem[_42463 + 132 len floor32(mem[_42464])] = mem[_42464 + 32 len floor32(mem[_42464])]
                                        mem[_42463 + floor32(mem[_42464]) + -(mem[_42464] % 32) + 164 len mem[_42464] % 32] = mem[_42464 + -(mem[_42464] % 32) + floor32(mem[_42464]) + 64 len mem[_42464] % 32]
                                        call stakingTokenAddress.mem[_42463 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_42463 + 136 len _45478 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_42463 + 242 len 22]
                                        else:
                                            mem[_42463 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_42463 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_42463 + ceil32(return_data.size) + 243 len 22]
                            else:
                                if (10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _34324 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34324] = 26
                                mem[_34324 + 32] = 'SafeMath: division by zero'
                                if not totalStakes:
                                    revert with 0, 'SafeMath: division by zero'
                                if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                    revert with 0, 'SafeMath: addition overflow'
                                _36460 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_36460] = 30
                                mem[_36460 + 32] = 'SafeMath: subtraction overflow'
                                if t > ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 17
                                if not accountStakes[address(msg.sender)]:
                                    _39058 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39058] = 26
                                    mem[_39058 + 32] = 'SafeMath: division by zero'
                                    if s < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_183ddbfb[address(msg.sender)].field_512 = s
                                    sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                    sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                    if sub_183ddbfb[address(msg.sender)].field_0:
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _42012 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _42013 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_42013 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _44654 = mem[_42013]
                                        mem[_42012 + 132 len floor32(mem[_42013])] = mem[_42013 + 32 len floor32(mem[_42013])]
                                        mem[_42012 + floor32(mem[_42013]) + -(mem[_42013] % 32) + 164 len mem[_42013] % 32] = mem[_42013 + -(mem[_42013] % 32) + floor32(mem[_42013]) + 64 len mem[_42013] % 32]
                                        call stakingTokenAddress.mem[_42012 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_42012 + 136 len _44654 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_42012 + 242 len 22]
                                        else:
                                            mem[_42012 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_42012 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_42012 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _42460 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _42461 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_42461 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _45472 = mem[_42461]
                                        mem[_42460 + 132 len floor32(mem[_42461])] = mem[_42461 + 32 len floor32(mem[_42461])]
                                        mem[_42460 + floor32(mem[_42461]) + -(mem[_42461] % 32) + 164 len mem[_42461] % 32] = mem[_42461 + -(mem[_42461] % 32) + floor32(mem[_42461]) + 64 len mem[_42461] % 32]
                                        call stakingTokenAddress.mem[_42460 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_42460 + 136 len _45472 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_42460 + 242 len 22]
                                        else:
                                            mem[_42460 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_42460 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_42460 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored - t:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39709 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39709] = 26
                                    mem[_39709 + 32] = 'SafeMath: division by zero'
                                    if s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_183ddbfb[address(msg.sender)].field_512 = s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                    sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                    sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                    if sub_183ddbfb[address(msg.sender)].field_0:
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _42858 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _42859 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_42859 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _46212 = mem[_42859]
                                        mem[_42858 + 132 len floor32(mem[_42859])] = mem[_42859 + 32 len floor32(mem[_42859])]
                                        mem[_42858 + floor32(mem[_42859]) + -(mem[_42859] % 32) + 164 len mem[_42859] % 32] = mem[_42859 + -(mem[_42859] % 32) + floor32(mem[_42859]) + 64 len mem[_42859] % 32]
                                        call stakingTokenAddress.mem[_42858 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_42858 + 136 len _46212 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_42858 + 242 len 22]
                                        else:
                                            mem[_42858 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_42858 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_42858 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _43398 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _43399 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_43399 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _47049 = mem[_43399]
                                        mem[_43398 + 132 len floor32(mem[_43399])] = mem[_43399 + 32 len floor32(mem[_43399])]
                                        mem[_43398 + floor32(mem[_43399]) + -(mem[_43399] % 32) + 164 len mem[_43399] % 32] = mem[_43399 + -(mem[_43399] % 32) + floor32(mem[_43399]) + 64 len mem[_43399] % 32]
                                        call stakingTokenAddress.mem[_43398 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_43398 + 136 len _47049 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_43398 + 242 len 22]
                                        else:
                                            mem[_43398 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_43398 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_43398 + ceil32(return_data.size) + 243 len 22]
        else:
            lastUpdateTime = periodFinish
            if not msg.sender:
                if arg1 <= 0:
                    revert with 0, 'staking 0'
                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                    revert with 0, 'SafeERC20: call to non-contract'
                if not ext_code.hash(stakingTokenAddress):
                    revert with 0, 'SafeERC20: call to non-contract'
                mem[228 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg1) >> 32
                mem[352 len 4] = uint32(arg1)
                call stakingTokenAddress with:
                     gas gas_remaining wei
                    args Mask(224, 32, arg1) << 480, mem[324 len 4]
                if not return_data.size:
                    if not ext_call.success:
                        revert with 0, 'SafeERC20: low-level call failed'
                    if not unknown_0x23b872dd(?????), Mask(224, 32, msg.sender) >> 32:
                        revert with 0, 
                                    32,
                                    42,
                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[338 len 14],
                                    uint32(arg1),
                                    mem[356 len 4]
                else:
                    mem[260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        if not mem[260]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[ceil32(return_data.size) + 339 len 22]
            else:
                mem[96] = 0
                mem[128] = 0
                mem[160] = 0
                mem[192] = 0
                mem[0] = msg.sender
                mem[32] = 16
                mem[64] = 352
                mem[224] = sub_183ddbfb[address(msg.sender)].field_0
                mem[256] = sub_183ddbfb[address(msg.sender)].field_256
                mem[288] = sub_183ddbfb[address(msg.sender)].field_512
                mem[320] = sub_183ddbfb[address(msg.sender)].field_768
                idx = sub_183ddbfb[address(msg.sender)].field_768
                s = sub_183ddbfb[address(msg.sender)].field_512
                t = sub_183ddbfb[address(msg.sender)].field_256
                while idx < sub_e7690c44:
                    require idx < sub_155b0a71.length
                    mem[0] = 15
                    if not t:
                        _32494 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32494] = 26
                        mem[_32494 + 32] = 'SafeMath: division by zero'
                        require idx < sub_155b0a71.length
                        mem[0] = 15
                        if not s:
                            _33726 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33726] = 26
                            mem[_33726 + 32] = 'SafeMath: division by zero'
                            idx = idx + 1
                            s = 0
                            t = 0
                            continue 
                        if sub_155b0a71[idx] * s / s != sub_155b0a71[idx]:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _33810 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33810] = 26
                        mem[_33810 + 32] = 'SafeMath: division by zero'
                        idx = idx + 1
                        s = sub_155b0a71[idx] * s / 10^18
                        t = 0
                        continue 
                    if sub_155b0a71[idx] * t / t != sub_155b0a71[idx]:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _32620 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32620] = 26
                    mem[_32620 + 32] = 'SafeMath: division by zero'
                    require idx < sub_155b0a71.length
                    mem[0] = 15
                    if not s:
                        _33809 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33809] = 26
                        mem[_33809 + 32] = 'SafeMath: division by zero'
                        idx = idx + 1
                        s = 0
                        t = sub_155b0a71[idx] * t / 10^18
                        continue 
                    if sub_155b0a71[idx] * s / s != sub_155b0a71[idx]:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _33824 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_33824] = 26
                    mem[_33824 + 32] = 'SafeMath: division by zero'
                    idx = idx + 1
                    s = sub_155b0a71[idx] * s / 10^18
                    t = sub_155b0a71[idx] * t / 10^18
                    continue 
                if 0 == totalStakes:
                    _32422 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32422] = 30
                    mem[_32422 + 32] = 'SafeMath: subtraction overflow'
                    if t > rewardPerTokenStored:
                        revert with 0, 'SafeMath: subtraction overflow'
                    mem[0] = msg.sender
                    mem[32] = 17
                    if not accountStakes[address(msg.sender)]:
                        _33417 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33417] = 26
                        mem[_33417 + 32] = 'SafeMath: division by zero'
                        if s < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        sub_183ddbfb[address(msg.sender)].field_512 = s
                        sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                        sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                        if sub_183ddbfb[address(msg.sender)].field_0:
                            if arg1 <= 0:
                                revert with 0, 'staking 0'
                            _34464 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = this.address
                            mem[mem[64] + 100] = arg1
                            _34465 = mem[64]
                            mem[mem[64]] = 100
                            mem[64] = mem[64] + 132
                            mem[_34465 + 32 len 4] = unknown_0x23b872dd(?????)
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                revert with 0, 'SafeERC20: call to non-contract'
                            if not ext_code.hash(stakingTokenAddress):
                                revert with 0, 'SafeERC20: call to non-contract'
                            _35110 = mem[_34465]
                            mem[_34464 + 132 len floor32(mem[_34465])] = mem[_34465 + 32 len floor32(mem[_34465])]
                            mem[_34464 + floor32(mem[_34465]) + -(mem[_34465] % 32) + 164 len mem[_34465] % 32] = mem[_34465 + -(mem[_34465] % 32) + floor32(mem[_34465]) + 64 len mem[_34465] % 32]
                            call stakingTokenAddress.mem[_34464 + 132 len 4] with:
                                 gas gas_remaining wei
                                args mem[_34464 + 136 len _35110 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if mem[96]:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_34464 + 242 len 22]
                            else:
                                mem[_34464 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[_34464 + 164]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_34464 + ceil32(return_data.size) + 243 len 22]
                        else:
                            sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                            if arg1 <= 0:
                                revert with 0, 'staking 0'
                            _34662 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = this.address
                            mem[mem[64] + 100] = arg1
                            _34663 = mem[64]
                            mem[mem[64]] = 100
                            mem[64] = mem[64] + 132
                            mem[_34663 + 32 len 4] = unknown_0x23b872dd(?????)
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                revert with 0, 'SafeERC20: call to non-contract'
                            if not ext_code.hash(stakingTokenAddress):
                                revert with 0, 'SafeERC20: call to non-contract'
                            _35208 = mem[_34663]
                            mem[_34662 + 132 len floor32(mem[_34663])] = mem[_34663 + 32 len floor32(mem[_34663])]
                            mem[_34662 + floor32(mem[_34663]) + -(mem[_34663] % 32) + 164 len mem[_34663] % 32] = mem[_34663 + -(mem[_34663] % 32) + floor32(mem[_34663]) + 64 len mem[_34663] % 32]
                            call stakingTokenAddress.mem[_34662 + 132 len 4] with:
                                 gas gas_remaining wei
                                args mem[_34662 + 136 len _35208 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if mem[96]:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_34662 + 242 len 22]
                            else:
                                mem[_34662 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[_34662 + 164]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_34662 + ceil32(return_data.size) + 243 len 22]
                    else:
                        if (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != rewardPerTokenStored - t:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _33668 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33668] = 26
                        mem[_33668 + 32] = 'SafeMath: division by zero'
                        if s + ((rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        sub_183ddbfb[address(msg.sender)].field_512 = s + ((rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                        sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                        sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                        if sub_183ddbfb[address(msg.sender)].field_0:
                            if arg1 <= 0:
                                revert with 0, 'staking 0'
                            _34786 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = this.address
                            mem[mem[64] + 100] = arg1
                            _34787 = mem[64]
                            mem[mem[64]] = 100
                            mem[64] = mem[64] + 132
                            mem[_34787 + 32 len 4] = unknown_0x23b872dd(?????)
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                revert with 0, 'SafeERC20: call to non-contract'
                            if not ext_code.hash(stakingTokenAddress):
                                revert with 0, 'SafeERC20: call to non-contract'
                            _35372 = mem[_34787]
                            mem[_34786 + 132 len floor32(mem[_34787])] = mem[_34787 + 32 len floor32(mem[_34787])]
                            mem[_34786 + floor32(mem[_34787]) + -(mem[_34787] % 32) + 164 len mem[_34787] % 32] = mem[_34787 + -(mem[_34787] % 32) + floor32(mem[_34787]) + 64 len mem[_34787] % 32]
                            call stakingTokenAddress.mem[_34786 + 132 len 4] with:
                                 gas gas_remaining wei
                                args mem[_34786 + 136 len _35372 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if mem[96]:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_34786 + 242 len 22]
                            else:
                                mem[_34786 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[_34786 + 164]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_34786 + ceil32(return_data.size) + 243 len 22]
                        else:
                            sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                            if arg1 <= 0:
                                revert with 0, 'staking 0'
                            _34928 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = this.address
                            mem[mem[64] + 100] = arg1
                            _34929 = mem[64]
                            mem[mem[64]] = 100
                            mem[64] = mem[64] + 132
                            mem[_34929 + 32 len 4] = unknown_0x23b872dd(?????)
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                revert with 0, 'SafeERC20: call to non-contract'
                            if not ext_code.hash(stakingTokenAddress):
                                revert with 0, 'SafeERC20: call to non-contract'
                            _35595 = mem[_34929]
                            mem[_34928 + 132 len floor32(mem[_34929])] = mem[_34929 + 32 len floor32(mem[_34929])]
                            mem[_34928 + floor32(mem[_34929]) + -(mem[_34929] % 32) + 164 len mem[_34929] % 32] = mem[_34929 + -(mem[_34929] % 32) + floor32(mem[_34929]) + 64 len mem[_34929] % 32]
                            call stakingTokenAddress.mem[_34928 + 132 len 4] with:
                                 gas gas_remaining wei
                                args mem[_34928 + 136 len _35595 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if mem[96]:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_34928 + 242 len 22]
                            else:
                                mem[_34928 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[_34928 + 164]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_34928 + ceil32(return_data.size) + 243 len 22]
                else:
                    if block.timestamp < periodFinish:
                        _32660 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32660] = 30
                        mem[_32660 + 32] = 'SafeMath: subtraction overflow'
                        if lastUpdateTime > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.timestamp - lastUpdateTime:
                            _33864 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33864] = 26
                            mem[_33864 + 32] = 'SafeMath: division by zero'
                            if not totalStakes:
                                revert with 0, 'SafeMath: division by zero'
                            if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                revert with 0, 'SafeMath: addition overflow'
                            _35204 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35204] = 30
                            mem[_35204 + 32] = 'SafeMath: subtraction overflow'
                            if t > (0 / totalStakes) + rewardPerTokenStored:
                                revert with 0, 'SafeMath: subtraction overflow'
                            mem[0] = msg.sender
                            mem[32] = 17
                            if not accountStakes[address(msg.sender)]:
                                _37578 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_37578] = 26
                                mem[_37578 + 32] = 'SafeMath: division by zero'
                                if s < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                if sub_183ddbfb[address(msg.sender)].field_0:
                                    if arg1 <= 0:
                                        revert with 0, 'staking 0'
                                    _40526 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = this.address
                                    mem[mem[64] + 100] = arg1
                                    _40527 = mem[64]
                                    mem[mem[64]] = 100
                                    mem[64] = mem[64] + 132
                                    mem[_40527 + 32 len 4] = unknown_0x23b872dd(?????)
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    _41736 = mem[_40527]
                                    mem[_40526 + 132 len floor32(mem[_40527])] = mem[_40527 + 32 len floor32(mem[_40527])]
                                    mem[_40526 + floor32(mem[_40527]) + -(mem[_40527] % 32) + 164 len mem[_40527] % 32] = mem[_40527 + -(mem[_40527] % 32) + floor32(mem[_40527]) + 64 len mem[_40527] % 32]
                                    call stakingTokenAddress.mem[_40526 + 132 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_40526 + 136 len _41736 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_40526 + 242 len 22]
                                    else:
                                        mem[_40526 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[_40526 + 164]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_40526 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                    if arg1 <= 0:
                                        revert with 0, 'staking 0'
                                    _40678 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = this.address
                                    mem[mem[64] + 100] = arg1
                                    _40679 = mem[64]
                                    mem[mem[64]] = 100
                                    mem[64] = mem[64] + 132
                                    mem[_40679 + 32 len 4] = unknown_0x23b872dd(?????)
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    _42030 = mem[_40679]
                                    mem[_40678 + 132 len floor32(mem[_40679])] = mem[_40679 + 32 len floor32(mem[_40679])]
                                    mem[_40678 + floor32(mem[_40679]) + -(mem[_40679] % 32) + 164 len mem[_40679] % 32] = mem[_40679 + -(mem[_40679] % 32) + floor32(mem[_40679]) + 64 len mem[_40679] % 32]
                                    call stakingTokenAddress.mem[_40678 + 132 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_40678 + 136 len _42030 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_40678 + 242 len 22]
                                    else:
                                        mem[_40678 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[_40678 + 164]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_40678 + ceil32(return_data.size) + 243 len 22]
                            else:
                                if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _38053 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38053] = 26
                                mem[_38053 + 32] = 'SafeMath: division by zero'
                                if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                if sub_183ddbfb[address(msg.sender)].field_0:
                                    if arg1 <= 0:
                                        revert with 0, 'staking 0'
                                    _40885 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = this.address
                                    mem[mem[64] + 100] = arg1
                                    _40886 = mem[64]
                                    mem[mem[64]] = 100
                                    mem[64] = mem[64] + 132
                                    mem[_40886 + 32 len 4] = unknown_0x23b872dd(?????)
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    _42484 = mem[_40886]
                                    mem[_40885 + 132 len floor32(mem[_40886])] = mem[_40886 + 32 len floor32(mem[_40886])]
                                    mem[_40885 + floor32(mem[_40886]) + -(mem[_40886] % 32) + 164 len mem[_40886] % 32] = mem[_40886 + -(mem[_40886] % 32) + floor32(mem[_40886]) + 64 len mem[_40886] % 32]
                                    call stakingTokenAddress.mem[_40885 + 132 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_40885 + 136 len _42484 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_40885 + 242 len 22]
                                    else:
                                        mem[_40885 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[_40885 + 164]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_40885 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                    if arg1 <= 0:
                                        revert with 0, 'staking 0'
                                    _41123 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = this.address
                                    mem[mem[64] + 100] = arg1
                                    _41124 = mem[64]
                                    mem[mem[64]] = 100
                                    mem[64] = mem[64] + 132
                                    mem[_41124 + 32 len 4] = unknown_0x23b872dd(?????)
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    _42878 = mem[_41124]
                                    mem[_41123 + 132 len floor32(mem[_41124])] = mem[_41124 + 32 len floor32(mem[_41124])]
                                    mem[_41123 + floor32(mem[_41124]) + -(mem[_41124] % 32) + 164 len mem[_41124] % 32] = mem[_41124 + -(mem[_41124] % 32) + floor32(mem[_41124]) + 64 len mem[_41124] % 32]
                                    call stakingTokenAddress.mem[_41123 + 132 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_41123 + 136 len _42878 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_41123 + 242 len 22]
                                    else:
                                        mem[_41123 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[_41123 + 164]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_41123 + ceil32(return_data.size) + 243 len 22]
                        else:
                            if (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) / block.timestamp - lastUpdateTime != rewardRate:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate):
                                _33986 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33986] = 26
                                mem[_33986 + 32] = 'SafeMath: division by zero'
                                if not totalStakes:
                                    revert with 0, 'SafeMath: division by zero'
                                if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                    revert with 0, 'SafeMath: addition overflow'
                                _35587 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35587] = 30
                                mem[_35587 + 32] = 'SafeMath: subtraction overflow'
                                if t > (0 / totalStakes) + rewardPerTokenStored:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 17
                                if not accountStakes[address(msg.sender)]:
                                    _38052 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38052] = 26
                                    mem[_38052 + 32] = 'SafeMath: division by zero'
                                    if s < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_183ddbfb[address(msg.sender)].field_512 = s
                                    sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                    sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                    if sub_183ddbfb[address(msg.sender)].field_0:
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _40880 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _40881 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_40881 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _42478 = mem[_40881]
                                        mem[_40880 + 132 len floor32(mem[_40881])] = mem[_40881 + 32 len floor32(mem[_40881])]
                                        mem[_40880 + floor32(mem[_40881]) + -(mem[_40881] % 32) + 164 len mem[_40881] % 32] = mem[_40881 + -(mem[_40881] % 32) + floor32(mem[_40881]) + 64 len mem[_40881] % 32]
                                        call stakingTokenAddress.mem[_40880 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_40880 + 136 len _42478 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_40880 + 242 len 22]
                                        else:
                                            mem[_40880 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_40880 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_40880 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _41120 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _41121 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_41121 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _42872 = mem[_41121]
                                        mem[_41120 + 132 len floor32(mem[_41121])] = mem[_41121 + 32 len floor32(mem[_41121])]
                                        mem[_41120 + floor32(mem[_41121]) + -(mem[_41121] % 32) + 164 len mem[_41121] % 32] = mem[_41121 + -(mem[_41121] % 32) + floor32(mem[_41121]) + 64 len mem[_41121] % 32]
                                        call stakingTokenAddress.mem[_41120 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_41120 + 136 len _42872 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_41120 + 242 len 22]
                                        else:
                                            mem[_41120 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_41120 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_41120 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _38514 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38514] = 26
                                    mem[_38514 + 32] = 'SafeMath: division by zero'
                                    if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                    sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                    sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                    if sub_183ddbfb[address(msg.sender)].field_0:
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _41398 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _41399 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_41399 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _43426 = mem[_41399]
                                        mem[_41398 + 132 len floor32(mem[_41399])] = mem[_41399 + 32 len floor32(mem[_41399])]
                                        mem[_41398 + floor32(mem[_41399]) + -(mem[_41399] % 32) + 164 len mem[_41399] % 32] = mem[_41399 + -(mem[_41399] % 32) + floor32(mem[_41399]) + 64 len mem[_41399] % 32]
                                        call stakingTokenAddress.mem[_41398 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_41398 + 136 len _43426 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_41398 + 242 len 22]
                                        else:
                                            mem[_41398 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_41398 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_41398 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _41730 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _41731 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_41731 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _44051 = mem[_41731]
                                        mem[_41730 + 132 len floor32(mem[_41731])] = mem[_41731 + 32 len floor32(mem[_41731])]
                                        mem[_41730 + floor32(mem[_41731]) + -(mem[_41731] % 32) + 164 len mem[_41731] % 32] = mem[_41731 + -(mem[_41731] % 32) + floor32(mem[_41731]) + 64 len mem[_41731] % 32]
                                        call stakingTokenAddress.mem[_41730 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_41730 + 136 len _44051 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_41730 + 242 len 22]
                                        else:
                                            mem[_41730 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_41730 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_41730 + ceil32(return_data.size) + 243 len 22]
                            else:
                                if (10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _34138 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34138] = 26
                                mem[_34138 + 32] = 'SafeMath: division by zero'
                                if not totalStakes:
                                    revert with 0, 'SafeMath: division by zero'
                                if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                    revert with 0, 'SafeMath: addition overflow'
                                _35960 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35960] = 30
                                mem[_35960 + 32] = 'SafeMath: subtraction overflow'
                                if t > ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 17
                                if not accountStakes[address(msg.sender)]:
                                    _38513 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38513] = 26
                                    mem[_38513 + 32] = 'SafeMath: division by zero'
                                    if s < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_183ddbfb[address(msg.sender)].field_512 = s
                                    sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                    sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                    if sub_183ddbfb[address(msg.sender)].field_0:
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _41393 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _41394 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_41394 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _43420 = mem[_41394]
                                        mem[_41393 + 132 len floor32(mem[_41394])] = mem[_41394 + 32 len floor32(mem[_41394])]
                                        mem[_41393 + floor32(mem[_41394]) + -(mem[_41394] % 32) + 164 len mem[_41394] % 32] = mem[_41394 + -(mem[_41394] % 32) + floor32(mem[_41394]) + 64 len mem[_41394] % 32]
                                        call stakingTokenAddress.mem[_41393 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_41393 + 136 len _43420 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_41393 + 242 len 22]
                                        else:
                                            mem[_41393 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_41393 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_41393 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _41727 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _41728 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_41728 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _44045 = mem[_41728]
                                        mem[_41727 + 132 len floor32(mem[_41728])] = mem[_41728 + 32 len floor32(mem[_41728])]
                                        mem[_41727 + floor32(mem[_41728]) + -(mem[_41728] % 32) + 164 len mem[_41728] % 32] = mem[_41728 + -(mem[_41728] % 32) + floor32(mem[_41728]) + 64 len mem[_41728] % 32]
                                        call stakingTokenAddress.mem[_41727 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_41727 + 136 len _44045 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_41727 + 242 len 22]
                                        else:
                                            mem[_41727 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_41727 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_41727 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored - t:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39080 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39080] = 26
                                    mem[_39080 + 32] = 'SafeMath: division by zero'
                                    if s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_183ddbfb[address(msg.sender)].field_512 = s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                    sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                    sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                    if sub_183ddbfb[address(msg.sender)].field_0:
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _42022 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _42023 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_42023 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _44675 = mem[_42023]
                                        mem[_42022 + 132 len floor32(mem[_42023])] = mem[_42023 + 32 len floor32(mem[_42023])]
                                        mem[_42022 + floor32(mem[_42023]) + -(mem[_42023] % 32) + 164 len mem[_42023] % 32] = mem[_42023 + -(mem[_42023] % 32) + floor32(mem[_42023]) + 64 len mem[_42023] % 32]
                                        call stakingTokenAddress.mem[_42022 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_42022 + 136 len _44675 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_42022 + 242 len 22]
                                        else:
                                            mem[_42022 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_42022 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_42022 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _42472 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _42473 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_42473 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _45500 = mem[_42473]
                                        mem[_42472 + 132 len floor32(mem[_42473])] = mem[_42473 + 32 len floor32(mem[_42473])]
                                        mem[_42472 + floor32(mem[_42473]) + -(mem[_42473] % 32) + 164 len mem[_42473] % 32] = mem[_42473 + -(mem[_42473] % 32) + floor32(mem[_42473]) + 64 len mem[_42473] % 32]
                                        call stakingTokenAddress.mem[_42472 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_42472 + 136 len _45500 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_42472 + 242 len 22]
                                        else:
                                            mem[_42472 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_42472 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_42472 + ceil32(return_data.size) + 243 len 22]
                    else:
                        _32870 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32870] = 30
                        mem[_32870 + 32] = 'SafeMath: subtraction overflow'
                        if lastUpdateTime > periodFinish:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not periodFinish - lastUpdateTime:
                            _33990 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33990] = 26
                            mem[_33990 + 32] = 'SafeMath: division by zero'
                            if not totalStakes:
                                revert with 0, 'SafeMath: division by zero'
                            if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                revert with 0, 'SafeMath: addition overflow'
                            _35591 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35591] = 30
                            mem[_35591 + 32] = 'SafeMath: subtraction overflow'
                            if t > (0 / totalStakes) + rewardPerTokenStored:
                                revert with 0, 'SafeMath: subtraction overflow'
                            mem[0] = msg.sender
                            mem[32] = 17
                            if not accountStakes[address(msg.sender)]:
                                _38056 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38056] = 26
                                mem[_38056 + 32] = 'SafeMath: division by zero'
                                if s < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                if sub_183ddbfb[address(msg.sender)].field_0:
                                    if arg1 <= 0:
                                        revert with 0, 'staking 0'
                                    _40890 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = this.address
                                    mem[mem[64] + 100] = arg1
                                    _40891 = mem[64]
                                    mem[mem[64]] = 100
                                    mem[64] = mem[64] + 132
                                    mem[_40891 + 32 len 4] = unknown_0x23b872dd(?????)
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    _42502 = mem[_40891]
                                    mem[_40890 + 132 len floor32(mem[_40891])] = mem[_40891 + 32 len floor32(mem[_40891])]
                                    mem[_40890 + floor32(mem[_40891]) + -(mem[_40891] % 32) + 164 len mem[_40891] % 32] = mem[_40891 + -(mem[_40891] % 32) + floor32(mem[_40891]) + 64 len mem[_40891] % 32]
                                    call stakingTokenAddress.mem[_40890 + 132 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_40890 + 136 len _42502 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_40890 + 242 len 22]
                                    else:
                                        mem[_40890 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[_40890 + 164]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_40890 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                    if arg1 <= 0:
                                        revert with 0, 'staking 0'
                                    _41130 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = this.address
                                    mem[mem[64] + 100] = arg1
                                    _41131 = mem[64]
                                    mem[mem[64]] = 100
                                    mem[64] = mem[64] + 132
                                    mem[_41131 + 32 len 4] = unknown_0x23b872dd(?????)
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    _42894 = mem[_41131]
                                    mem[_41130 + 132 len floor32(mem[_41131])] = mem[_41131 + 32 len floor32(mem[_41131])]
                                    mem[_41130 + floor32(mem[_41131]) + -(mem[_41131] % 32) + 164 len mem[_41131] % 32] = mem[_41131 + -(mem[_41131] % 32) + floor32(mem[_41131]) + 64 len mem[_41131] % 32]
                                    call stakingTokenAddress.mem[_41130 + 132 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_41130 + 136 len _42894 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_41130 + 242 len 22]
                                    else:
                                        mem[_41130 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[_41130 + 164]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_41130 + ceil32(return_data.size) + 243 len 22]
                            else:
                                if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _38516 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38516] = 26
                                mem[_38516 + 32] = 'SafeMath: division by zero'
                                if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                if sub_183ddbfb[address(msg.sender)].field_0:
                                    if arg1 <= 0:
                                        revert with 0, 'staking 0'
                                    _41408 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = this.address
                                    mem[mem[64] + 100] = arg1
                                    _41409 = mem[64]
                                    mem[mem[64]] = 100
                                    mem[64] = mem[64] + 132
                                    mem[_41409 + 32 len 4] = unknown_0x23b872dd(?????)
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    _43450 = mem[_41409]
                                    mem[_41408 + 132 len floor32(mem[_41409])] = mem[_41409 + 32 len floor32(mem[_41409])]
                                    mem[_41408 + floor32(mem[_41409]) + -(mem[_41409] % 32) + 164 len mem[_41409] % 32] = mem[_41409 + -(mem[_41409] % 32) + floor32(mem[_41409]) + 64 len mem[_41409] % 32]
                                    call stakingTokenAddress.mem[_41408 + 132 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_41408 + 136 len _43450 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_41408 + 242 len 22]
                                    else:
                                        mem[_41408 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[_41408 + 164]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_41408 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                    if arg1 <= 0:
                                        revert with 0, 'staking 0'
                                    _41746 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = this.address
                                    mem[mem[64] + 100] = arg1
                                    _41747 = mem[64]
                                    mem[mem[64]] = 100
                                    mem[64] = mem[64] + 132
                                    mem[_41747 + 32 len 4] = unknown_0x23b872dd(?????)
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    _44079 = mem[_41747]
                                    mem[_41746 + 132 len floor32(mem[_41747])] = mem[_41747 + 32 len floor32(mem[_41747])]
                                    mem[_41746 + floor32(mem[_41747]) + -(mem[_41747] % 32) + 164 len mem[_41747] % 32] = mem[_41747 + -(mem[_41747] % 32) + floor32(mem[_41747]) + 64 len mem[_41747] % 32]
                                    call stakingTokenAddress.mem[_41746 + 132 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_41746 + 136 len _44079 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_41746 + 242 len 22]
                                    else:
                                        mem[_41746 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[_41746 + 164]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_41746 + ceil32(return_data.size) + 243 len 22]
                        else:
                            if (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) / periodFinish - lastUpdateTime != rewardRate:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not (periodFinish * rewardRate) - (lastUpdateTime * rewardRate):
                                _34143 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34143] = 26
                                mem[_34143 + 32] = 'SafeMath: division by zero'
                                if not totalStakes:
                                    revert with 0, 'SafeMath: division by zero'
                                if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                    revert with 0, 'SafeMath: addition overflow'
                                _35966 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35966] = 30
                                mem[_35966 + 32] = 'SafeMath: subtraction overflow'
                                if t > (0 / totalStakes) + rewardPerTokenStored:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 17
                                if not accountStakes[address(msg.sender)]:
                                    _38515 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38515] = 26
                                    mem[_38515 + 32] = 'SafeMath: division by zero'
                                    if s < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_183ddbfb[address(msg.sender)].field_512 = s
                                    sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                    sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                    if sub_183ddbfb[address(msg.sender)].field_0:
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _41403 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _41404 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_41404 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _43444 = mem[_41404]
                                        mem[_41403 + 132 len floor32(mem[_41404])] = mem[_41404 + 32 len floor32(mem[_41404])]
                                        mem[_41403 + floor32(mem[_41404]) + -(mem[_41404] % 32) + 164 len mem[_41404] % 32] = mem[_41404 + -(mem[_41404] % 32) + floor32(mem[_41404]) + 64 len mem[_41404] % 32]
                                        call stakingTokenAddress.mem[_41403 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_41403 + 136 len _43444 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_41403 + 242 len 22]
                                        else:
                                            mem[_41403 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_41403 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_41403 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _41743 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _41744 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_41744 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _44073 = mem[_41744]
                                        mem[_41743 + 132 len floor32(mem[_41744])] = mem[_41744 + 32 len floor32(mem[_41744])]
                                        mem[_41743 + floor32(mem[_41744]) + -(mem[_41744] % 32) + 164 len mem[_41744] % 32] = mem[_41744 + -(mem[_41744] % 32) + floor32(mem[_41744]) + 64 len mem[_41744] % 32]
                                        call stakingTokenAddress.mem[_41743 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_41743 + 136 len _44073 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_41743 + 242 len 22]
                                        else:
                                            mem[_41743 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_41743 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_41743 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39082 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39082] = 26
                                    mem[_39082 + 32] = 'SafeMath: division by zero'
                                    if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                    sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                    sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                    if sub_183ddbfb[address(msg.sender)].field_0:
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _42038 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _42039 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_42039 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _44705 = mem[_42039]
                                        mem[_42038 + 132 len floor32(mem[_42039])] = mem[_42039 + 32 len floor32(mem[_42039])]
                                        mem[_42038 + floor32(mem[_42039]) + -(mem[_42039] % 32) + 164 len mem[_42039] % 32] = mem[_42039 + -(mem[_42039] % 32) + floor32(mem[_42039]) + 64 len mem[_42039] % 32]
                                        call stakingTokenAddress.mem[_42038 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_42038 + 136 len _44705 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_42038 + 242 len 22]
                                        else:
                                            mem[_42038 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_42038 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_42038 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _42496 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _42497 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_42497 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _45538 = mem[_42497]
                                        mem[_42496 + 132 len floor32(mem[_42497])] = mem[_42497 + 32 len floor32(mem[_42497])]
                                        mem[_42496 + floor32(mem[_42497]) + -(mem[_42497] % 32) + 164 len mem[_42497] % 32] = mem[_42497 + -(mem[_42497] % 32) + floor32(mem[_42497]) + 64 len mem[_42497] % 32]
                                        call stakingTokenAddress.mem[_42496 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_42496 + 136 len _45538 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_42496 + 242 len 22]
                                        else:
                                            mem[_42496 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_42496 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_42496 + ceil32(return_data.size) + 243 len 22]
                            else:
                                if (10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _34336 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34336] = 26
                                mem[_34336 + 32] = 'SafeMath: division by zero'
                                if not totalStakes:
                                    revert with 0, 'SafeMath: division by zero'
                                if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                    revert with 0, 'SafeMath: addition overflow'
                                _36483 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_36483] = 30
                                mem[_36483 + 32] = 'SafeMath: subtraction overflow'
                                if t > ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 17
                                if not accountStakes[address(msg.sender)]:
                                    _39081 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39081] = 26
                                    mem[_39081 + 32] = 'SafeMath: division by zero'
                                    if s < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_183ddbfb[address(msg.sender)].field_512 = s
                                    sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                    sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                    if sub_183ddbfb[address(msg.sender)].field_0:
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _42033 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _42034 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_42034 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _44699 = mem[_42034]
                                        mem[_42033 + 132 len floor32(mem[_42034])] = mem[_42034 + 32 len floor32(mem[_42034])]
                                        mem[_42033 + floor32(mem[_42034]) + -(mem[_42034] % 32) + 164 len mem[_42034] % 32] = mem[_42034 + -(mem[_42034] % 32) + floor32(mem[_42034]) + 64 len mem[_42034] % 32]
                                        call stakingTokenAddress.mem[_42033 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_42033 + 136 len _44699 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_42033 + 242 len 22]
                                        else:
                                            mem[_42033 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_42033 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_42033 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _42493 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _42494 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_42494 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _45532 = mem[_42494]
                                        mem[_42493 + 132 len floor32(mem[_42494])] = mem[_42494 + 32 len floor32(mem[_42494])]
                                        mem[_42493 + floor32(mem[_42494]) + -(mem[_42494] % 32) + 164 len mem[_42494] % 32] = mem[_42494 + -(mem[_42494] % 32) + floor32(mem[_42494]) + 64 len mem[_42494] % 32]
                                        call stakingTokenAddress.mem[_42493 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_42493 + 136 len _45532 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_42493 + 242 len 22]
                                        else:
                                            mem[_42493 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_42493 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_42493 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored - t:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _39736 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39736] = 26
                                    mem[_39736 + 32] = 'SafeMath: division by zero'
                                    if s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_183ddbfb[address(msg.sender)].field_512 = s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                    sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                    sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                    if sub_183ddbfb[address(msg.sender)].field_0:
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _42886 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _42887 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_42887 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _46264 = mem[_42887]
                                        mem[_42886 + 132 len floor32(mem[_42887])] = mem[_42887 + 32 len floor32(mem[_42887])]
                                        mem[_42886 + floor32(mem[_42887]) + -(mem[_42887] % 32) + 164 len mem[_42887] % 32] = mem[_42887 + -(mem[_42887] % 32) + floor32(mem[_42887]) + 64 len mem[_42887] % 32]
                                        call stakingTokenAddress.mem[_42886 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_42886 + 136 len _46264 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_42886 + 242 len 22]
                                        else:
                                            mem[_42886 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_42886 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_42886 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _43438 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _43439 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_43439 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _47110 = mem[_43439]
                                        mem[_43438 + 132 len floor32(mem[_43439])] = mem[_43439 + 32 len floor32(mem[_43439])]
                                        mem[_43438 + floor32(mem[_43439]) + -(mem[_43439] % 32) + 164 len mem[_43439] % 32] = mem[_43439 + -(mem[_43439] % 32) + floor32(mem[_43439]) + 64 len mem[_43439] % 32]
                                        call stakingTokenAddress.mem[_43438 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_43438 + 136 len _47110 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_43438 + 242 len 22]
                                        else:
                                            mem[_43438 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_43438 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_43438 + ceil32(return_data.size) + 243 len 22]
    else:
        mem[96] = 30
        mem[128] = 'SafeMath: subtraction overflow'
        if block.timestamp < periodFinish:
            if lastUpdateTime > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.timestamp - lastUpdateTime:
                mem[160] = 26
                mem[192] = 'SafeMath: division by zero'
                if not totalStakes:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                    revert with 0, 'SafeMath: addition overflow'
                rewardPerTokenStored += 0 / totalStakes
                if block.timestamp < periodFinish:
                    lastUpdateTime = block.timestamp
                    if not msg.sender:
                        if arg1 <= 0:
                            revert with 0, 'staking 0'
                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                            revert with 0, 'SafeERC20: call to non-contract'
                        if not ext_code.hash(stakingTokenAddress):
                            revert with 0, 'SafeERC20: call to non-contract'
                        mem[356 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg1) >> 32
                        mem[480 len 4] = uint32(arg1)
                        call stakingTokenAddress with:
                             gas gas_remaining wei
                            args Mask(224, 32, arg1) << 480, mem[452 len 4]
                        if not return_data.size:
                            require not ext_call.success
                            revert with 0, 'SafeERC20: low-level call failed'
                        mem[388 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            if not mem[388]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[ceil32(return_data.size) + 467 len 22]
                    else:
                        mem[224] = 0
                        mem[256] = 0
                        mem[288] = 0
                        mem[320] = 0
                        mem[0] = msg.sender
                        mem[32] = 16
                        mem[64] = 480
                        mem[352] = sub_183ddbfb[address(msg.sender)].field_0
                        mem[384] = sub_183ddbfb[address(msg.sender)].field_256
                        mem[416] = sub_183ddbfb[address(msg.sender)].field_512
                        mem[448] = sub_183ddbfb[address(msg.sender)].field_768
                        idx = sub_183ddbfb[address(msg.sender)].field_768
                        s = sub_183ddbfb[address(msg.sender)].field_512
                        t = sub_183ddbfb[address(msg.sender)].field_256
                        while idx < sub_e7690c44:
                            require idx < sub_155b0a71.length
                            mem[0] = 15
                            if not t:
                                _32449 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32449] = 26
                                mem[_32449 + 32] = 'SafeMath: division by zero'
                                require idx < sub_155b0a71.length
                                mem[0] = 15
                                if not s:
                                    _33690 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33690] = 26
                                    mem[_33690 + 32] = 'SafeMath: division by zero'
                                    idx = idx + 1
                                    s = 0
                                    t = 0
                                    continue 
                                if sub_155b0a71[idx] * s / s != sub_155b0a71[idx]:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _33774 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33774] = 26
                                mem[_33774 + 32] = 'SafeMath: division by zero'
                                idx = idx + 1
                                s = sub_155b0a71[idx] * s / 10^18
                                t = 0
                                continue 
                            if sub_155b0a71[idx] * t / t != sub_155b0a71[idx]:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _32566 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32566] = 26
                            mem[_32566 + 32] = 'SafeMath: division by zero'
                            require idx < sub_155b0a71.length
                            mem[0] = 15
                            if not s:
                                _33773 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33773] = 26
                                mem[_33773 + 32] = 'SafeMath: division by zero'
                                idx = idx + 1
                                s = 0
                                t = sub_155b0a71[idx] * t / 10^18
                                continue 
                            if sub_155b0a71[idx] * s / s != sub_155b0a71[idx]:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _33815 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33815] = 26
                            mem[_33815 + 32] = 'SafeMath: division by zero'
                            idx = idx + 1
                            s = sub_155b0a71[idx] * s / 10^18
                            t = sub_155b0a71[idx] * t / 10^18
                            continue 
                        if 0 == totalStakes:
                            _32377 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32377] = 30
                            mem[_32377 + 32] = 'SafeMath: subtraction overflow'
                            if t > rewardPerTokenStored:
                                revert with 0, 'SafeMath: subtraction overflow'
                            mem[0] = msg.sender
                            mem[32] = 17
                            if not accountStakes[address(msg.sender)]:
                                _33327 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33327] = 26
                                mem[_33327 + 32] = 'SafeMath: division by zero'
                                if s < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                if sub_183ddbfb[address(msg.sender)].field_0:
                                    if arg1 <= 0:
                                        revert with 0, 'staking 0'
                                    _34383 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = this.address
                                    mem[mem[64] + 100] = arg1
                                    _34384 = mem[64]
                                    mem[mem[64]] = 100
                                    mem[64] = mem[64] + 132
                                    mem[_34384 + 32 len 4] = unknown_0x23b872dd(?????)
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    _35011 = mem[_34384]
                                    mem[_34383 + 132 len floor32(mem[_34384])] = mem[_34384 + 32 len floor32(mem[_34384])]
                                    mem[_34383 + floor32(mem[_34384]) + -(mem[_34384] % 32) + 164 len mem[_34384] % 32] = mem[_34384 + -(mem[_34384] % 32) + floor32(mem[_34384]) + 64 len mem[_34384] % 32]
                                    call stakingTokenAddress.mem[_34383 + 132 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_34383 + 136 len _35011 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_34383 + 242 len 22]
                                    else:
                                        mem[_34383 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[_34383 + 164]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_34383 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                    if arg1 <= 0:
                                        revert with 0, 'staking 0'
                                    _34536 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = this.address
                                    mem[mem[64] + 100] = arg1
                                    _34537 = mem[64]
                                    mem[mem[64]] = 100
                                    mem[64] = mem[64] + 132
                                    mem[_34537 + 32 len 4] = unknown_0x23b872dd(?????)
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    _35145 = mem[_34537]
                                    mem[_34536 + 132 len floor32(mem[_34537])] = mem[_34537 + 32 len floor32(mem[_34537])]
                                    mem[_34536 + floor32(mem[_34537]) + -(mem[_34537] % 32) + 164 len mem[_34537] % 32] = mem[_34537 + -(mem[_34537] % 32) + floor32(mem[_34537]) + 64 len mem[_34537] % 32]
                                    call stakingTokenAddress.mem[_34536 + 132 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_34536 + 136 len _35145 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_34536 + 242 len 22]
                                    else:
                                        mem[_34536 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[_34536 + 164]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_34536 + ceil32(return_data.size) + 243 len 22]
                            else:
                                if (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != rewardPerTokenStored - t:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _33587 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33587] = 26
                                mem[_33587 + 32] = 'SafeMath: division by zero'
                                if s + ((rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_183ddbfb[address(msg.sender)].field_512 = s + ((rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                if sub_183ddbfb[address(msg.sender)].field_0:
                                    if arg1 <= 0:
                                        revert with 0, 'staking 0'
                                    _34705 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = this.address
                                    mem[mem[64] + 100] = arg1
                                    _34706 = mem[64]
                                    mem[mem[64]] = 100
                                    mem[64] = mem[64] + 132
                                    mem[_34706 + 32 len 4] = unknown_0x23b872dd(?????)
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    _35264 = mem[_34706]
                                    mem[_34705 + 132 len floor32(mem[_34706])] = mem[_34706 + 32 len floor32(mem[_34706])]
                                    mem[_34705 + floor32(mem[_34706]) + -(mem[_34706] % 32) + 164 len mem[_34706] % 32] = mem[_34706 + -(mem[_34706] % 32) + floor32(mem[_34706]) + 64 len mem[_34706] % 32]
                                    call stakingTokenAddress.mem[_34705 + 132 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_34705 + 136 len _35264 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_34705 + 242 len 22]
                                    else:
                                        mem[_34705 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[_34705 + 164]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_34705 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                    if arg1 <= 0:
                                        revert with 0, 'staking 0'
                                    _34838 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = this.address
                                    mem[mem[64] + 100] = arg1
                                    _34839 = mem[64]
                                    mem[mem[64]] = 100
                                    mem[64] = mem[64] + 132
                                    mem[_34839 + 32 len 4] = unknown_0x23b872dd(?????)
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    _35451 = mem[_34839]
                                    mem[_34838 + 132 len floor32(mem[_34839])] = mem[_34839 + 32 len floor32(mem[_34839])]
                                    mem[_34838 + floor32(mem[_34839]) + -(mem[_34839] % 32) + 164 len mem[_34839] % 32] = mem[_34839 + -(mem[_34839] % 32) + floor32(mem[_34839]) + 64 len mem[_34839] % 32]
                                    call stakingTokenAddress.mem[_34838 + 132 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_34838 + 136 len _35451 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_34838 + 242 len 22]
                                    else:
                                        mem[_34838 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[_34838 + 164]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_34838 + ceil32(return_data.size) + 243 len 22]
                        else:
                            if block.timestamp < periodFinish:
                                _32633 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32633] = 30
                                mem[_32633 + 32] = 'SafeMath: subtraction overflow'
                                if lastUpdateTime > block.timestamp:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if not block.timestamp - lastUpdateTime:
                                    _33837 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33837] = 26
                                    mem[_33837 + 32] = 'SafeMath: division by zero'
                                    if not totalStakes:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _35141 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35141] = 30
                                    mem[_35141 + 32] = 'SafeMath: subtraction overflow'
                                    if t > (0 / totalStakes) + rewardPerTokenStored:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 17
                                    if not accountStakes[address(msg.sender)]:
                                        _37443 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37443] = 26
                                        mem[_37443 + 32] = 'SafeMath: division by zero'
                                        if s < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_183ddbfb[address(msg.sender)].field_512 = s
                                        sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                        sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                        if sub_183ddbfb[address(msg.sender)].field_0:
                                            if arg1 <= 0:
                                                revert with 0, 'staking 0'
                                            _40481 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = this.address
                                            mem[mem[64] + 100] = arg1
                                            _40482 = mem[64]
                                            mem[mem[64]] = 100
                                            mem[64] = mem[64] + 132
                                            mem[_40482 + 32 len 4] = unknown_0x23b872dd(?????)
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            _41520 = mem[_40482]
                                            mem[_40481 + 132 len floor32(mem[_40482])] = mem[_40482 + 32 len floor32(mem[_40482])]
                                            mem[_40481 + floor32(mem[_40482]) + -(mem[_40482] % 32) + 164 len mem[_40482] % 32] = mem[_40482 + -(mem[_40482] % 32) + floor32(mem[_40482]) + 64 len mem[_40482] % 32]
                                            call stakingTokenAddress.mem[_40481 + 132 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_40481 + 136 len _41520 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40481 + 242 len 22]
                                            else:
                                                mem[_40481 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[_40481 + 164]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40481 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                            if arg1 <= 0:
                                                revert with 0, 'staking 0'
                                            _40579 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = this.address
                                            mem[mem[64] + 100] = arg1
                                            _40580 = mem[64]
                                            mem[mem[64]] = 100
                                            mem[64] = mem[64] + 132
                                            mem[_40580 + 32 len 4] = unknown_0x23b872dd(?????)
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            _41841 = mem[_40580]
                                            mem[_40579 + 132 len floor32(mem[_40580])] = mem[_40580 + 32 len floor32(mem[_40580])]
                                            mem[_40579 + floor32(mem[_40580]) + -(mem[_40580] % 32) + 164 len mem[_40580] % 32] = mem[_40580 + -(mem[_40580] % 32) + floor32(mem[_40580]) + 64 len mem[_40580] % 32]
                                            call stakingTokenAddress.mem[_40579 + 132 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_40579 + 136 len _41841 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40579 + 242 len 22]
                                            else:
                                                mem[_40579 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[_40579 + 164]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40579 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _37918 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37918] = 26
                                        mem[_37918 + 32] = 'SafeMath: division by zero'
                                        if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                        sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                        sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                        if sub_183ddbfb[address(msg.sender)].field_0:
                                            if arg1 <= 0:
                                                revert with 0, 'staking 0'
                                            _40750 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = this.address
                                            mem[mem[64] + 100] = arg1
                                            _40751 = mem[64]
                                            mem[mem[64]] = 100
                                            mem[64] = mem[64] + 132
                                            mem[_40751 + 32 len 4] = unknown_0x23b872dd(?????)
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            _42187 = mem[_40751]
                                            mem[_40750 + 132 len floor32(mem[_40751])] = mem[_40751 + 32 len floor32(mem[_40751])]
                                            mem[_40750 + floor32(mem[_40751]) + -(mem[_40751] % 32) + 164 len mem[_40751] % 32] = mem[_40751 + -(mem[_40751] % 32) + floor32(mem[_40751]) + 64 len mem[_40751] % 32]
                                            call stakingTokenAddress.mem[_40750 + 132 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_40750 + 136 len _42187 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40750 + 242 len 22]
                                            else:
                                                mem[_40750 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[_40750 + 164]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40750 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                            if arg1 <= 0:
                                                revert with 0, 'staking 0'
                                            _40970 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = this.address
                                            mem[mem[64] + 100] = arg1
                                            _40971 = mem[64]
                                            mem[mem[64]] = 100
                                            mem[64] = mem[64] + 132
                                            mem[_40971 + 32 len 4] = unknown_0x23b872dd(?????)
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            _42626 = mem[_40971]
                                            mem[_40970 + 132 len floor32(mem[_40971])] = mem[_40971 + 32 len floor32(mem[_40971])]
                                            mem[_40970 + floor32(mem[_40971]) + -(mem[_40971] % 32) + 164 len mem[_40971] % 32] = mem[_40971 + -(mem[_40971] % 32) + floor32(mem[_40971]) + 64 len mem[_40971] % 32]
                                            call stakingTokenAddress.mem[_40970 + 132 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_40970 + 136 len _42626 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40970 + 242 len 22]
                                            else:
                                                mem[_40970 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[_40970 + 164]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40970 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    if (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) / block.timestamp - lastUpdateTime != rewardRate:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate):
                                        _33923 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33923] = 26
                                        mem[_33923 + 32] = 'SafeMath: division by zero'
                                        if not totalStakes:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _35443 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35443] = 30
                                        mem[_35443 + 32] = 'SafeMath: subtraction overflow'
                                        if t > (0 / totalStakes) + rewardPerTokenStored:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 17
                                        if not accountStakes[address(msg.sender)]:
                                            _37917 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37917] = 26
                                            mem[_37917 + 32] = 'SafeMath: division by zero'
                                            if s < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40745 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40746 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40746 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42181 = mem[_40746]
                                                mem[_40745 + 132 len floor32(mem[_40746])] = mem[_40746 + 32 len floor32(mem[_40746])]
                                                mem[_40745 + floor32(mem[_40746]) + -(mem[_40746] % 32) + 164 len mem[_40746] % 32] = mem[_40746 + -(mem[_40746] % 32) + floor32(mem[_40746]) + 64 len mem[_40746] % 32]
                                                call stakingTokenAddress.mem[_40745 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40745 + 136 len _42181 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40745 + 242 len 22]
                                                else:
                                                    mem[_40745 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40745 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40745 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40967 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40968 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40968 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42620 = mem[_40968]
                                                mem[_40967 + 132 len floor32(mem[_40968])] = mem[_40968 + 32 len floor32(mem[_40968])]
                                                mem[_40967 + floor32(mem[_40968]) + -(mem[_40968] % 32) + 164 len mem[_40968] % 32] = mem[_40968 + -(mem[_40968] % 32) + floor32(mem[_40968]) + 64 len mem[_40968] % 32]
                                                call stakingTokenAddress.mem[_40967 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40967 + 136 len _42620 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40967 + 242 len 22]
                                                else:
                                                    mem[_40967 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40967 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40967 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _38370 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38370] = 26
                                            mem[_38370 + 32] = 'SafeMath: division by zero'
                                            if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41218 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41219 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41219 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43066 = mem[_41219]
                                                mem[_41218 + 132 len floor32(mem[_41219])] = mem[_41219 + 32 len floor32(mem[_41219])]
                                                mem[_41218 + floor32(mem[_41219]) + -(mem[_41219] % 32) + 164 len mem[_41219] % 32] = mem[_41219 + -(mem[_41219] % 32) + floor32(mem[_41219]) + 64 len mem[_41219] % 32]
                                                call stakingTokenAddress.mem[_41218 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41218 + 136 len _43066 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41218 + 242 len 22]
                                                else:
                                                    mem[_41218 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41218 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41218 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41514 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41515 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41515 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43646 = mem[_41515]
                                                mem[_41514 + 132 len floor32(mem[_41515])] = mem[_41515 + 32 len floor32(mem[_41515])]
                                                mem[_41514 + floor32(mem[_41515]) + -(mem[_41515] % 32) + 164 len mem[_41515] % 32] = mem[_41515 + -(mem[_41515] % 32) + floor32(mem[_41515]) + 64 len mem[_41515] % 32]
                                                call stakingTokenAddress.mem[_41514 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41514 + 136 len _43646 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41514 + 242 len 22]
                                                else:
                                                    mem[_41514 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41514 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41514 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        if (10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _34057 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34057] = 26
                                        mem[_34057 + 32] = 'SafeMath: division by zero'
                                        if not totalStakes:
                                            revert with 0, 'SafeMath: division by zero'
                                        if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _35771 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35771] = 30
                                        mem[_35771 + 32] = 'SafeMath: subtraction overflow'
                                        if t > ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 17
                                        if not accountStakes[address(msg.sender)]:
                                            _38369 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38369] = 26
                                            mem[_38369 + 32] = 'SafeMath: division by zero'
                                            if s < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41213 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41214 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41214 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43060 = mem[_41214]
                                                mem[_41213 + 132 len floor32(mem[_41214])] = mem[_41214 + 32 len floor32(mem[_41214])]
                                                mem[_41213 + floor32(mem[_41214]) + -(mem[_41214] % 32) + 164 len mem[_41214] % 32] = mem[_41214 + -(mem[_41214] % 32) + floor32(mem[_41214]) + 64 len mem[_41214] % 32]
                                                call stakingTokenAddress.mem[_41213 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41213 + 136 len _43060 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41213 + 242 len 22]
                                                else:
                                                    mem[_41213 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41213 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41213 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41511 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41512 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41512 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43640 = mem[_41512]
                                                mem[_41511 + 132 len floor32(mem[_41512])] = mem[_41512 + 32 len floor32(mem[_41512])]
                                                mem[_41511 + floor32(mem[_41512]) + -(mem[_41512] % 32) + 164 len mem[_41512] % 32] = mem[_41512 + -(mem[_41512] % 32) + floor32(mem[_41512]) + 64 len mem[_41512] % 32]
                                                call stakingTokenAddress.mem[_41511 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41511 + 136 len _43640 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41511 + 242 len 22]
                                                else:
                                                    mem[_41511 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41511 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41511 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored - t:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _38873 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38873] = 26
                                            mem[_38873 + 32] = 'SafeMath: division by zero'
                                            if s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41833 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41834 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41834 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _44270 = mem[_41834]
                                                mem[_41833 + 132 len floor32(mem[_41834])] = mem[_41834 + 32 len floor32(mem[_41834])]
                                                mem[_41833 + floor32(mem[_41834]) + -(mem[_41834] % 32) + 164 len mem[_41834] % 32] = mem[_41834 + -(mem[_41834] % 32) + floor32(mem[_41834]) + 64 len mem[_41834] % 32]
                                                call stakingTokenAddress.mem[_41833 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41833 + 136 len _44270 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41833 + 242 len 22]
                                                else:
                                                    mem[_41833 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41833 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41833 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _42175 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _42176 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_42176 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _44960 = mem[_42176]
                                                mem[_42175 + 132 len floor32(mem[_42176])] = mem[_42176 + 32 len floor32(mem[_42176])]
                                                mem[_42175 + floor32(mem[_42176]) + -(mem[_42176] % 32) + 164 len mem[_42176] % 32] = mem[_42176 + -(mem[_42176] % 32) + floor32(mem[_42176]) + 64 len mem[_42176] % 32]
                                                call stakingTokenAddress.mem[_42175 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_42175 + 136 len _44960 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_42175 + 242 len 22]
                                                else:
                                                    mem[_42175 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_42175 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_42175 + ceil32(return_data.size) + 243 len 22]
                            else:
                                _32816 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32816] = 30
                                mem[_32816 + 32] = 'SafeMath: subtraction overflow'
                                if lastUpdateTime > periodFinish:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if not periodFinish - lastUpdateTime:
                                    _33927 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33927] = 26
                                    mem[_33927 + 32] = 'SafeMath: division by zero'
                                    if not totalStakes:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _35447 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35447] = 30
                                    mem[_35447 + 32] = 'SafeMath: subtraction overflow'
                                    if t > (0 / totalStakes) + rewardPerTokenStored:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 17
                                    if not accountStakes[address(msg.sender)]:
                                        _37921 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37921] = 26
                                        mem[_37921 + 32] = 'SafeMath: division by zero'
                                        if s < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_183ddbfb[address(msg.sender)].field_512 = s
                                        sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                        sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                        if sub_183ddbfb[address(msg.sender)].field_0:
                                            if arg1 <= 0:
                                                revert with 0, 'staking 0'
                                            _40755 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = this.address
                                            mem[mem[64] + 100] = arg1
                                            _40756 = mem[64]
                                            mem[mem[64]] = 100
                                            mem[64] = mem[64] + 132
                                            mem[_40756 + 32 len 4] = unknown_0x23b872dd(?????)
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            _42205 = mem[_40756]
                                            mem[_40755 + 132 len floor32(mem[_40756])] = mem[_40756 + 32 len floor32(mem[_40756])]
                                            mem[_40755 + floor32(mem[_40756]) + -(mem[_40756] % 32) + 164 len mem[_40756] % 32] = mem[_40756 + -(mem[_40756] % 32) + floor32(mem[_40756]) + 64 len mem[_40756] % 32]
                                            call stakingTokenAddress.mem[_40755 + 132 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_40755 + 136 len _42205 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40755 + 242 len 22]
                                            else:
                                                mem[_40755 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[_40755 + 164]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40755 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                            if arg1 <= 0:
                                                revert with 0, 'staking 0'
                                            _40977 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = this.address
                                            mem[mem[64] + 100] = arg1
                                            _40978 = mem[64]
                                            mem[mem[64]] = 100
                                            mem[64] = mem[64] + 132
                                            mem[_40978 + 32 len 4] = unknown_0x23b872dd(?????)
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            _42642 = mem[_40978]
                                            mem[_40977 + 132 len floor32(mem[_40978])] = mem[_40978 + 32 len floor32(mem[_40978])]
                                            mem[_40977 + floor32(mem[_40978]) + -(mem[_40978] % 32) + 164 len mem[_40978] % 32] = mem[_40978 + -(mem[_40978] % 32) + floor32(mem[_40978]) + 64 len mem[_40978] % 32]
                                            call stakingTokenAddress.mem[_40977 + 132 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_40977 + 136 len _42642 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40977 + 242 len 22]
                                            else:
                                                mem[_40977 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[_40977 + 164]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40977 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _38372 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38372] = 26
                                        mem[_38372 + 32] = 'SafeMath: division by zero'
                                        if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                        sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                        sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                        if sub_183ddbfb[address(msg.sender)].field_0:
                                            if arg1 <= 0:
                                                revert with 0, 'staking 0'
                                            _41228 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = this.address
                                            mem[mem[64] + 100] = arg1
                                            _41229 = mem[64]
                                            mem[mem[64]] = 100
                                            mem[64] = mem[64] + 132
                                            mem[_41229 + 32 len 4] = unknown_0x23b872dd(?????)
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            _43090 = mem[_41229]
                                            mem[_41228 + 132 len floor32(mem[_41229])] = mem[_41229 + 32 len floor32(mem[_41229])]
                                            mem[_41228 + floor32(mem[_41229]) + -(mem[_41229] % 32) + 164 len mem[_41229] % 32] = mem[_41229 + -(mem[_41229] % 32) + floor32(mem[_41229]) + 64 len mem[_41229] % 32]
                                            call stakingTokenAddress.mem[_41228 + 132 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_41228 + 136 len _43090 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_41228 + 242 len 22]
                                            else:
                                                mem[_41228 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[_41228 + 164]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_41228 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                            if arg1 <= 0:
                                                revert with 0, 'staking 0'
                                            _41530 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = this.address
                                            mem[mem[64] + 100] = arg1
                                            _41531 = mem[64]
                                            mem[mem[64]] = 100
                                            mem[64] = mem[64] + 132
                                            mem[_41531 + 32 len 4] = unknown_0x23b872dd(?????)
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            _43674 = mem[_41531]
                                            mem[_41530 + 132 len floor32(mem[_41531])] = mem[_41531 + 32 len floor32(mem[_41531])]
                                            mem[_41530 + floor32(mem[_41531]) + -(mem[_41531] % 32) + 164 len mem[_41531] % 32] = mem[_41531 + -(mem[_41531] % 32) + floor32(mem[_41531]) + 64 len mem[_41531] % 32]
                                            call stakingTokenAddress.mem[_41530 + 132 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_41530 + 136 len _43674 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_41530 + 242 len 22]
                                            else:
                                                mem[_41530 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[_41530 + 164]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_41530 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    if (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) / periodFinish - lastUpdateTime != rewardRate:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not (periodFinish * rewardRate) - (lastUpdateTime * rewardRate):
                                        _34062 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34062] = 26
                                        mem[_34062 + 32] = 'SafeMath: division by zero'
                                        if not totalStakes:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _35777 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35777] = 30
                                        mem[_35777 + 32] = 'SafeMath: subtraction overflow'
                                        if t > (0 / totalStakes) + rewardPerTokenStored:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 17
                                        if not accountStakes[address(msg.sender)]:
                                            _38371 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38371] = 26
                                            mem[_38371 + 32] = 'SafeMath: division by zero'
                                            if s < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41223 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41224 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41224 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43084 = mem[_41224]
                                                mem[_41223 + 132 len floor32(mem[_41224])] = mem[_41224 + 32 len floor32(mem[_41224])]
                                                mem[_41223 + floor32(mem[_41224]) + -(mem[_41224] % 32) + 164 len mem[_41224] % 32] = mem[_41224 + -(mem[_41224] % 32) + floor32(mem[_41224]) + 64 len mem[_41224] % 32]
                                                call stakingTokenAddress.mem[_41223 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41223 + 136 len _43084 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41223 + 242 len 22]
                                                else:
                                                    mem[_41223 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41223 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41223 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41527 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41528 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41528 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43668 = mem[_41528]
                                                mem[_41527 + 132 len floor32(mem[_41528])] = mem[_41528 + 32 len floor32(mem[_41528])]
                                                mem[_41527 + floor32(mem[_41528]) + -(mem[_41528] % 32) + 164 len mem[_41528] % 32] = mem[_41528 + -(mem[_41528] % 32) + floor32(mem[_41528]) + 64 len mem[_41528] % 32]
                                                call stakingTokenAddress.mem[_41527 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41527 + 136 len _43668 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41527 + 242 len 22]
                                                else:
                                                    mem[_41527 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41527 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41527 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _38875 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38875] = 26
                                            mem[_38875 + 32] = 'SafeMath: division by zero'
                                            if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41849 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41850 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41850 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _44300 = mem[_41850]
                                                mem[_41849 + 132 len floor32(mem[_41850])] = mem[_41850 + 32 len floor32(mem[_41850])]
                                                mem[_41849 + floor32(mem[_41850]) + -(mem[_41850] % 32) + 164 len mem[_41850] % 32] = mem[_41850 + -(mem[_41850] % 32) + floor32(mem[_41850]) + 64 len mem[_41850] % 32]
                                                call stakingTokenAddress.mem[_41849 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41849 + 136 len _44300 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41849 + 242 len 22]
                                                else:
                                                    mem[_41849 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41849 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41849 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _42199 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _42200 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_42200 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _44998 = mem[_42200]
                                                mem[_42199 + 132 len floor32(mem[_42200])] = mem[_42200 + 32 len floor32(mem[_42200])]
                                                mem[_42199 + floor32(mem[_42200]) + -(mem[_42200] % 32) + 164 len mem[_42200] % 32] = mem[_42200 + -(mem[_42200] % 32) + floor32(mem[_42200]) + 64 len mem[_42200] % 32]
                                                call stakingTokenAddress.mem[_42199 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_42199 + 136 len _44998 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_42199 + 242 len 22]
                                                else:
                                                    mem[_42199 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_42199 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_42199 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        if (10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _34228 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34228] = 26
                                        mem[_34228 + 32] = 'SafeMath: division by zero'
                                        if not totalStakes:
                                            revert with 0, 'SafeMath: division by zero'
                                        if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _36276 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36276] = 30
                                        mem[_36276 + 32] = 'SafeMath: subtraction overflow'
                                        if t > ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 17
                                        if not accountStakes[address(msg.sender)]:
                                            _38874 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38874] = 26
                                            mem[_38874 + 32] = 'SafeMath: division by zero'
                                            if s < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41844 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41845 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41845 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _44294 = mem[_41845]
                                                mem[_41844 + 132 len floor32(mem[_41845])] = mem[_41845 + 32 len floor32(mem[_41845])]
                                                mem[_41844 + floor32(mem[_41845]) + -(mem[_41845] % 32) + 164 len mem[_41845] % 32] = mem[_41845 + -(mem[_41845] % 32) + floor32(mem[_41845]) + 64 len mem[_41845] % 32]
                                                call stakingTokenAddress.mem[_41844 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41844 + 136 len _44294 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41844 + 242 len 22]
                                                else:
                                                    mem[_41844 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41844 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41844 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _42196 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _42197 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_42197 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _44992 = mem[_42197]
                                                mem[_42196 + 132 len floor32(mem[_42197])] = mem[_42197 + 32 len floor32(mem[_42197])]
                                                mem[_42196 + floor32(mem[_42197]) + -(mem[_42197] % 32) + 164 len mem[_42197] % 32] = mem[_42197 + -(mem[_42197] % 32) + floor32(mem[_42197]) + 64 len mem[_42197] % 32]
                                                call stakingTokenAddress.mem[_42196 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_42196 + 136 len _44992 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_42196 + 242 len 22]
                                                else:
                                                    mem[_42196 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_42196 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_42196 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored - t:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39493 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39493] = 26
                                            mem[_39493 + 32] = 'SafeMath: division by zero'
                                            if s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _42634 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _42635 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_42635 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _45796 = mem[_42635]
                                                mem[_42634 + 132 len floor32(mem[_42635])] = mem[_42635 + 32 len floor32(mem[_42635])]
                                                mem[_42634 + floor32(mem[_42635]) + -(mem[_42635] % 32) + 164 len mem[_42635] % 32] = mem[_42635 + -(mem[_42635] % 32) + floor32(mem[_42635]) + 64 len mem[_42635] % 32]
                                                call stakingTokenAddress.mem[_42634 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_42634 + 136 len _45796 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_42634 + 242 len 22]
                                                else:
                                                    mem[_42634 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_42634 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_42634 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _43078 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _43079 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_43079 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _46561 = mem[_43079]
                                                mem[_43078 + 132 len floor32(mem[_43079])] = mem[_43079 + 32 len floor32(mem[_43079])]
                                                mem[_43078 + floor32(mem[_43079]) + -(mem[_43079] % 32) + 164 len mem[_43079] % 32] = mem[_43079 + -(mem[_43079] % 32) + floor32(mem[_43079]) + 64 len mem[_43079] % 32]
                                                call stakingTokenAddress.mem[_43078 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_43078 + 136 len _46561 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_43078 + 242 len 22]
                                                else:
                                                    mem[_43078 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_43078 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_43078 + ceil32(return_data.size) + 243 len 22]
                else:
                    lastUpdateTime = periodFinish
                    if not msg.sender:
                        if arg1 <= 0:
                            revert with 0, 'staking 0'
                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                            revert with 0, 'SafeERC20: call to non-contract'
                        if not ext_code.hash(stakingTokenAddress):
                            revert with 0, 'SafeERC20: call to non-contract'
                        mem[356 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg1) >> 32
                        mem[480 len 4] = uint32(arg1)
                        call stakingTokenAddress with:
                             gas gas_remaining wei
                            args Mask(224, 32, arg1) << 480, mem[452 len 4]
                        if not return_data.size:
                            require not ext_call.success
                            revert with 0, 'SafeERC20: low-level call failed'
                        mem[388 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            if not mem[388]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[ceil32(return_data.size) + 467 len 22]
                    else:
                        mem[224] = 0
                        mem[256] = 0
                        mem[288] = 0
                        mem[320] = 0
                        mem[0] = msg.sender
                        mem[32] = 16
                        mem[64] = 480
                        mem[352] = sub_183ddbfb[address(msg.sender)].field_0
                        mem[384] = sub_183ddbfb[address(msg.sender)].field_256
                        mem[416] = sub_183ddbfb[address(msg.sender)].field_512
                        mem[448] = sub_183ddbfb[address(msg.sender)].field_768
                        idx = sub_183ddbfb[address(msg.sender)].field_768
                        s = sub_183ddbfb[address(msg.sender)].field_512
                        t = sub_183ddbfb[address(msg.sender)].field_256
                        while idx < sub_e7690c44:
                            require idx < sub_155b0a71.length
                            mem[0] = 15
                            if not t:
                                _32454 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32454] = 26
                                mem[_32454 + 32] = 'SafeMath: division by zero'
                                require idx < sub_155b0a71.length
                                mem[0] = 15
                                if not s:
                                    _33694 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33694] = 26
                                    mem[_33694 + 32] = 'SafeMath: division by zero'
                                    idx = idx + 1
                                    s = 0
                                    t = 0
                                    continue 
                                if sub_155b0a71[idx] * s / s != sub_155b0a71[idx]:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _33778 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33778] = 26
                                mem[_33778 + 32] = 'SafeMath: division by zero'
                                idx = idx + 1
                                s = sub_155b0a71[idx] * s / 10^18
                                t = 0
                                continue 
                            if sub_155b0a71[idx] * t / t != sub_155b0a71[idx]:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _32572 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32572] = 26
                            mem[_32572 + 32] = 'SafeMath: division by zero'
                            require idx < sub_155b0a71.length
                            mem[0] = 15
                            if not s:
                                _33777 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33777] = 26
                                mem[_33777 + 32] = 'SafeMath: division by zero'
                                idx = idx + 1
                                s = 0
                                t = sub_155b0a71[idx] * t / 10^18
                                continue 
                            if sub_155b0a71[idx] * s / s != sub_155b0a71[idx]:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _33816 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33816] = 26
                            mem[_33816 + 32] = 'SafeMath: division by zero'
                            idx = idx + 1
                            s = sub_155b0a71[idx] * s / 10^18
                            t = sub_155b0a71[idx] * t / 10^18
                            continue 
                        if 0 == totalStakes:
                            _32382 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32382] = 30
                            mem[_32382 + 32] = 'SafeMath: subtraction overflow'
                            if t > rewardPerTokenStored:
                                revert with 0, 'SafeMath: subtraction overflow'
                            mem[0] = msg.sender
                            mem[32] = 17
                            if not accountStakes[address(msg.sender)]:
                                _33337 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33337] = 26
                                mem[_33337 + 32] = 'SafeMath: division by zero'
                                if s < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                if sub_183ddbfb[address(msg.sender)].field_0:
                                    if arg1 <= 0:
                                        revert with 0, 'staking 0'
                                    _34392 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = this.address
                                    mem[mem[64] + 100] = arg1
                                    _34393 = mem[64]
                                    mem[mem[64]] = 100
                                    mem[64] = mem[64] + 132
                                    mem[_34393 + 32 len 4] = unknown_0x23b872dd(?????)
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    _35022 = mem[_34393]
                                    mem[_34392 + 132 len floor32(mem[_34393])] = mem[_34393 + 32 len floor32(mem[_34393])]
                                    mem[_34392 + floor32(mem[_34393]) + -(mem[_34393] % 32) + 164 len mem[_34393] % 32] = mem[_34393 + -(mem[_34393] % 32) + floor32(mem[_34393]) + 64 len mem[_34393] % 32]
                                    call stakingTokenAddress.mem[_34392 + 132 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_34392 + 136 len _35022 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_34392 + 242 len 22]
                                    else:
                                        mem[_34392 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[_34392 + 164]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_34392 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                    if arg1 <= 0:
                                        revert with 0, 'staking 0'
                                    _34550 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = this.address
                                    mem[mem[64] + 100] = arg1
                                    _34551 = mem[64]
                                    mem[mem[64]] = 100
                                    mem[64] = mem[64] + 132
                                    mem[_34551 + 32 len 4] = unknown_0x23b872dd(?????)
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    _35152 = mem[_34551]
                                    mem[_34550 + 132 len floor32(mem[_34551])] = mem[_34551 + 32 len floor32(mem[_34551])]
                                    mem[_34550 + floor32(mem[_34551]) + -(mem[_34551] % 32) + 164 len mem[_34551] % 32] = mem[_34551 + -(mem[_34551] % 32) + floor32(mem[_34551]) + 64 len mem[_34551] % 32]
                                    call stakingTokenAddress.mem[_34550 + 132 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_34550 + 136 len _35152 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_34550 + 242 len 22]
                                    else:
                                        mem[_34550 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[_34550 + 164]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_34550 + ceil32(return_data.size) + 243 len 22]
                            else:
                                if (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != rewardPerTokenStored - t:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _33596 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33596] = 26
                                mem[_33596 + 32] = 'SafeMath: division by zero'
                                if s + ((rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_183ddbfb[address(msg.sender)].field_512 = s + ((rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                if sub_183ddbfb[address(msg.sender)].field_0:
                                    if arg1 <= 0:
                                        revert with 0, 'staking 0'
                                    _34714 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = this.address
                                    mem[mem[64] + 100] = arg1
                                    _34715 = mem[64]
                                    mem[mem[64]] = 100
                                    mem[64] = mem[64] + 132
                                    mem[_34715 + 32 len 4] = unknown_0x23b872dd(?????)
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    _35276 = mem[_34715]
                                    mem[_34714 + 132 len floor32(mem[_34715])] = mem[_34715 + 32 len floor32(mem[_34715])]
                                    mem[_34714 + floor32(mem[_34715]) + -(mem[_34715] % 32) + 164 len mem[_34715] % 32] = mem[_34715 + -(mem[_34715] % 32) + floor32(mem[_34715]) + 64 len mem[_34715] % 32]
                                    call stakingTokenAddress.mem[_34714 + 132 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_34714 + 136 len _35276 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_34714 + 242 len 22]
                                    else:
                                        mem[_34714 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[_34714 + 164]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_34714 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                    if arg1 <= 0:
                                        revert with 0, 'staking 0'
                                    _34848 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = this.address
                                    mem[mem[64] + 100] = arg1
                                    _34849 = mem[64]
                                    mem[mem[64]] = 100
                                    mem[64] = mem[64] + 132
                                    mem[_34849 + 32 len 4] = unknown_0x23b872dd(?????)
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    _35467 = mem[_34849]
                                    mem[_34848 + 132 len floor32(mem[_34849])] = mem[_34849 + 32 len floor32(mem[_34849])]
                                    mem[_34848 + floor32(mem[_34849]) + -(mem[_34849] % 32) + 164 len mem[_34849] % 32] = mem[_34849 + -(mem[_34849] % 32) + floor32(mem[_34849]) + 64 len mem[_34849] % 32]
                                    call stakingTokenAddress.mem[_34848 + 132 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_34848 + 136 len _35467 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_34848 + 242 len 22]
                                    else:
                                        mem[_34848 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[_34848 + 164]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_34848 + ceil32(return_data.size) + 243 len 22]
                        else:
                            if block.timestamp < periodFinish:
                                _32636 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32636] = 30
                                mem[_32636 + 32] = 'SafeMath: subtraction overflow'
                                if lastUpdateTime > block.timestamp:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if not block.timestamp - lastUpdateTime:
                                    _33840 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33840] = 26
                                    mem[_33840 + 32] = 'SafeMath: division by zero'
                                    if not totalStakes:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _35148 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35148] = 30
                                    mem[_35148 + 32] = 'SafeMath: subtraction overflow'
                                    if t > (0 / totalStakes) + rewardPerTokenStored:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 17
                                    if not accountStakes[address(msg.sender)]:
                                        _37458 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37458] = 26
                                        mem[_37458 + 32] = 'SafeMath: division by zero'
                                        if s < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_183ddbfb[address(msg.sender)].field_512 = s
                                        sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                        sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                        if sub_183ddbfb[address(msg.sender)].field_0:
                                            if arg1 <= 0:
                                                revert with 0, 'staking 0'
                                            _40486 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = this.address
                                            mem[mem[64] + 100] = arg1
                                            _40487 = mem[64]
                                            mem[mem[64]] = 100
                                            mem[64] = mem[64] + 132
                                            mem[_40487 + 32 len 4] = unknown_0x23b872dd(?????)
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            _41544 = mem[_40487]
                                            mem[_40486 + 132 len floor32(mem[_40487])] = mem[_40487 + 32 len floor32(mem[_40487])]
                                            mem[_40486 + floor32(mem[_40487]) + -(mem[_40487] % 32) + 164 len mem[_40487] % 32] = mem[_40487 + -(mem[_40487] % 32) + floor32(mem[_40487]) + 64 len mem[_40487] % 32]
                                            call stakingTokenAddress.mem[_40486 + 132 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_40486 + 136 len _41544 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40486 + 242 len 22]
                                            else:
                                                mem[_40486 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[_40486 + 164]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40486 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                            if arg1 <= 0:
                                                revert with 0, 'staking 0'
                                            _40590 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = this.address
                                            mem[mem[64] + 100] = arg1
                                            _40591 = mem[64]
                                            mem[mem[64]] = 100
                                            mem[64] = mem[64] + 132
                                            mem[_40591 + 32 len 4] = unknown_0x23b872dd(?????)
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            _41862 = mem[_40591]
                                            mem[_40590 + 132 len floor32(mem[_40591])] = mem[_40591 + 32 len floor32(mem[_40591])]
                                            mem[_40590 + floor32(mem[_40591]) + -(mem[_40591] % 32) + 164 len mem[_40591] % 32] = mem[_40591 + -(mem[_40591] % 32) + floor32(mem[_40591]) + 64 len mem[_40591] % 32]
                                            call stakingTokenAddress.mem[_40590 + 132 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_40590 + 136 len _41862 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40590 + 242 len 22]
                                            else:
                                                mem[_40590 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[_40590 + 164]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40590 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _37933 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37933] = 26
                                        mem[_37933 + 32] = 'SafeMath: division by zero'
                                        if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                        sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                        sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                        if sub_183ddbfb[address(msg.sender)].field_0:
                                            if arg1 <= 0:
                                                revert with 0, 'staking 0'
                                            _40765 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = this.address
                                            mem[mem[64] + 100] = arg1
                                            _40766 = mem[64]
                                            mem[mem[64]] = 100
                                            mem[64] = mem[64] + 132
                                            mem[_40766 + 32 len 4] = unknown_0x23b872dd(?????)
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            _42220 = mem[_40766]
                                            mem[_40765 + 132 len floor32(mem[_40766])] = mem[_40766 + 32 len floor32(mem[_40766])]
                                            mem[_40765 + floor32(mem[_40766]) + -(mem[_40766] % 32) + 164 len mem[_40766] % 32] = mem[_40766 + -(mem[_40766] % 32) + floor32(mem[_40766]) + 64 len mem[_40766] % 32]
                                            call stakingTokenAddress.mem[_40765 + 132 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_40765 + 136 len _42220 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40765 + 242 len 22]
                                            else:
                                                mem[_40765 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[_40765 + 164]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40765 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                            if arg1 <= 0:
                                                revert with 0, 'staking 0'
                                            _40987 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = this.address
                                            mem[mem[64] + 100] = arg1
                                            _40988 = mem[64]
                                            mem[mem[64]] = 100
                                            mem[64] = mem[64] + 132
                                            mem[_40988 + 32 len 4] = unknown_0x23b872dd(?????)
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            _42654 = mem[_40988]
                                            mem[_40987 + 132 len floor32(mem[_40988])] = mem[_40988 + 32 len floor32(mem[_40988])]
                                            mem[_40987 + floor32(mem[_40988]) + -(mem[_40988] % 32) + 164 len mem[_40988] % 32] = mem[_40988 + -(mem[_40988] % 32) + floor32(mem[_40988]) + 64 len mem[_40988] % 32]
                                            call stakingTokenAddress.mem[_40987 + 132 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_40987 + 136 len _42654 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40987 + 242 len 22]
                                            else:
                                                mem[_40987 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[_40987 + 164]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40987 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    if (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) / block.timestamp - lastUpdateTime != rewardRate:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate):
                                        _33930 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33930] = 26
                                        mem[_33930 + 32] = 'SafeMath: division by zero'
                                        if not totalStakes:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _35459 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35459] = 30
                                        mem[_35459 + 32] = 'SafeMath: subtraction overflow'
                                        if t > (0 / totalStakes) + rewardPerTokenStored:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 17
                                        if not accountStakes[address(msg.sender)]:
                                            _37932 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37932] = 26
                                            mem[_37932 + 32] = 'SafeMath: division by zero'
                                            if s < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40760 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40761 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40761 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42214 = mem[_40761]
                                                mem[_40760 + 132 len floor32(mem[_40761])] = mem[_40761 + 32 len floor32(mem[_40761])]
                                                mem[_40760 + floor32(mem[_40761]) + -(mem[_40761] % 32) + 164 len mem[_40761] % 32] = mem[_40761 + -(mem[_40761] % 32) + floor32(mem[_40761]) + 64 len mem[_40761] % 32]
                                                call stakingTokenAddress.mem[_40760 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40760 + 136 len _42214 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40760 + 242 len 22]
                                                else:
                                                    mem[_40760 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40760 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40760 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40984 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40985 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40985 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42648 = mem[_40985]
                                                mem[_40984 + 132 len floor32(mem[_40985])] = mem[_40985 + 32 len floor32(mem[_40985])]
                                                mem[_40984 + floor32(mem[_40985]) + -(mem[_40985] % 32) + 164 len mem[_40985] % 32] = mem[_40985 + -(mem[_40985] % 32) + floor32(mem[_40985]) + 64 len mem[_40985] % 32]
                                                call stakingTokenAddress.mem[_40984 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40984 + 136 len _42648 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40984 + 242 len 22]
                                                else:
                                                    mem[_40984 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40984 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40984 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _38386 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38386] = 26
                                            mem[_38386 + 32] = 'SafeMath: division by zero'
                                            if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41238 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41239 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41239 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43106 = mem[_41239]
                                                mem[_41238 + 132 len floor32(mem[_41239])] = mem[_41239 + 32 len floor32(mem[_41239])]
                                                mem[_41238 + floor32(mem[_41239]) + -(mem[_41239] % 32) + 164 len mem[_41239] % 32] = mem[_41239 + -(mem[_41239] % 32) + floor32(mem[_41239]) + 64 len mem[_41239] % 32]
                                                call stakingTokenAddress.mem[_41238 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41238 + 136 len _43106 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41238 + 242 len 22]
                                                else:
                                                    mem[_41238 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41238 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41238 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41538 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41539 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41539 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43691 = mem[_41539]
                                                mem[_41538 + 132 len floor32(mem[_41539])] = mem[_41539 + 32 len floor32(mem[_41539])]
                                                mem[_41538 + floor32(mem[_41539]) + -(mem[_41539] % 32) + 164 len mem[_41539] % 32] = mem[_41539 + -(mem[_41539] % 32) + floor32(mem[_41539]) + 64 len mem[_41539] % 32]
                                                call stakingTokenAddress.mem[_41538 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41538 + 136 len _43691 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41538 + 242 len 22]
                                                else:
                                                    mem[_41538 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41538 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41538 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        if (10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _34066 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34066] = 26
                                        mem[_34066 + 32] = 'SafeMath: division by zero'
                                        if not totalStakes:
                                            revert with 0, 'SafeMath: division by zero'
                                        if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _35792 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35792] = 30
                                        mem[_35792 + 32] = 'SafeMath: subtraction overflow'
                                        if t > ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 17
                                        if not accountStakes[address(msg.sender)]:
                                            _38385 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38385] = 26
                                            mem[_38385 + 32] = 'SafeMath: division by zero'
                                            if s < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41233 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41234 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41234 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43100 = mem[_41234]
                                                mem[_41233 + 132 len floor32(mem[_41234])] = mem[_41234 + 32 len floor32(mem[_41234])]
                                                mem[_41233 + floor32(mem[_41234]) + -(mem[_41234] % 32) + 164 len mem[_41234] % 32] = mem[_41234 + -(mem[_41234] % 32) + floor32(mem[_41234]) + 64 len mem[_41234] % 32]
                                                call stakingTokenAddress.mem[_41233 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41233 + 136 len _43100 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41233 + 242 len 22]
                                                else:
                                                    mem[_41233 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41233 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41233 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41535 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41536 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41536 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43685 = mem[_41536]
                                                mem[_41535 + 132 len floor32(mem[_41536])] = mem[_41536 + 32 len floor32(mem[_41536])]
                                                mem[_41535 + floor32(mem[_41536]) + -(mem[_41536] % 32) + 164 len mem[_41536] % 32] = mem[_41536 + -(mem[_41536] % 32) + floor32(mem[_41536]) + 64 len mem[_41536] % 32]
                                                call stakingTokenAddress.mem[_41535 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41535 + 136 len _43685 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41535 + 242 len 22]
                                                else:
                                                    mem[_41535 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41535 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41535 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored - t:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _38896 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38896] = 26
                                            mem[_38896 + 32] = 'SafeMath: division by zero'
                                            if s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41854 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41855 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41855 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _44315 = mem[_41855]
                                                mem[_41854 + 132 len floor32(mem[_41855])] = mem[_41855 + 32 len floor32(mem[_41855])]
                                                mem[_41854 + floor32(mem[_41855]) + -(mem[_41855] % 32) + 164 len mem[_41855] % 32] = mem[_41855 + -(mem[_41855] % 32) + floor32(mem[_41855]) + 64 len mem[_41855] % 32]
                                                call stakingTokenAddress.mem[_41854 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41854 + 136 len _44315 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41854 + 242 len 22]
                                                else:
                                                    mem[_41854 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41854 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41854 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _42208 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _42209 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_42209 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _45020 = mem[_42209]
                                                mem[_42208 + 132 len floor32(mem[_42209])] = mem[_42209 + 32 len floor32(mem[_42209])]
                                                mem[_42208 + floor32(mem[_42209]) + -(mem[_42209] % 32) + 164 len mem[_42209] % 32] = mem[_42209 + -(mem[_42209] % 32) + floor32(mem[_42209]) + 64 len mem[_42209] % 32]
                                                call stakingTokenAddress.mem[_42208 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_42208 + 136 len _45020 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_42208 + 242 len 22]
                                                else:
                                                    mem[_42208 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_42208 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_42208 + ceil32(return_data.size) + 243 len 22]
                            else:
                                _32822 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32822] = 30
                                mem[_32822 + 32] = 'SafeMath: subtraction overflow'
                                if lastUpdateTime > periodFinish:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if not periodFinish - lastUpdateTime:
                                    _33934 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33934] = 26
                                    mem[_33934 + 32] = 'SafeMath: division by zero'
                                    if not totalStakes:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _35463 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35463] = 30
                                    mem[_35463 + 32] = 'SafeMath: subtraction overflow'
                                    if t > (0 / totalStakes) + rewardPerTokenStored:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 17
                                    if not accountStakes[address(msg.sender)]:
                                        _37936 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37936] = 26
                                        mem[_37936 + 32] = 'SafeMath: division by zero'
                                        if s < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_183ddbfb[address(msg.sender)].field_512 = s
                                        sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                        sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                        if sub_183ddbfb[address(msg.sender)].field_0:
                                            if arg1 <= 0:
                                                revert with 0, 'staking 0'
                                            _40770 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = this.address
                                            mem[mem[64] + 100] = arg1
                                            _40771 = mem[64]
                                            mem[mem[64]] = 100
                                            mem[64] = mem[64] + 132
                                            mem[_40771 + 32 len 4] = unknown_0x23b872dd(?????)
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            _42238 = mem[_40771]
                                            mem[_40770 + 132 len floor32(mem[_40771])] = mem[_40771 + 32 len floor32(mem[_40771])]
                                            mem[_40770 + floor32(mem[_40771]) + -(mem[_40771] % 32) + 164 len mem[_40771] % 32] = mem[_40771 + -(mem[_40771] % 32) + floor32(mem[_40771]) + 64 len mem[_40771] % 32]
                                            call stakingTokenAddress.mem[_40770 + 132 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_40770 + 136 len _42238 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40770 + 242 len 22]
                                            else:
                                                mem[_40770 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[_40770 + 164]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40770 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                            if arg1 <= 0:
                                                revert with 0, 'staking 0'
                                            _40994 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = this.address
                                            mem[mem[64] + 100] = arg1
                                            _40995 = mem[64]
                                            mem[mem[64]] = 100
                                            mem[64] = mem[64] + 132
                                            mem[_40995 + 32 len 4] = unknown_0x23b872dd(?????)
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            _42670 = mem[_40995]
                                            mem[_40994 + 132 len floor32(mem[_40995])] = mem[_40995 + 32 len floor32(mem[_40995])]
                                            mem[_40994 + floor32(mem[_40995]) + -(mem[_40995] % 32) + 164 len mem[_40995] % 32] = mem[_40995 + -(mem[_40995] % 32) + floor32(mem[_40995]) + 64 len mem[_40995] % 32]
                                            call stakingTokenAddress.mem[_40994 + 132 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_40994 + 136 len _42670 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40994 + 242 len 22]
                                            else:
                                                mem[_40994 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[_40994 + 164]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40994 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _38388 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38388] = 26
                                        mem[_38388 + 32] = 'SafeMath: division by zero'
                                        if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                        sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                        sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                        if sub_183ddbfb[address(msg.sender)].field_0:
                                            if arg1 <= 0:
                                                revert with 0, 'staking 0'
                                            _41248 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = this.address
                                            mem[mem[64] + 100] = arg1
                                            _41249 = mem[64]
                                            mem[mem[64]] = 100
                                            mem[64] = mem[64] + 132
                                            mem[_41249 + 32 len 4] = unknown_0x23b872dd(?????)
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            _43130 = mem[_41249]
                                            mem[_41248 + 132 len floor32(mem[_41249])] = mem[_41249 + 32 len floor32(mem[_41249])]
                                            mem[_41248 + floor32(mem[_41249]) + -(mem[_41249] % 32) + 164 len mem[_41249] % 32] = mem[_41249 + -(mem[_41249] % 32) + floor32(mem[_41249]) + 64 len mem[_41249] % 32]
                                            call stakingTokenAddress.mem[_41248 + 132 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_41248 + 136 len _43130 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_41248 + 242 len 22]
                                            else:
                                                mem[_41248 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[_41248 + 164]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_41248 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                            if arg1 <= 0:
                                                revert with 0, 'staking 0'
                                            _41554 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = this.address
                                            mem[mem[64] + 100] = arg1
                                            _41555 = mem[64]
                                            mem[mem[64]] = 100
                                            mem[64] = mem[64] + 132
                                            mem[_41555 + 32 len 4] = unknown_0x23b872dd(?????)
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            _43719 = mem[_41555]
                                            mem[_41554 + 132 len floor32(mem[_41555])] = mem[_41555 + 32 len floor32(mem[_41555])]
                                            mem[_41554 + floor32(mem[_41555]) + -(mem[_41555] % 32) + 164 len mem[_41555] % 32] = mem[_41555 + -(mem[_41555] % 32) + floor32(mem[_41555]) + 64 len mem[_41555] % 32]
                                            call stakingTokenAddress.mem[_41554 + 132 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_41554 + 136 len _43719 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_41554 + 242 len 22]
                                            else:
                                                mem[_41554 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[_41554 + 164]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_41554 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    if (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) / periodFinish - lastUpdateTime != rewardRate:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not (periodFinish * rewardRate) - (lastUpdateTime * rewardRate):
                                        _34071 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34071] = 26
                                        mem[_34071 + 32] = 'SafeMath: division by zero'
                                        if not totalStakes:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _35798 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35798] = 30
                                        mem[_35798 + 32] = 'SafeMath: subtraction overflow'
                                        if t > (0 / totalStakes) + rewardPerTokenStored:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 17
                                        if not accountStakes[address(msg.sender)]:
                                            _38387 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38387] = 26
                                            mem[_38387 + 32] = 'SafeMath: division by zero'
                                            if s < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41243 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41244 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41244 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43124 = mem[_41244]
                                                mem[_41243 + 132 len floor32(mem[_41244])] = mem[_41244 + 32 len floor32(mem[_41244])]
                                                mem[_41243 + floor32(mem[_41244]) + -(mem[_41244] % 32) + 164 len mem[_41244] % 32] = mem[_41244 + -(mem[_41244] % 32) + floor32(mem[_41244]) + 64 len mem[_41244] % 32]
                                                call stakingTokenAddress.mem[_41243 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41243 + 136 len _43124 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41243 + 242 len 22]
                                                else:
                                                    mem[_41243 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41243 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41243 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41551 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41552 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41552 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43713 = mem[_41552]
                                                mem[_41551 + 132 len floor32(mem[_41552])] = mem[_41552 + 32 len floor32(mem[_41552])]
                                                mem[_41551 + floor32(mem[_41552]) + -(mem[_41552] % 32) + 164 len mem[_41552] % 32] = mem[_41552 + -(mem[_41552] % 32) + floor32(mem[_41552]) + 64 len mem[_41552] % 32]
                                                call stakingTokenAddress.mem[_41551 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41551 + 136 len _43713 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41551 + 242 len 22]
                                                else:
                                                    mem[_41551 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41551 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41551 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _38898 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38898] = 26
                                            mem[_38898 + 32] = 'SafeMath: division by zero'
                                            if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41870 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41871 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41871 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _44345 = mem[_41871]
                                                mem[_41870 + 132 len floor32(mem[_41871])] = mem[_41871 + 32 len floor32(mem[_41871])]
                                                mem[_41870 + floor32(mem[_41871]) + -(mem[_41871] % 32) + 164 len mem[_41871] % 32] = mem[_41871 + -(mem[_41871] % 32) + floor32(mem[_41871]) + 64 len mem[_41871] % 32]
                                                call stakingTokenAddress.mem[_41870 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41870 + 136 len _44345 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41870 + 242 len 22]
                                                else:
                                                    mem[_41870 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41870 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41870 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _42232 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _42233 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_42233 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _45058 = mem[_42233]
                                                mem[_42232 + 132 len floor32(mem[_42233])] = mem[_42233 + 32 len floor32(mem[_42233])]
                                                mem[_42232 + floor32(mem[_42233]) + -(mem[_42233] % 32) + 164 len mem[_42233] % 32] = mem[_42233 + -(mem[_42233] % 32) + floor32(mem[_42233]) + 64 len mem[_42233] % 32]
                                                call stakingTokenAddress.mem[_42232 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_42232 + 136 len _45058 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_42232 + 242 len 22]
                                                else:
                                                    mem[_42232 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_42232 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_42232 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        if (10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _34240 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34240] = 26
                                        mem[_34240 + 32] = 'SafeMath: division by zero'
                                        if not totalStakes:
                                            revert with 0, 'SafeMath: division by zero'
                                        if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _36299 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36299] = 30
                                        mem[_36299 + 32] = 'SafeMath: subtraction overflow'
                                        if t > ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 17
                                        if not accountStakes[address(msg.sender)]:
                                            _38897 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38897] = 26
                                            mem[_38897 + 32] = 'SafeMath: division by zero'
                                            if s < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41865 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41866 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41866 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _44339 = mem[_41866]
                                                mem[_41865 + 132 len floor32(mem[_41866])] = mem[_41866 + 32 len floor32(mem[_41866])]
                                                mem[_41865 + floor32(mem[_41866]) + -(mem[_41866] % 32) + 164 len mem[_41866] % 32] = mem[_41866 + -(mem[_41866] % 32) + floor32(mem[_41866]) + 64 len mem[_41866] % 32]
                                                call stakingTokenAddress.mem[_41865 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41865 + 136 len _44339 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41865 + 242 len 22]
                                                else:
                                                    mem[_41865 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41865 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41865 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _42229 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _42230 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_42230 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _45052 = mem[_42230]
                                                mem[_42229 + 132 len floor32(mem[_42230])] = mem[_42230 + 32 len floor32(mem[_42230])]
                                                mem[_42229 + floor32(mem[_42230]) + -(mem[_42230] % 32) + 164 len mem[_42230] % 32] = mem[_42230 + -(mem[_42230] % 32) + floor32(mem[_42230]) + 64 len mem[_42230] % 32]
                                                call stakingTokenAddress.mem[_42229 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_42229 + 136 len _45052 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_42229 + 242 len 22]
                                                else:
                                                    mem[_42229 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_42229 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_42229 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored - t:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39520 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39520] = 26
                                            mem[_39520 + 32] = 'SafeMath: division by zero'
                                            if s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _42662 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _42663 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_42663 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _45848 = mem[_42663]
                                                mem[_42662 + 132 len floor32(mem[_42663])] = mem[_42663 + 32 len floor32(mem[_42663])]
                                                mem[_42662 + floor32(mem[_42663]) + -(mem[_42663] % 32) + 164 len mem[_42663] % 32] = mem[_42663 + -(mem[_42663] % 32) + floor32(mem[_42663]) + 64 len mem[_42663] % 32]
                                                call stakingTokenAddress.mem[_42662 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_42662 + 136 len _45848 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_42662 + 242 len 22]
                                                else:
                                                    mem[_42662 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_42662 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_42662 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _43118 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _43119 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_43119 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _46622 = mem[_43119]
                                                mem[_43118 + 132 len floor32(mem[_43119])] = mem[_43119 + 32 len floor32(mem[_43119])]
                                                mem[_43118 + floor32(mem[_43119]) + -(mem[_43119] % 32) + 164 len mem[_43119] % 32] = mem[_43119 + -(mem[_43119] % 32) + floor32(mem[_43119]) + 64 len mem[_43119] % 32]
                                                call stakingTokenAddress.mem[_43118 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_43118 + 136 len _46622 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_43118 + 242 len 22]
                                                else:
                                                    mem[_43118 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_43118 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_43118 + ceil32(return_data.size) + 243 len 22]
            else:
                if (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) / block.timestamp - lastUpdateTime != rewardRate:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                if not (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate):
                    mem[160] = 26
                    mem[192] = 'SafeMath: division by zero'
                    if not totalStakes:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                        revert with 0, 'SafeMath: addition overflow'
                    rewardPerTokenStored += 0 / totalStakes
                    if block.timestamp < periodFinish:
                        lastUpdateTime = block.timestamp
                        if not msg.sender:
                            if arg1 <= 0:
                                revert with 0, 'staking 0'
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                revert with 0, 'SafeERC20: call to non-contract'
                            if not ext_code.hash(stakingTokenAddress):
                                revert with 0, 'SafeERC20: call to non-contract'
                            mem[356 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg1) >> 32
                            mem[480 len 4] = uint32(arg1)
                            call stakingTokenAddress with:
                                 gas gas_remaining wei
                                args Mask(224, 32, arg1) << 480, mem[452 len 4]
                            if not return_data.size:
                                require not ext_call.success
                                revert with 0, 'SafeERC20: low-level call failed'
                            mem[388 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[388]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[ceil32(return_data.size) + 467 len 22]
                        else:
                            mem[224] = 0
                            mem[256] = 0
                            mem[288] = 0
                            mem[320] = 0
                            mem[0] = msg.sender
                            mem[32] = 16
                            mem[64] = 480
                            mem[352] = sub_183ddbfb[address(msg.sender)].field_0
                            mem[384] = sub_183ddbfb[address(msg.sender)].field_256
                            mem[416] = sub_183ddbfb[address(msg.sender)].field_512
                            mem[448] = sub_183ddbfb[address(msg.sender)].field_768
                            idx = sub_183ddbfb[address(msg.sender)].field_768
                            s = sub_183ddbfb[address(msg.sender)].field_512
                            t = sub_183ddbfb[address(msg.sender)].field_256
                            while idx < sub_e7690c44:
                                require idx < sub_155b0a71.length
                                mem[0] = 15
                                if not t:
                                    _32439 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32439] = 26
                                    mem[_32439 + 32] = 'SafeMath: division by zero'
                                    require idx < sub_155b0a71.length
                                    mem[0] = 15
                                    if not s:
                                        _33682 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33682] = 26
                                        mem[_33682 + 32] = 'SafeMath: division by zero'
                                        idx = idx + 1
                                        s = 0
                                        t = 0
                                        continue 
                                    if sub_155b0a71[idx] * s / s != sub_155b0a71[idx]:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _33766 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33766] = 26
                                    mem[_33766 + 32] = 'SafeMath: division by zero'
                                    idx = idx + 1
                                    s = sub_155b0a71[idx] * s / 10^18
                                    t = 0
                                    continue 
                                if sub_155b0a71[idx] * t / t != sub_155b0a71[idx]:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _32554 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32554] = 26
                                mem[_32554 + 32] = 'SafeMath: division by zero'
                                require idx < sub_155b0a71.length
                                mem[0] = 15
                                if not s:
                                    _33765 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33765] = 26
                                    mem[_33765 + 32] = 'SafeMath: division by zero'
                                    idx = idx + 1
                                    s = 0
                                    t = sub_155b0a71[idx] * t / 10^18
                                    continue 
                                if sub_155b0a71[idx] * s / s != sub_155b0a71[idx]:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _33813 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33813] = 26
                                mem[_33813 + 32] = 'SafeMath: division by zero'
                                idx = idx + 1
                                s = sub_155b0a71[idx] * s / 10^18
                                t = sub_155b0a71[idx] * t / 10^18
                                continue 
                            if 0 == totalStakes:
                                _32367 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32367] = 30
                                mem[_32367 + 32] = 'SafeMath: subtraction overflow'
                                if t > rewardPerTokenStored:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 17
                                if not accountStakes[address(msg.sender)]:
                                    _33307 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33307] = 26
                                    mem[_33307 + 32] = 'SafeMath: division by zero'
                                    if s < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_183ddbfb[address(msg.sender)].field_512 = s
                                    sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                    sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                    if sub_183ddbfb[address(msg.sender)].field_0:
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _34365 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _34366 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_34366 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _34989 = mem[_34366]
                                        mem[_34365 + 132 len floor32(mem[_34366])] = mem[_34366 + 32 len floor32(mem[_34366])]
                                        mem[_34365 + floor32(mem[_34366]) + -(mem[_34366] % 32) + 164 len mem[_34366] % 32] = mem[_34366 + -(mem[_34366] % 32) + floor32(mem[_34366]) + 64 len mem[_34366] % 32]
                                        call stakingTokenAddress.mem[_34365 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_34365 + 136 len _34989 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34365 + 242 len 22]
                                        else:
                                            mem[_34365 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_34365 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34365 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _34508 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _34509 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_34509 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _35131 = mem[_34509]
                                        mem[_34508 + 132 len floor32(mem[_34509])] = mem[_34509 + 32 len floor32(mem[_34509])]
                                        mem[_34508 + floor32(mem[_34509]) + -(mem[_34509] % 32) + 164 len mem[_34509] % 32] = mem[_34509 + -(mem[_34509] % 32) + floor32(mem[_34509]) + 64 len mem[_34509] % 32]
                                        call stakingTokenAddress.mem[_34508 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_34508 + 136 len _35131 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34508 + 242 len 22]
                                        else:
                                            mem[_34508 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_34508 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34508 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    if (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != rewardPerTokenStored - t:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _33569 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33569] = 26
                                    mem[_33569 + 32] = 'SafeMath: division by zero'
                                    if s + ((rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_183ddbfb[address(msg.sender)].field_512 = s + ((rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                    sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                    sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                    if sub_183ddbfb[address(msg.sender)].field_0:
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _34687 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _34688 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_34688 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _35240 = mem[_34688]
                                        mem[_34687 + 132 len floor32(mem[_34688])] = mem[_34688 + 32 len floor32(mem[_34688])]
                                        mem[_34687 + floor32(mem[_34688]) + -(mem[_34688] % 32) + 164 len mem[_34688] % 32] = mem[_34688 + -(mem[_34688] % 32) + floor32(mem[_34688]) + 64 len mem[_34688] % 32]
                                        call stakingTokenAddress.mem[_34687 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_34687 + 136 len _35240 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34687 + 242 len 22]
                                        else:
                                            mem[_34687 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_34687 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34687 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _34818 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _34819 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_34819 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _35419 = mem[_34819]
                                        mem[_34818 + 132 len floor32(mem[_34819])] = mem[_34819 + 32 len floor32(mem[_34819])]
                                        mem[_34818 + floor32(mem[_34819]) + -(mem[_34819] % 32) + 164 len mem[_34819] % 32] = mem[_34819 + -(mem[_34819] % 32) + floor32(mem[_34819]) + 64 len mem[_34819] % 32]
                                        call stakingTokenAddress.mem[_34818 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_34818 + 136 len _35419 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34818 + 242 len 22]
                                        else:
                                            mem[_34818 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_34818 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34818 + ceil32(return_data.size) + 243 len 22]
                            else:
                                if block.timestamp < periodFinish:
                                    _32627 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32627] = 30
                                    mem[_32627 + 32] = 'SafeMath: subtraction overflow'
                                    if lastUpdateTime > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not block.timestamp - lastUpdateTime:
                                        _33831 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33831] = 26
                                        mem[_33831 + 32] = 'SafeMath: division by zero'
                                        if not totalStakes:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _35127 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35127] = 30
                                        mem[_35127 + 32] = 'SafeMath: subtraction overflow'
                                        if t > (0 / totalStakes) + rewardPerTokenStored:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 17
                                        if not accountStakes[address(msg.sender)]:
                                            _37413 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37413] = 26
                                            mem[_37413 + 32] = 'SafeMath: division by zero'
                                            if s < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40471 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40472 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40472 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _41472 = mem[_40472]
                                                mem[_40471 + 132 len floor32(mem[_40472])] = mem[_40472 + 32 len floor32(mem[_40472])]
                                                mem[_40471 + floor32(mem[_40472]) + -(mem[_40472] % 32) + 164 len mem[_40472] % 32] = mem[_40472 + -(mem[_40472] % 32) + floor32(mem[_40472]) + 64 len mem[_40472] % 32]
                                                call stakingTokenAddress.mem[_40471 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40471 + 136 len _41472 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40471 + 242 len 22]
                                                else:
                                                    mem[_40471 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40471 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40471 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40557 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40558 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40558 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _41799 = mem[_40558]
                                                mem[_40557 + 132 len floor32(mem[_40558])] = mem[_40558 + 32 len floor32(mem[_40558])]
                                                mem[_40557 + floor32(mem[_40558]) + -(mem[_40558] % 32) + 164 len mem[_40558] % 32] = mem[_40558 + -(mem[_40558] % 32) + floor32(mem[_40558]) + 64 len mem[_40558] % 32]
                                                call stakingTokenAddress.mem[_40557 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40557 + 136 len _41799 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40557 + 242 len 22]
                                                else:
                                                    mem[_40557 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40557 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40557 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _37888 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37888] = 26
                                            mem[_37888 + 32] = 'SafeMath: division by zero'
                                            if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40720 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40721 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40721 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42121 = mem[_40721]
                                                mem[_40720 + 132 len floor32(mem[_40721])] = mem[_40721 + 32 len floor32(mem[_40721])]
                                                mem[_40720 + floor32(mem[_40721]) + -(mem[_40721] % 32) + 164 len mem[_40721] % 32] = mem[_40721 + -(mem[_40721] % 32) + floor32(mem[_40721]) + 64 len mem[_40721] % 32]
                                                call stakingTokenAddress.mem[_40720 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40720 + 136 len _42121 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40720 + 242 len 22]
                                                else:
                                                    mem[_40720 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40720 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40720 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40936 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40937 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40937 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42570 = mem[_40937]
                                                mem[_40936 + 132 len floor32(mem[_40937])] = mem[_40937 + 32 len floor32(mem[_40937])]
                                                mem[_40936 + floor32(mem[_40937]) + -(mem[_40937] % 32) + 164 len mem[_40937] % 32] = mem[_40937 + -(mem[_40937] % 32) + floor32(mem[_40937]) + 64 len mem[_40937] % 32]
                                                call stakingTokenAddress.mem[_40936 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40936 + 136 len _42570 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40936 + 242 len 22]
                                                else:
                                                    mem[_40936 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40936 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40936 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        if (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) / block.timestamp - lastUpdateTime != rewardRate:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate):
                                            _33909 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33909] = 26
                                            mem[_33909 + 32] = 'SafeMath: division by zero'
                                            if not totalStakes:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _35411 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35411] = 30
                                            mem[_35411 + 32] = 'SafeMath: subtraction overflow'
                                            if t > (0 / totalStakes) + rewardPerTokenStored:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 17
                                            if not accountStakes[address(msg.sender)]:
                                                _37887 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37887] = 26
                                                mem[_37887 + 32] = 'SafeMath: division by zero'
                                                if s < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _40715 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _40716 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_40716 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _42115 = mem[_40716]
                                                    mem[_40715 + 132 len floor32(mem[_40716])] = mem[_40716 + 32 len floor32(mem[_40716])]
                                                    mem[_40715 + floor32(mem[_40716]) + -(mem[_40716] % 32) + 164 len mem[_40716] % 32] = mem[_40716 + -(mem[_40716] % 32) + floor32(mem[_40716]) + 64 len mem[_40716] % 32]
                                                    call stakingTokenAddress.mem[_40715 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_40715 + 136 len _42115 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_40715 + 242 len 22]
                                                    else:
                                                        mem[_40715 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_40715 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_40715 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _40933 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _40934 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_40934 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _42564 = mem[_40934]
                                                    mem[_40933 + 132 len floor32(mem[_40934])] = mem[_40934 + 32 len floor32(mem[_40934])]
                                                    mem[_40933 + floor32(mem[_40934]) + -(mem[_40934] % 32) + 164 len mem[_40934] % 32] = mem[_40934 + -(mem[_40934] % 32) + floor32(mem[_40934]) + 64 len mem[_40934] % 32]
                                                    call stakingTokenAddress.mem[_40933 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_40933 + 136 len _42564 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_40933 + 242 len 22]
                                                    else:
                                                        mem[_40933 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_40933 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_40933 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _38338 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38338] = 26
                                                mem[_38338 + 32] = 'SafeMath: division by zero'
                                                if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41178 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41179 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41179 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _42986 = mem[_41179]
                                                    mem[_41178 + 132 len floor32(mem[_41179])] = mem[_41179 + 32 len floor32(mem[_41179])]
                                                    mem[_41178 + floor32(mem[_41179]) + -(mem[_41179] % 32) + 164 len mem[_41179] % 32] = mem[_41179 + -(mem[_41179] % 32) + floor32(mem[_41179]) + 64 len mem[_41179] % 32]
                                                    call stakingTokenAddress.mem[_41178 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41178 + 136 len _42986 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41178 + 242 len 22]
                                                    else:
                                                        mem[_41178 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41178 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41178 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41466 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41467 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41467 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43556 = mem[_41467]
                                                    mem[_41466 + 132 len floor32(mem[_41467])] = mem[_41467 + 32 len floor32(mem[_41467])]
                                                    mem[_41466 + floor32(mem[_41467]) + -(mem[_41467] % 32) + 164 len mem[_41467] % 32] = mem[_41467 + -(mem[_41467] % 32) + floor32(mem[_41467]) + 64 len mem[_41467] % 32]
                                                    call stakingTokenAddress.mem[_41466 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41466 + 136 len _43556 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41466 + 242 len 22]
                                                    else:
                                                        mem[_41466 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41466 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41466 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _34039 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34039] = 26
                                            mem[_34039 + 32] = 'SafeMath: division by zero'
                                            if not totalStakes:
                                                revert with 0, 'SafeMath: division by zero'
                                            if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _35729 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35729] = 30
                                            mem[_35729 + 32] = 'SafeMath: subtraction overflow'
                                            if t > ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 17
                                            if not accountStakes[address(msg.sender)]:
                                                _38337 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38337] = 26
                                                mem[_38337 + 32] = 'SafeMath: division by zero'
                                                if s < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41173 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41174 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41174 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _42980 = mem[_41174]
                                                    mem[_41173 + 132 len floor32(mem[_41174])] = mem[_41174 + 32 len floor32(mem[_41174])]
                                                    mem[_41173 + floor32(mem[_41174]) + -(mem[_41174] % 32) + 164 len mem[_41174] % 32] = mem[_41174 + -(mem[_41174] % 32) + floor32(mem[_41174]) + 64 len mem[_41174] % 32]
                                                    call stakingTokenAddress.mem[_41173 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41173 + 136 len _42980 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41173 + 242 len 22]
                                                    else:
                                                        mem[_41173 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41173 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41173 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41463 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41464 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41464 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43550 = mem[_41464]
                                                    mem[_41463 + 132 len floor32(mem[_41464])] = mem[_41464 + 32 len floor32(mem[_41464])]
                                                    mem[_41463 + floor32(mem[_41464]) + -(mem[_41464] % 32) + 164 len mem[_41464] % 32] = mem[_41464 + -(mem[_41464] % 32) + floor32(mem[_41464]) + 64 len mem[_41464] % 32]
                                                    call stakingTokenAddress.mem[_41463 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41463 + 136 len _43550 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41463 + 242 len 22]
                                                    else:
                                                        mem[_41463 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41463 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41463 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored - t:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _38827 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38827] = 26
                                                mem[_38827 + 32] = 'SafeMath: division by zero'
                                                if s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41791 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41792 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41792 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44180 = mem[_41792]
                                                    mem[_41791 + 132 len floor32(mem[_41792])] = mem[_41792 + 32 len floor32(mem[_41792])]
                                                    mem[_41791 + floor32(mem[_41792]) + -(mem[_41792] % 32) + 164 len mem[_41792] % 32] = mem[_41792 + -(mem[_41792] % 32) + floor32(mem[_41792]) + 64 len mem[_41792] % 32]
                                                    call stakingTokenAddress.mem[_41791 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41791 + 136 len _44180 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41791 + 242 len 22]
                                                    else:
                                                        mem[_41791 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41791 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41791 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _42109 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _42110 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_42110 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44840 = mem[_42110]
                                                    mem[_42109 + 132 len floor32(mem[_42110])] = mem[_42110 + 32 len floor32(mem[_42110])]
                                                    mem[_42109 + floor32(mem[_42110]) + -(mem[_42110] % 32) + 164 len mem[_42110] % 32] = mem[_42110 + -(mem[_42110] % 32) + floor32(mem[_42110]) + 64 len mem[_42110] % 32]
                                                    call stakingTokenAddress.mem[_42109 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_42109 + 136 len _44840 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42109 + 242 len 22]
                                                    else:
                                                        mem[_42109 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_42109 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42109 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    _32804 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32804] = 30
                                    mem[_32804 + 32] = 'SafeMath: subtraction overflow'
                                    if lastUpdateTime > periodFinish:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not periodFinish - lastUpdateTime:
                                        _33913 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33913] = 26
                                        mem[_33913 + 32] = 'SafeMath: division by zero'
                                        if not totalStakes:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _35415 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35415] = 30
                                        mem[_35415 + 32] = 'SafeMath: subtraction overflow'
                                        if t > (0 / totalStakes) + rewardPerTokenStored:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 17
                                        if not accountStakes[address(msg.sender)]:
                                            _37891 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37891] = 26
                                            mem[_37891 + 32] = 'SafeMath: division by zero'
                                            if s < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40725 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40726 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40726 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42139 = mem[_40726]
                                                mem[_40725 + 132 len floor32(mem[_40726])] = mem[_40726 + 32 len floor32(mem[_40726])]
                                                mem[_40725 + floor32(mem[_40726]) + -(mem[_40726] % 32) + 164 len mem[_40726] % 32] = mem[_40726 + -(mem[_40726] % 32) + floor32(mem[_40726]) + 64 len mem[_40726] % 32]
                                                call stakingTokenAddress.mem[_40725 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40725 + 136 len _42139 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40725 + 242 len 22]
                                                else:
                                                    mem[_40725 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40725 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40725 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40943 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40944 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40944 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42586 = mem[_40944]
                                                mem[_40943 + 132 len floor32(mem[_40944])] = mem[_40944 + 32 len floor32(mem[_40944])]
                                                mem[_40943 + floor32(mem[_40944]) + -(mem[_40944] % 32) + 164 len mem[_40944] % 32] = mem[_40944 + -(mem[_40944] % 32) + floor32(mem[_40944]) + 64 len mem[_40944] % 32]
                                                call stakingTokenAddress.mem[_40943 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40943 + 136 len _42586 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40943 + 242 len 22]
                                                else:
                                                    mem[_40943 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40943 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40943 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _38340 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38340] = 26
                                            mem[_38340 + 32] = 'SafeMath: division by zero'
                                            if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41188 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41189 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41189 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43010 = mem[_41189]
                                                mem[_41188 + 132 len floor32(mem[_41189])] = mem[_41189 + 32 len floor32(mem[_41189])]
                                                mem[_41188 + floor32(mem[_41189]) + -(mem[_41189] % 32) + 164 len mem[_41189] % 32] = mem[_41189 + -(mem[_41189] % 32) + floor32(mem[_41189]) + 64 len mem[_41189] % 32]
                                                call stakingTokenAddress.mem[_41188 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41188 + 136 len _43010 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41188 + 242 len 22]
                                                else:
                                                    mem[_41188 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41188 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41188 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41482 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41483 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41483 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43584 = mem[_41483]
                                                mem[_41482 + 132 len floor32(mem[_41483])] = mem[_41483 + 32 len floor32(mem[_41483])]
                                                mem[_41482 + floor32(mem[_41483]) + -(mem[_41483] % 32) + 164 len mem[_41483] % 32] = mem[_41483 + -(mem[_41483] % 32) + floor32(mem[_41483]) + 64 len mem[_41483] % 32]
                                                call stakingTokenAddress.mem[_41482 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41482 + 136 len _43584 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41482 + 242 len 22]
                                                else:
                                                    mem[_41482 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41482 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41482 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        if (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) / periodFinish - lastUpdateTime != rewardRate:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not (periodFinish * rewardRate) - (lastUpdateTime * rewardRate):
                                            _34044 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34044] = 26
                                            mem[_34044 + 32] = 'SafeMath: division by zero'
                                            if not totalStakes:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _35735 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35735] = 30
                                            mem[_35735 + 32] = 'SafeMath: subtraction overflow'
                                            if t > (0 / totalStakes) + rewardPerTokenStored:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 17
                                            if not accountStakes[address(msg.sender)]:
                                                _38339 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38339] = 26
                                                mem[_38339 + 32] = 'SafeMath: division by zero'
                                                if s < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41183 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41184 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41184 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43004 = mem[_41184]
                                                    mem[_41183 + 132 len floor32(mem[_41184])] = mem[_41184 + 32 len floor32(mem[_41184])]
                                                    mem[_41183 + floor32(mem[_41184]) + -(mem[_41184] % 32) + 164 len mem[_41184] % 32] = mem[_41184 + -(mem[_41184] % 32) + floor32(mem[_41184]) + 64 len mem[_41184] % 32]
                                                    call stakingTokenAddress.mem[_41183 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41183 + 136 len _43004 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41183 + 242 len 22]
                                                    else:
                                                        mem[_41183 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41183 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41183 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41479 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41480 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41480 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43578 = mem[_41480]
                                                    mem[_41479 + 132 len floor32(mem[_41480])] = mem[_41480 + 32 len floor32(mem[_41480])]
                                                    mem[_41479 + floor32(mem[_41480]) + -(mem[_41480] % 32) + 164 len mem[_41480] % 32] = mem[_41480 + -(mem[_41480] % 32) + floor32(mem[_41480]) + 64 len mem[_41480] % 32]
                                                    call stakingTokenAddress.mem[_41479 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41479 + 136 len _43578 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41479 + 242 len 22]
                                                    else:
                                                        mem[_41479 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41479 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41479 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _38829 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38829] = 26
                                                mem[_38829 + 32] = 'SafeMath: division by zero'
                                                if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41807 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41808 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41808 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44210 = mem[_41808]
                                                    mem[_41807 + 132 len floor32(mem[_41808])] = mem[_41808 + 32 len floor32(mem[_41808])]
                                                    mem[_41807 + floor32(mem[_41808]) + -(mem[_41808] % 32) + 164 len mem[_41808] % 32] = mem[_41808 + -(mem[_41808] % 32) + floor32(mem[_41808]) + 64 len mem[_41808] % 32]
                                                    call stakingTokenAddress.mem[_41807 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41807 + 136 len _44210 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41807 + 242 len 22]
                                                    else:
                                                        mem[_41807 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41807 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41807 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _42133 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _42134 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_42134 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44878 = mem[_42134]
                                                    mem[_42133 + 132 len floor32(mem[_42134])] = mem[_42134 + 32 len floor32(mem[_42134])]
                                                    mem[_42133 + floor32(mem[_42134]) + -(mem[_42134] % 32) + 164 len mem[_42134] % 32] = mem[_42134 + -(mem[_42134] % 32) + floor32(mem[_42134]) + 64 len mem[_42134] % 32]
                                                    call stakingTokenAddress.mem[_42133 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_42133 + 136 len _44878 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42133 + 242 len 22]
                                                    else:
                                                        mem[_42133 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_42133 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42133 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _34204 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34204] = 26
                                            mem[_34204 + 32] = 'SafeMath: division by zero'
                                            if not totalStakes:
                                                revert with 0, 'SafeMath: division by zero'
                                            if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _36230 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36230] = 30
                                            mem[_36230 + 32] = 'SafeMath: subtraction overflow'
                                            if t > ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 17
                                            if not accountStakes[address(msg.sender)]:
                                                _38828 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38828] = 26
                                                mem[_38828 + 32] = 'SafeMath: division by zero'
                                                if s < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41802 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41803 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41803 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44204 = mem[_41803]
                                                    mem[_41802 + 132 len floor32(mem[_41803])] = mem[_41803 + 32 len floor32(mem[_41803])]
                                                    mem[_41802 + floor32(mem[_41803]) + -(mem[_41803] % 32) + 164 len mem[_41803] % 32] = mem[_41803 + -(mem[_41803] % 32) + floor32(mem[_41803]) + 64 len mem[_41803] % 32]
                                                    call stakingTokenAddress.mem[_41802 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41802 + 136 len _44204 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41802 + 242 len 22]
                                                    else:
                                                        mem[_41802 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41802 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41802 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _42130 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _42131 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_42131 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44872 = mem[_42131]
                                                    mem[_42130 + 132 len floor32(mem[_42131])] = mem[_42131 + 32 len floor32(mem[_42131])]
                                                    mem[_42130 + floor32(mem[_42131]) + -(mem[_42131] % 32) + 164 len mem[_42131] % 32] = mem[_42131 + -(mem[_42131] % 32) + floor32(mem[_42131]) + 64 len mem[_42131] % 32]
                                                    call stakingTokenAddress.mem[_42130 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_42130 + 136 len _44872 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42130 + 242 len 22]
                                                    else:
                                                        mem[_42130 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_42130 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42130 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored - t:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _39439 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39439] = 26
                                                mem[_39439 + 32] = 'SafeMath: division by zero'
                                                if s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _42578 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _42579 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_42579 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _45692 = mem[_42579]
                                                    mem[_42578 + 132 len floor32(mem[_42579])] = mem[_42579 + 32 len floor32(mem[_42579])]
                                                    mem[_42578 + floor32(mem[_42579]) + -(mem[_42579] % 32) + 164 len mem[_42579] % 32] = mem[_42579 + -(mem[_42579] % 32) + floor32(mem[_42579]) + 64 len mem[_42579] % 32]
                                                    call stakingTokenAddress.mem[_42578 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_42578 + 136 len _45692 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42578 + 242 len 22]
                                                    else:
                                                        mem[_42578 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_42578 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42578 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _42998 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _42999 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_42999 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _46439 = mem[_42999]
                                                    mem[_42998 + 132 len floor32(mem[_42999])] = mem[_42999 + 32 len floor32(mem[_42999])]
                                                    mem[_42998 + floor32(mem[_42999]) + -(mem[_42999] % 32) + 164 len mem[_42999] % 32] = mem[_42999 + -(mem[_42999] % 32) + floor32(mem[_42999]) + 64 len mem[_42999] % 32]
                                                    call stakingTokenAddress.mem[_42998 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_42998 + 136 len _46439 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42998 + 242 len 22]
                                                    else:
                                                        mem[_42998 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_42998 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42998 + ceil32(return_data.size) + 243 len 22]
                    else:
                        lastUpdateTime = periodFinish
                        if not msg.sender:
                            if arg1 <= 0:
                                revert with 0, 'staking 0'
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                revert with 0, 'SafeERC20: call to non-contract'
                            if not ext_code.hash(stakingTokenAddress):
                                revert with 0, 'SafeERC20: call to non-contract'
                            mem[356 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg1) >> 32
                            mem[480 len 4] = uint32(arg1)
                            call stakingTokenAddress with:
                                 gas gas_remaining wei
                                args Mask(224, 32, arg1) << 480, mem[452 len 4]
                            if not return_data.size:
                                require not ext_call.success
                                revert with 0, 'SafeERC20: low-level call failed'
                            mem[388 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[388]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[ceil32(return_data.size) + 467 len 22]
                        else:
                            mem[224] = 0
                            mem[256] = 0
                            mem[288] = 0
                            mem[320] = 0
                            mem[0] = msg.sender
                            mem[32] = 16
                            mem[64] = 480
                            mem[352] = sub_183ddbfb[address(msg.sender)].field_0
                            mem[384] = sub_183ddbfb[address(msg.sender)].field_256
                            mem[416] = sub_183ddbfb[address(msg.sender)].field_512
                            mem[448] = sub_183ddbfb[address(msg.sender)].field_768
                            idx = sub_183ddbfb[address(msg.sender)].field_768
                            s = sub_183ddbfb[address(msg.sender)].field_512
                            t = sub_183ddbfb[address(msg.sender)].field_256
                            while idx < sub_e7690c44:
                                require idx < sub_155b0a71.length
                                mem[0] = 15
                                if not t:
                                    _32444 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32444] = 26
                                    mem[_32444 + 32] = 'SafeMath: division by zero'
                                    require idx < sub_155b0a71.length
                                    mem[0] = 15
                                    if not s:
                                        _33686 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33686] = 26
                                        mem[_33686 + 32] = 'SafeMath: division by zero'
                                        idx = idx + 1
                                        s = 0
                                        t = 0
                                        continue 
                                    if sub_155b0a71[idx] * s / s != sub_155b0a71[idx]:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _33770 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33770] = 26
                                    mem[_33770 + 32] = 'SafeMath: division by zero'
                                    idx = idx + 1
                                    s = sub_155b0a71[idx] * s / 10^18
                                    t = 0
                                    continue 
                                if sub_155b0a71[idx] * t / t != sub_155b0a71[idx]:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _32560 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32560] = 26
                                mem[_32560 + 32] = 'SafeMath: division by zero'
                                require idx < sub_155b0a71.length
                                mem[0] = 15
                                if not s:
                                    _33769 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33769] = 26
                                    mem[_33769 + 32] = 'SafeMath: division by zero'
                                    idx = idx + 1
                                    s = 0
                                    t = sub_155b0a71[idx] * t / 10^18
                                    continue 
                                if sub_155b0a71[idx] * s / s != sub_155b0a71[idx]:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _33814 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33814] = 26
                                mem[_33814 + 32] = 'SafeMath: division by zero'
                                idx = idx + 1
                                s = sub_155b0a71[idx] * s / 10^18
                                t = sub_155b0a71[idx] * t / 10^18
                                continue 
                            if 0 == totalStakes:
                                _32372 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32372] = 30
                                mem[_32372 + 32] = 'SafeMath: subtraction overflow'
                                if t > rewardPerTokenStored:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 17
                                if not accountStakes[address(msg.sender)]:
                                    _33317 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33317] = 26
                                    mem[_33317 + 32] = 'SafeMath: division by zero'
                                    if s < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_183ddbfb[address(msg.sender)].field_512 = s
                                    sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                    sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                    if sub_183ddbfb[address(msg.sender)].field_0:
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _34374 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _34375 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_34375 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _35000 = mem[_34375]
                                        mem[_34374 + 132 len floor32(mem[_34375])] = mem[_34375 + 32 len floor32(mem[_34375])]
                                        mem[_34374 + floor32(mem[_34375]) + -(mem[_34375] % 32) + 164 len mem[_34375] % 32] = mem[_34375 + -(mem[_34375] % 32) + floor32(mem[_34375]) + 64 len mem[_34375] % 32]
                                        call stakingTokenAddress.mem[_34374 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_34374 + 136 len _35000 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34374 + 242 len 22]
                                        else:
                                            mem[_34374 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_34374 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34374 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _34522 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _34523 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_34523 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _35138 = mem[_34523]
                                        mem[_34522 + 132 len floor32(mem[_34523])] = mem[_34523 + 32 len floor32(mem[_34523])]
                                        mem[_34522 + floor32(mem[_34523]) + -(mem[_34523] % 32) + 164 len mem[_34523] % 32] = mem[_34523 + -(mem[_34523] % 32) + floor32(mem[_34523]) + 64 len mem[_34523] % 32]
                                        call stakingTokenAddress.mem[_34522 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_34522 + 136 len _35138 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34522 + 242 len 22]
                                        else:
                                            mem[_34522 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_34522 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34522 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    if (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != rewardPerTokenStored - t:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _33578 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33578] = 26
                                    mem[_33578 + 32] = 'SafeMath: division by zero'
                                    if s + ((rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_183ddbfb[address(msg.sender)].field_512 = s + ((rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                    sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                    sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                    if sub_183ddbfb[address(msg.sender)].field_0:
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _34696 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _34697 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_34697 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _35252 = mem[_34697]
                                        mem[_34696 + 132 len floor32(mem[_34697])] = mem[_34697 + 32 len floor32(mem[_34697])]
                                        mem[_34696 + floor32(mem[_34697]) + -(mem[_34697] % 32) + 164 len mem[_34697] % 32] = mem[_34697 + -(mem[_34697] % 32) + floor32(mem[_34697]) + 64 len mem[_34697] % 32]
                                        call stakingTokenAddress.mem[_34696 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_34696 + 136 len _35252 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34696 + 242 len 22]
                                        else:
                                            mem[_34696 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_34696 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34696 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _34828 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _34829 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_34829 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _35435 = mem[_34829]
                                        mem[_34828 + 132 len floor32(mem[_34829])] = mem[_34829 + 32 len floor32(mem[_34829])]
                                        mem[_34828 + floor32(mem[_34829]) + -(mem[_34829] % 32) + 164 len mem[_34829] % 32] = mem[_34829 + -(mem[_34829] % 32) + floor32(mem[_34829]) + 64 len mem[_34829] % 32]
                                        call stakingTokenAddress.mem[_34828 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_34828 + 136 len _35435 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34828 + 242 len 22]
                                        else:
                                            mem[_34828 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_34828 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34828 + ceil32(return_data.size) + 243 len 22]
                            else:
                                if block.timestamp < periodFinish:
                                    _32630 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32630] = 30
                                    mem[_32630 + 32] = 'SafeMath: subtraction overflow'
                                    if lastUpdateTime > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not block.timestamp - lastUpdateTime:
                                        _33834 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33834] = 26
                                        mem[_33834 + 32] = 'SafeMath: division by zero'
                                        if not totalStakes:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _35134 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35134] = 30
                                        mem[_35134 + 32] = 'SafeMath: subtraction overflow'
                                        if t > (0 / totalStakes) + rewardPerTokenStored:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 17
                                        if not accountStakes[address(msg.sender)]:
                                            _37428 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37428] = 26
                                            mem[_37428 + 32] = 'SafeMath: division by zero'
                                            if s < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40476 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40477 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40477 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _41496 = mem[_40477]
                                                mem[_40476 + 132 len floor32(mem[_40477])] = mem[_40477 + 32 len floor32(mem[_40477])]
                                                mem[_40476 + floor32(mem[_40477]) + -(mem[_40477] % 32) + 164 len mem[_40477] % 32] = mem[_40477 + -(mem[_40477] % 32) + floor32(mem[_40477]) + 64 len mem[_40477] % 32]
                                                call stakingTokenAddress.mem[_40476 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40476 + 136 len _41496 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40476 + 242 len 22]
                                                else:
                                                    mem[_40476 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40476 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40476 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40568 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40569 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40569 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _41820 = mem[_40569]
                                                mem[_40568 + 132 len floor32(mem[_40569])] = mem[_40569 + 32 len floor32(mem[_40569])]
                                                mem[_40568 + floor32(mem[_40569]) + -(mem[_40569] % 32) + 164 len mem[_40569] % 32] = mem[_40569 + -(mem[_40569] % 32) + floor32(mem[_40569]) + 64 len mem[_40569] % 32]
                                                call stakingTokenAddress.mem[_40568 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40568 + 136 len _41820 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40568 + 242 len 22]
                                                else:
                                                    mem[_40568 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40568 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40568 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _37903 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37903] = 26
                                            mem[_37903 + 32] = 'SafeMath: division by zero'
                                            if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40735 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40736 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40736 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42154 = mem[_40736]
                                                mem[_40735 + 132 len floor32(mem[_40736])] = mem[_40736 + 32 len floor32(mem[_40736])]
                                                mem[_40735 + floor32(mem[_40736]) + -(mem[_40736] % 32) + 164 len mem[_40736] % 32] = mem[_40736 + -(mem[_40736] % 32) + floor32(mem[_40736]) + 64 len mem[_40736] % 32]
                                                call stakingTokenAddress.mem[_40735 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40735 + 136 len _42154 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40735 + 242 len 22]
                                                else:
                                                    mem[_40735 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40735 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40735 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40953 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40954 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40954 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42598 = mem[_40954]
                                                mem[_40953 + 132 len floor32(mem[_40954])] = mem[_40954 + 32 len floor32(mem[_40954])]
                                                mem[_40953 + floor32(mem[_40954]) + -(mem[_40954] % 32) + 164 len mem[_40954] % 32] = mem[_40954 + -(mem[_40954] % 32) + floor32(mem[_40954]) + 64 len mem[_40954] % 32]
                                                call stakingTokenAddress.mem[_40953 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40953 + 136 len _42598 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40953 + 242 len 22]
                                                else:
                                                    mem[_40953 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40953 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40953 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        if (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) / block.timestamp - lastUpdateTime != rewardRate:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate):
                                            _33916 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33916] = 26
                                            mem[_33916 + 32] = 'SafeMath: division by zero'
                                            if not totalStakes:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _35427 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35427] = 30
                                            mem[_35427 + 32] = 'SafeMath: subtraction overflow'
                                            if t > (0 / totalStakes) + rewardPerTokenStored:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 17
                                            if not accountStakes[address(msg.sender)]:
                                                _37902 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37902] = 26
                                                mem[_37902 + 32] = 'SafeMath: division by zero'
                                                if s < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _40730 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _40731 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_40731 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _42148 = mem[_40731]
                                                    mem[_40730 + 132 len floor32(mem[_40731])] = mem[_40731 + 32 len floor32(mem[_40731])]
                                                    mem[_40730 + floor32(mem[_40731]) + -(mem[_40731] % 32) + 164 len mem[_40731] % 32] = mem[_40731 + -(mem[_40731] % 32) + floor32(mem[_40731]) + 64 len mem[_40731] % 32]
                                                    call stakingTokenAddress.mem[_40730 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_40730 + 136 len _42148 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_40730 + 242 len 22]
                                                    else:
                                                        mem[_40730 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_40730 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_40730 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _40950 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _40951 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_40951 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _42592 = mem[_40951]
                                                    mem[_40950 + 132 len floor32(mem[_40951])] = mem[_40951 + 32 len floor32(mem[_40951])]
                                                    mem[_40950 + floor32(mem[_40951]) + -(mem[_40951] % 32) + 164 len mem[_40951] % 32] = mem[_40951 + -(mem[_40951] % 32) + floor32(mem[_40951]) + 64 len mem[_40951] % 32]
                                                    call stakingTokenAddress.mem[_40950 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_40950 + 136 len _42592 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_40950 + 242 len 22]
                                                    else:
                                                        mem[_40950 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_40950 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_40950 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _38354 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38354] = 26
                                                mem[_38354 + 32] = 'SafeMath: division by zero'
                                                if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41198 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41199 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41199 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43026 = mem[_41199]
                                                    mem[_41198 + 132 len floor32(mem[_41199])] = mem[_41199 + 32 len floor32(mem[_41199])]
                                                    mem[_41198 + floor32(mem[_41199]) + -(mem[_41199] % 32) + 164 len mem[_41199] % 32] = mem[_41199 + -(mem[_41199] % 32) + floor32(mem[_41199]) + 64 len mem[_41199] % 32]
                                                    call stakingTokenAddress.mem[_41198 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41198 + 136 len _43026 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41198 + 242 len 22]
                                                    else:
                                                        mem[_41198 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41198 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41198 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41490 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41491 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41491 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43601 = mem[_41491]
                                                    mem[_41490 + 132 len floor32(mem[_41491])] = mem[_41491 + 32 len floor32(mem[_41491])]
                                                    mem[_41490 + floor32(mem[_41491]) + -(mem[_41491] % 32) + 164 len mem[_41491] % 32] = mem[_41491 + -(mem[_41491] % 32) + floor32(mem[_41491]) + 64 len mem[_41491] % 32]
                                                    call stakingTokenAddress.mem[_41490 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41490 + 136 len _43601 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41490 + 242 len 22]
                                                    else:
                                                        mem[_41490 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41490 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41490 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _34048 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34048] = 26
                                            mem[_34048 + 32] = 'SafeMath: division by zero'
                                            if not totalStakes:
                                                revert with 0, 'SafeMath: division by zero'
                                            if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _35750 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35750] = 30
                                            mem[_35750 + 32] = 'SafeMath: subtraction overflow'
                                            if t > ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 17
                                            if not accountStakes[address(msg.sender)]:
                                                _38353 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38353] = 26
                                                mem[_38353 + 32] = 'SafeMath: division by zero'
                                                if s < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41193 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41194 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41194 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43020 = mem[_41194]
                                                    mem[_41193 + 132 len floor32(mem[_41194])] = mem[_41194 + 32 len floor32(mem[_41194])]
                                                    mem[_41193 + floor32(mem[_41194]) + -(mem[_41194] % 32) + 164 len mem[_41194] % 32] = mem[_41194 + -(mem[_41194] % 32) + floor32(mem[_41194]) + 64 len mem[_41194] % 32]
                                                    call stakingTokenAddress.mem[_41193 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41193 + 136 len _43020 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41193 + 242 len 22]
                                                    else:
                                                        mem[_41193 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41193 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41193 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41487 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41488 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41488 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43595 = mem[_41488]
                                                    mem[_41487 + 132 len floor32(mem[_41488])] = mem[_41488 + 32 len floor32(mem[_41488])]
                                                    mem[_41487 + floor32(mem[_41488]) + -(mem[_41488] % 32) + 164 len mem[_41488] % 32] = mem[_41488 + -(mem[_41488] % 32) + floor32(mem[_41488]) + 64 len mem[_41488] % 32]
                                                    call stakingTokenAddress.mem[_41487 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41487 + 136 len _43595 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41487 + 242 len 22]
                                                    else:
                                                        mem[_41487 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41487 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41487 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored - t:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _38850 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38850] = 26
                                                mem[_38850 + 32] = 'SafeMath: division by zero'
                                                if s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41812 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41813 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41813 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44225 = mem[_41813]
                                                    mem[_41812 + 132 len floor32(mem[_41813])] = mem[_41813 + 32 len floor32(mem[_41813])]
                                                    mem[_41812 + floor32(mem[_41813]) + -(mem[_41813] % 32) + 164 len mem[_41813] % 32] = mem[_41813 + -(mem[_41813] % 32) + floor32(mem[_41813]) + 64 len mem[_41813] % 32]
                                                    call stakingTokenAddress.mem[_41812 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41812 + 136 len _44225 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41812 + 242 len 22]
                                                    else:
                                                        mem[_41812 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41812 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41812 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _42142 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _42143 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_42143 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44900 = mem[_42143]
                                                    mem[_42142 + 132 len floor32(mem[_42143])] = mem[_42143 + 32 len floor32(mem[_42143])]
                                                    mem[_42142 + floor32(mem[_42143]) + -(mem[_42143] % 32) + 164 len mem[_42143] % 32] = mem[_42143 + -(mem[_42143] % 32) + floor32(mem[_42143]) + 64 len mem[_42143] % 32]
                                                    call stakingTokenAddress.mem[_42142 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_42142 + 136 len _44900 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42142 + 242 len 22]
                                                    else:
                                                        mem[_42142 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_42142 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42142 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    _32810 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32810] = 30
                                    mem[_32810 + 32] = 'SafeMath: subtraction overflow'
                                    if lastUpdateTime > periodFinish:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not periodFinish - lastUpdateTime:
                                        _33920 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33920] = 26
                                        mem[_33920 + 32] = 'SafeMath: division by zero'
                                        if not totalStakes:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _35431 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35431] = 30
                                        mem[_35431 + 32] = 'SafeMath: subtraction overflow'
                                        if t > (0 / totalStakes) + rewardPerTokenStored:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 17
                                        if not accountStakes[address(msg.sender)]:
                                            _37906 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37906] = 26
                                            mem[_37906 + 32] = 'SafeMath: division by zero'
                                            if s < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40740 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40741 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40741 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42172 = mem[_40741]
                                                mem[_40740 + 132 len floor32(mem[_40741])] = mem[_40741 + 32 len floor32(mem[_40741])]
                                                mem[_40740 + floor32(mem[_40741]) + -(mem[_40741] % 32) + 164 len mem[_40741] % 32] = mem[_40741 + -(mem[_40741] % 32) + floor32(mem[_40741]) + 64 len mem[_40741] % 32]
                                                call stakingTokenAddress.mem[_40740 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40740 + 136 len _42172 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40740 + 242 len 22]
                                                else:
                                                    mem[_40740 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40740 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40740 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40960 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40961 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40961 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42614 = mem[_40961]
                                                mem[_40960 + 132 len floor32(mem[_40961])] = mem[_40961 + 32 len floor32(mem[_40961])]
                                                mem[_40960 + floor32(mem[_40961]) + -(mem[_40961] % 32) + 164 len mem[_40961] % 32] = mem[_40961 + -(mem[_40961] % 32) + floor32(mem[_40961]) + 64 len mem[_40961] % 32]
                                                call stakingTokenAddress.mem[_40960 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40960 + 136 len _42614 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40960 + 242 len 22]
                                                else:
                                                    mem[_40960 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40960 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40960 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _38356 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38356] = 26
                                            mem[_38356 + 32] = 'SafeMath: division by zero'
                                            if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41208 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41209 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41209 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43050 = mem[_41209]
                                                mem[_41208 + 132 len floor32(mem[_41209])] = mem[_41209 + 32 len floor32(mem[_41209])]
                                                mem[_41208 + floor32(mem[_41209]) + -(mem[_41209] % 32) + 164 len mem[_41209] % 32] = mem[_41209 + -(mem[_41209] % 32) + floor32(mem[_41209]) + 64 len mem[_41209] % 32]
                                                call stakingTokenAddress.mem[_41208 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41208 + 136 len _43050 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41208 + 242 len 22]
                                                else:
                                                    mem[_41208 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41208 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41208 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41506 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41507 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41507 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43629 = mem[_41507]
                                                mem[_41506 + 132 len floor32(mem[_41507])] = mem[_41507 + 32 len floor32(mem[_41507])]
                                                mem[_41506 + floor32(mem[_41507]) + -(mem[_41507] % 32) + 164 len mem[_41507] % 32] = mem[_41507 + -(mem[_41507] % 32) + floor32(mem[_41507]) + 64 len mem[_41507] % 32]
                                                call stakingTokenAddress.mem[_41506 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41506 + 136 len _43629 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41506 + 242 len 22]
                                                else:
                                                    mem[_41506 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41506 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41506 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        if (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) / periodFinish - lastUpdateTime != rewardRate:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not (periodFinish * rewardRate) - (lastUpdateTime * rewardRate):
                                            _34053 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34053] = 26
                                            mem[_34053 + 32] = 'SafeMath: division by zero'
                                            if not totalStakes:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _35756 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35756] = 30
                                            mem[_35756 + 32] = 'SafeMath: subtraction overflow'
                                            if t > (0 / totalStakes) + rewardPerTokenStored:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 17
                                            if not accountStakes[address(msg.sender)]:
                                                _38355 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38355] = 26
                                                mem[_38355 + 32] = 'SafeMath: division by zero'
                                                if s < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41203 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41204 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41204 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43044 = mem[_41204]
                                                    mem[_41203 + 132 len floor32(mem[_41204])] = mem[_41204 + 32 len floor32(mem[_41204])]
                                                    mem[_41203 + floor32(mem[_41204]) + -(mem[_41204] % 32) + 164 len mem[_41204] % 32] = mem[_41204 + -(mem[_41204] % 32) + floor32(mem[_41204]) + 64 len mem[_41204] % 32]
                                                    call stakingTokenAddress.mem[_41203 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41203 + 136 len _43044 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41203 + 242 len 22]
                                                    else:
                                                        mem[_41203 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41203 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41203 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41503 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41504 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41504 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43623 = mem[_41504]
                                                    mem[_41503 + 132 len floor32(mem[_41504])] = mem[_41504 + 32 len floor32(mem[_41504])]
                                                    mem[_41503 + floor32(mem[_41504]) + -(mem[_41504] % 32) + 164 len mem[_41504] % 32] = mem[_41504 + -(mem[_41504] % 32) + floor32(mem[_41504]) + 64 len mem[_41504] % 32]
                                                    call stakingTokenAddress.mem[_41503 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41503 + 136 len _43623 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41503 + 242 len 22]
                                                    else:
                                                        mem[_41503 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41503 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41503 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _38852 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38852] = 26
                                                mem[_38852 + 32] = 'SafeMath: division by zero'
                                                if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41828 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41829 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41829 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44255 = mem[_41829]
                                                    mem[_41828 + 132 len floor32(mem[_41829])] = mem[_41829 + 32 len floor32(mem[_41829])]
                                                    mem[_41828 + floor32(mem[_41829]) + -(mem[_41829] % 32) + 164 len mem[_41829] % 32] = mem[_41829 + -(mem[_41829] % 32) + floor32(mem[_41829]) + 64 len mem[_41829] % 32]
                                                    call stakingTokenAddress.mem[_41828 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41828 + 136 len _44255 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41828 + 242 len 22]
                                                    else:
                                                        mem[_41828 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41828 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41828 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _42166 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _42167 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_42167 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44938 = mem[_42167]
                                                    mem[_42166 + 132 len floor32(mem[_42167])] = mem[_42167 + 32 len floor32(mem[_42167])]
                                                    mem[_42166 + floor32(mem[_42167]) + -(mem[_42167] % 32) + 164 len mem[_42167] % 32] = mem[_42167 + -(mem[_42167] % 32) + floor32(mem[_42167]) + 64 len mem[_42167] % 32]
                                                    call stakingTokenAddress.mem[_42166 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_42166 + 136 len _44938 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42166 + 242 len 22]
                                                    else:
                                                        mem[_42166 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_42166 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42166 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _34216 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34216] = 26
                                            mem[_34216 + 32] = 'SafeMath: division by zero'
                                            if not totalStakes:
                                                revert with 0, 'SafeMath: division by zero'
                                            if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _36253 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36253] = 30
                                            mem[_36253 + 32] = 'SafeMath: subtraction overflow'
                                            if t > ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 17
                                            if not accountStakes[address(msg.sender)]:
                                                _38851 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38851] = 26
                                                mem[_38851 + 32] = 'SafeMath: division by zero'
                                                if s < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41823 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41824 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41824 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44249 = mem[_41824]
                                                    mem[_41823 + 132 len floor32(mem[_41824])] = mem[_41824 + 32 len floor32(mem[_41824])]
                                                    mem[_41823 + floor32(mem[_41824]) + -(mem[_41824] % 32) + 164 len mem[_41824] % 32] = mem[_41824 + -(mem[_41824] % 32) + floor32(mem[_41824]) + 64 len mem[_41824] % 32]
                                                    call stakingTokenAddress.mem[_41823 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41823 + 136 len _44249 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41823 + 242 len 22]
                                                    else:
                                                        mem[_41823 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41823 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41823 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _42163 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _42164 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_42164 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44932 = mem[_42164]
                                                    mem[_42163 + 132 len floor32(mem[_42164])] = mem[_42164 + 32 len floor32(mem[_42164])]
                                                    mem[_42163 + floor32(mem[_42164]) + -(mem[_42164] % 32) + 164 len mem[_42164] % 32] = mem[_42164 + -(mem[_42164] % 32) + floor32(mem[_42164]) + 64 len mem[_42164] % 32]
                                                    call stakingTokenAddress.mem[_42163 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_42163 + 136 len _44932 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42163 + 242 len 22]
                                                    else:
                                                        mem[_42163 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_42163 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42163 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored - t:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _39466 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39466] = 26
                                                mem[_39466 + 32] = 'SafeMath: division by zero'
                                                if s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _42606 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _42607 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_42607 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _45744 = mem[_42607]
                                                    mem[_42606 + 132 len floor32(mem[_42607])] = mem[_42607 + 32 len floor32(mem[_42607])]
                                                    mem[_42606 + floor32(mem[_42607]) + -(mem[_42607] % 32) + 164 len mem[_42607] % 32] = mem[_42607 + -(mem[_42607] % 32) + floor32(mem[_42607]) + 64 len mem[_42607] % 32]
                                                    call stakingTokenAddress.mem[_42606 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_42606 + 136 len _45744 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42606 + 242 len 22]
                                                    else:
                                                        mem[_42606 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_42606 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42606 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _43038 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _43039 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_43039 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _46500 = mem[_43039]
                                                    mem[_43038 + 132 len floor32(mem[_43039])] = mem[_43039 + 32 len floor32(mem[_43039])]
                                                    mem[_43038 + floor32(mem[_43039]) + -(mem[_43039] % 32) + 164 len mem[_43039] % 32] = mem[_43039 + -(mem[_43039] % 32) + floor32(mem[_43039]) + 64 len mem[_43039] % 32]
                                                    call stakingTokenAddress.mem[_43038 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_43038 + 136 len _46500 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_43038 + 242 len 22]
                                                    else:
                                                        mem[_43038 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_43038 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_43038 + ceil32(return_data.size) + 243 len 22]
                else:
                    if (10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                    mem[160] = 26
                    mem[192] = 'SafeMath: division by zero'
                    if not totalStakes:
                        revert with 0, 'SafeMath: division by zero'
                    if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                        revert with 0, 'SafeMath: addition overflow'
                    rewardPerTokenStored += (10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes
                    if block.timestamp < periodFinish:
                        lastUpdateTime = block.timestamp
                        if not msg.sender:
                            if arg1 <= 0:
                                revert with 0, 'staking 0'
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                revert with 0, 'SafeERC20: call to non-contract'
                            if not ext_code.hash(stakingTokenAddress):
                                revert with 0, 'SafeERC20: call to non-contract'
                            mem[356 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg1) >> 32
                            mem[480 len 4] = uint32(arg1)
                            call stakingTokenAddress with:
                                 gas gas_remaining wei
                                args Mask(224, 32, arg1) << 480, mem[452 len 4]
                            if not return_data.size:
                                require not ext_call.success
                                revert with 0, 'SafeERC20: low-level call failed'
                            mem[388 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[388]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[ceil32(return_data.size) + 467 len 22]
                        else:
                            mem[224] = 0
                            mem[256] = 0
                            mem[288] = 0
                            mem[320] = 0
                            mem[0] = msg.sender
                            mem[32] = 16
                            mem[64] = 480
                            mem[352] = sub_183ddbfb[address(msg.sender)].field_0
                            mem[384] = sub_183ddbfb[address(msg.sender)].field_256
                            mem[416] = sub_183ddbfb[address(msg.sender)].field_512
                            mem[448] = sub_183ddbfb[address(msg.sender)].field_768
                            idx = sub_183ddbfb[address(msg.sender)].field_768
                            s = sub_183ddbfb[address(msg.sender)].field_512
                            t = sub_183ddbfb[address(msg.sender)].field_256
                            while idx < sub_e7690c44:
                                require idx < sub_155b0a71.length
                                mem[0] = 15
                                if not t:
                                    _32429 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32429] = 26
                                    mem[_32429 + 32] = 'SafeMath: division by zero'
                                    require idx < sub_155b0a71.length
                                    mem[0] = 15
                                    if not s:
                                        _33674 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33674] = 26
                                        mem[_33674 + 32] = 'SafeMath: division by zero'
                                        idx = idx + 1
                                        s = 0
                                        t = 0
                                        continue 
                                    if sub_155b0a71[idx] * s / s != sub_155b0a71[idx]:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _33758 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33758] = 26
                                    mem[_33758 + 32] = 'SafeMath: division by zero'
                                    idx = idx + 1
                                    s = sub_155b0a71[idx] * s / 10^18
                                    t = 0
                                    continue 
                                if sub_155b0a71[idx] * t / t != sub_155b0a71[idx]:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _32542 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32542] = 26
                                mem[_32542 + 32] = 'SafeMath: division by zero'
                                require idx < sub_155b0a71.length
                                mem[0] = 15
                                if not s:
                                    _33757 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33757] = 26
                                    mem[_33757 + 32] = 'SafeMath: division by zero'
                                    idx = idx + 1
                                    s = 0
                                    t = sub_155b0a71[idx] * t / 10^18
                                    continue 
                                if sub_155b0a71[idx] * s / s != sub_155b0a71[idx]:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _33811 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33811] = 26
                                mem[_33811 + 32] = 'SafeMath: division by zero'
                                idx = idx + 1
                                s = sub_155b0a71[idx] * s / 10^18
                                t = sub_155b0a71[idx] * t / 10^18
                                continue 
                            if 0 == totalStakes:
                                _32357 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32357] = 30
                                mem[_32357 + 32] = 'SafeMath: subtraction overflow'
                                if t > rewardPerTokenStored:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 17
                                if not accountStakes[address(msg.sender)]:
                                    _33287 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33287] = 26
                                    mem[_33287 + 32] = 'SafeMath: division by zero'
                                    if s < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_183ddbfb[address(msg.sender)].field_512 = s
                                    sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                    sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                    if sub_183ddbfb[address(msg.sender)].field_0:
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _34347 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _34348 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_34348 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _34967 = mem[_34348]
                                        mem[_34347 + 132 len floor32(mem[_34348])] = mem[_34348 + 32 len floor32(mem[_34348])]
                                        mem[_34347 + floor32(mem[_34348]) + -(mem[_34348] % 32) + 164 len mem[_34348] % 32] = mem[_34348 + -(mem[_34348] % 32) + floor32(mem[_34348]) + 64 len mem[_34348] % 32]
                                        call stakingTokenAddress.mem[_34347 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_34347 + 136 len _34967 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34347 + 242 len 22]
                                        else:
                                            mem[_34347 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_34347 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34347 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _34480 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _34481 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_34481 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _35117 = mem[_34481]
                                        mem[_34480 + 132 len floor32(mem[_34481])] = mem[_34481 + 32 len floor32(mem[_34481])]
                                        mem[_34480 + floor32(mem[_34481]) + -(mem[_34481] % 32) + 164 len mem[_34481] % 32] = mem[_34481 + -(mem[_34481] % 32) + floor32(mem[_34481]) + 64 len mem[_34481] % 32]
                                        call stakingTokenAddress.mem[_34480 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_34480 + 136 len _35117 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34480 + 242 len 22]
                                        else:
                                            mem[_34480 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_34480 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34480 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    if (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != rewardPerTokenStored - t:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _33551 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33551] = 26
                                    mem[_33551 + 32] = 'SafeMath: division by zero'
                                    if s + ((rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_183ddbfb[address(msg.sender)].field_512 = s + ((rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                    sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                    sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                    if sub_183ddbfb[address(msg.sender)].field_0:
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _34669 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _34670 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_34670 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _35216 = mem[_34670]
                                        mem[_34669 + 132 len floor32(mem[_34670])] = mem[_34670 + 32 len floor32(mem[_34670])]
                                        mem[_34669 + floor32(mem[_34670]) + -(mem[_34670] % 32) + 164 len mem[_34670] % 32] = mem[_34670 + -(mem[_34670] % 32) + floor32(mem[_34670]) + 64 len mem[_34670] % 32]
                                        call stakingTokenAddress.mem[_34669 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_34669 + 136 len _35216 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34669 + 242 len 22]
                                        else:
                                            mem[_34669 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_34669 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34669 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _34798 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _34799 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_34799 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _35387 = mem[_34799]
                                        mem[_34798 + 132 len floor32(mem[_34799])] = mem[_34799 + 32 len floor32(mem[_34799])]
                                        mem[_34798 + floor32(mem[_34799]) + -(mem[_34799] % 32) + 164 len mem[_34799] % 32] = mem[_34799 + -(mem[_34799] % 32) + floor32(mem[_34799]) + 64 len mem[_34799] % 32]
                                        call stakingTokenAddress.mem[_34798 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_34798 + 136 len _35387 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34798 + 242 len 22]
                                        else:
                                            mem[_34798 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_34798 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34798 + ceil32(return_data.size) + 243 len 22]
                            else:
                                if block.timestamp < periodFinish:
                                    _32621 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32621] = 30
                                    mem[_32621 + 32] = 'SafeMath: subtraction overflow'
                                    if lastUpdateTime > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not block.timestamp - lastUpdateTime:
                                        _33825 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33825] = 26
                                        mem[_33825 + 32] = 'SafeMath: division by zero'
                                        if not totalStakes:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _35113 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35113] = 30
                                        mem[_35113 + 32] = 'SafeMath: subtraction overflow'
                                        if t > (0 / totalStakes) + rewardPerTokenStored:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 17
                                        if not accountStakes[address(msg.sender)]:
                                            _37383 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37383] = 26
                                            mem[_37383 + 32] = 'SafeMath: division by zero'
                                            if s < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40461 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40462 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40462 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _41424 = mem[_40462]
                                                mem[_40461 + 132 len floor32(mem[_40462])] = mem[_40462 + 32 len floor32(mem[_40462])]
                                                mem[_40461 + floor32(mem[_40462]) + -(mem[_40462] % 32) + 164 len mem[_40462] % 32] = mem[_40462 + -(mem[_40462] % 32) + floor32(mem[_40462]) + 64 len mem[_40462] % 32]
                                                call stakingTokenAddress.mem[_40461 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40461 + 136 len _41424 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40461 + 242 len 22]
                                                else:
                                                    mem[_40461 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40461 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40461 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40535 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40536 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40536 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _41757 = mem[_40536]
                                                mem[_40535 + 132 len floor32(mem[_40536])] = mem[_40536 + 32 len floor32(mem[_40536])]
                                                mem[_40535 + floor32(mem[_40536]) + -(mem[_40536] % 32) + 164 len mem[_40536] % 32] = mem[_40536 + -(mem[_40536] % 32) + floor32(mem[_40536]) + 64 len mem[_40536] % 32]
                                                call stakingTokenAddress.mem[_40535 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40535 + 136 len _41757 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40535 + 242 len 22]
                                                else:
                                                    mem[_40535 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40535 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40535 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _37858 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37858] = 26
                                            mem[_37858 + 32] = 'SafeMath: division by zero'
                                            if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40690 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40691 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40691 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42055 = mem[_40691]
                                                mem[_40690 + 132 len floor32(mem[_40691])] = mem[_40691 + 32 len floor32(mem[_40691])]
                                                mem[_40690 + floor32(mem[_40691]) + -(mem[_40691] % 32) + 164 len mem[_40691] % 32] = mem[_40691 + -(mem[_40691] % 32) + floor32(mem[_40691]) + 64 len mem[_40691] % 32]
                                                call stakingTokenAddress.mem[_40690 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40690 + 136 len _42055 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40690 + 242 len 22]
                                                else:
                                                    mem[_40690 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40690 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40690 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40902 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40903 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40903 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42514 = mem[_40903]
                                                mem[_40902 + 132 len floor32(mem[_40903])] = mem[_40903 + 32 len floor32(mem[_40903])]
                                                mem[_40902 + floor32(mem[_40903]) + -(mem[_40903] % 32) + 164 len mem[_40903] % 32] = mem[_40903 + -(mem[_40903] % 32) + floor32(mem[_40903]) + 64 len mem[_40903] % 32]
                                                call stakingTokenAddress.mem[_40902 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40902 + 136 len _42514 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40902 + 242 len 22]
                                                else:
                                                    mem[_40902 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40902 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40902 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        if (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) / block.timestamp - lastUpdateTime != rewardRate:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate):
                                            _33895 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33895] = 26
                                            mem[_33895 + 32] = 'SafeMath: division by zero'
                                            if not totalStakes:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _35379 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35379] = 30
                                            mem[_35379 + 32] = 'SafeMath: subtraction overflow'
                                            if t > (0 / totalStakes) + rewardPerTokenStored:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 17
                                            if not accountStakes[address(msg.sender)]:
                                                _37857 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37857] = 26
                                                mem[_37857 + 32] = 'SafeMath: division by zero'
                                                if s < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _40685 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _40686 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_40686 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _42049 = mem[_40686]
                                                    mem[_40685 + 132 len floor32(mem[_40686])] = mem[_40686 + 32 len floor32(mem[_40686])]
                                                    mem[_40685 + floor32(mem[_40686]) + -(mem[_40686] % 32) + 164 len mem[_40686] % 32] = mem[_40686 + -(mem[_40686] % 32) + floor32(mem[_40686]) + 64 len mem[_40686] % 32]
                                                    call stakingTokenAddress.mem[_40685 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_40685 + 136 len _42049 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_40685 + 242 len 22]
                                                    else:
                                                        mem[_40685 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_40685 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_40685 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _40899 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _40900 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_40900 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _42508 = mem[_40900]
                                                    mem[_40899 + 132 len floor32(mem[_40900])] = mem[_40900 + 32 len floor32(mem[_40900])]
                                                    mem[_40899 + floor32(mem[_40900]) + -(mem[_40900] % 32) + 164 len mem[_40900] % 32] = mem[_40900 + -(mem[_40900] % 32) + floor32(mem[_40900]) + 64 len mem[_40900] % 32]
                                                    call stakingTokenAddress.mem[_40899 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_40899 + 136 len _42508 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_40899 + 242 len 22]
                                                    else:
                                                        mem[_40899 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_40899 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_40899 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _38306 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38306] = 26
                                                mem[_38306 + 32] = 'SafeMath: division by zero'
                                                if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41138 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41139 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41139 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _42906 = mem[_41139]
                                                    mem[_41138 + 132 len floor32(mem[_41139])] = mem[_41139 + 32 len floor32(mem[_41139])]
                                                    mem[_41138 + floor32(mem[_41139]) + -(mem[_41139] % 32) + 164 len mem[_41139] % 32] = mem[_41139 + -(mem[_41139] % 32) + floor32(mem[_41139]) + 64 len mem[_41139] % 32]
                                                    call stakingTokenAddress.mem[_41138 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41138 + 136 len _42906 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41138 + 242 len 22]
                                                    else:
                                                        mem[_41138 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41138 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41138 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41418 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41419 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41419 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43466 = mem[_41419]
                                                    mem[_41418 + 132 len floor32(mem[_41419])] = mem[_41419 + 32 len floor32(mem[_41419])]
                                                    mem[_41418 + floor32(mem[_41419]) + -(mem[_41419] % 32) + 164 len mem[_41419] % 32] = mem[_41419 + -(mem[_41419] % 32) + floor32(mem[_41419]) + 64 len mem[_41419] % 32]
                                                    call stakingTokenAddress.mem[_41418 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41418 + 136 len _43466 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41418 + 242 len 22]
                                                    else:
                                                        mem[_41418 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41418 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41418 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _34021 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34021] = 26
                                            mem[_34021 + 32] = 'SafeMath: division by zero'
                                            if not totalStakes:
                                                revert with 0, 'SafeMath: division by zero'
                                            if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _35687 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35687] = 30
                                            mem[_35687 + 32] = 'SafeMath: subtraction overflow'
                                            if t > ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 17
                                            if not accountStakes[address(msg.sender)]:
                                                _38305 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38305] = 26
                                                mem[_38305 + 32] = 'SafeMath: division by zero'
                                                if s < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41133 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41134 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41134 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _42900 = mem[_41134]
                                                    mem[_41133 + 132 len floor32(mem[_41134])] = mem[_41134 + 32 len floor32(mem[_41134])]
                                                    mem[_41133 + floor32(mem[_41134]) + -(mem[_41134] % 32) + 164 len mem[_41134] % 32] = mem[_41134 + -(mem[_41134] % 32) + floor32(mem[_41134]) + 64 len mem[_41134] % 32]
                                                    call stakingTokenAddress.mem[_41133 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41133 + 136 len _42900 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41133 + 242 len 22]
                                                    else:
                                                        mem[_41133 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41133 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41133 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41415 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41416 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41416 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43460 = mem[_41416]
                                                    mem[_41415 + 132 len floor32(mem[_41416])] = mem[_41416 + 32 len floor32(mem[_41416])]
                                                    mem[_41415 + floor32(mem[_41416]) + -(mem[_41416] % 32) + 164 len mem[_41416] % 32] = mem[_41416 + -(mem[_41416] % 32) + floor32(mem[_41416]) + 64 len mem[_41416] % 32]
                                                    call stakingTokenAddress.mem[_41415 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41415 + 136 len _43460 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41415 + 242 len 22]
                                                    else:
                                                        mem[_41415 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41415 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41415 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored - t:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _38781 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38781] = 26
                                                mem[_38781 + 32] = 'SafeMath: division by zero'
                                                if s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41749 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41750 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41750 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44090 = mem[_41750]
                                                    mem[_41749 + 132 len floor32(mem[_41750])] = mem[_41750 + 32 len floor32(mem[_41750])]
                                                    mem[_41749 + floor32(mem[_41750]) + -(mem[_41750] % 32) + 164 len mem[_41750] % 32] = mem[_41750 + -(mem[_41750] % 32) + floor32(mem[_41750]) + 64 len mem[_41750] % 32]
                                                    call stakingTokenAddress.mem[_41749 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41749 + 136 len _44090 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41749 + 242 len 22]
                                                    else:
                                                        mem[_41749 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41749 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41749 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _42043 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _42044 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_42044 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44720 = mem[_42044]
                                                    mem[_42043 + 132 len floor32(mem[_42044])] = mem[_42044 + 32 len floor32(mem[_42044])]
                                                    mem[_42043 + floor32(mem[_42044]) + -(mem[_42044] % 32) + 164 len mem[_42044] % 32] = mem[_42044 + -(mem[_42044] % 32) + floor32(mem[_42044]) + 64 len mem[_42044] % 32]
                                                    call stakingTokenAddress.mem[_42043 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_42043 + 136 len _44720 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42043 + 242 len 22]
                                                    else:
                                                        mem[_42043 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_42043 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42043 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    _32792 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32792] = 30
                                    mem[_32792 + 32] = 'SafeMath: subtraction overflow'
                                    if lastUpdateTime > periodFinish:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not periodFinish - lastUpdateTime:
                                        _33899 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33899] = 26
                                        mem[_33899 + 32] = 'SafeMath: division by zero'
                                        if not totalStakes:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _35383 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35383] = 30
                                        mem[_35383 + 32] = 'SafeMath: subtraction overflow'
                                        if t > (0 / totalStakes) + rewardPerTokenStored:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 17
                                        if not accountStakes[address(msg.sender)]:
                                            _37861 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37861] = 26
                                            mem[_37861 + 32] = 'SafeMath: division by zero'
                                            if s < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40695 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40696 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40696 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42073 = mem[_40696]
                                                mem[_40695 + 132 len floor32(mem[_40696])] = mem[_40696 + 32 len floor32(mem[_40696])]
                                                mem[_40695 + floor32(mem[_40696]) + -(mem[_40696] % 32) + 164 len mem[_40696] % 32] = mem[_40696 + -(mem[_40696] % 32) + floor32(mem[_40696]) + 64 len mem[_40696] % 32]
                                                call stakingTokenAddress.mem[_40695 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40695 + 136 len _42073 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40695 + 242 len 22]
                                                else:
                                                    mem[_40695 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40695 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40695 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40909 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40910 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40910 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42530 = mem[_40910]
                                                mem[_40909 + 132 len floor32(mem[_40910])] = mem[_40910 + 32 len floor32(mem[_40910])]
                                                mem[_40909 + floor32(mem[_40910]) + -(mem[_40910] % 32) + 164 len mem[_40910] % 32] = mem[_40910 + -(mem[_40910] % 32) + floor32(mem[_40910]) + 64 len mem[_40910] % 32]
                                                call stakingTokenAddress.mem[_40909 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40909 + 136 len _42530 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40909 + 242 len 22]
                                                else:
                                                    mem[_40909 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40909 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40909 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _38308 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38308] = 26
                                            mem[_38308 + 32] = 'SafeMath: division by zero'
                                            if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41148 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41149 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41149 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42930 = mem[_41149]
                                                mem[_41148 + 132 len floor32(mem[_41149])] = mem[_41149 + 32 len floor32(mem[_41149])]
                                                mem[_41148 + floor32(mem[_41149]) + -(mem[_41149] % 32) + 164 len mem[_41149] % 32] = mem[_41149 + -(mem[_41149] % 32) + floor32(mem[_41149]) + 64 len mem[_41149] % 32]
                                                call stakingTokenAddress.mem[_41148 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41148 + 136 len _42930 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41148 + 242 len 22]
                                                else:
                                                    mem[_41148 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41148 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41148 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41434 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41435 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41435 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43494 = mem[_41435]
                                                mem[_41434 + 132 len floor32(mem[_41435])] = mem[_41435 + 32 len floor32(mem[_41435])]
                                                mem[_41434 + floor32(mem[_41435]) + -(mem[_41435] % 32) + 164 len mem[_41435] % 32] = mem[_41435 + -(mem[_41435] % 32) + floor32(mem[_41435]) + 64 len mem[_41435] % 32]
                                                call stakingTokenAddress.mem[_41434 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41434 + 136 len _43494 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41434 + 242 len 22]
                                                else:
                                                    mem[_41434 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41434 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41434 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        if (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) / periodFinish - lastUpdateTime != rewardRate:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not (periodFinish * rewardRate) - (lastUpdateTime * rewardRate):
                                            _34026 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34026] = 26
                                            mem[_34026 + 32] = 'SafeMath: division by zero'
                                            if not totalStakes:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _35693 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35693] = 30
                                            mem[_35693 + 32] = 'SafeMath: subtraction overflow'
                                            if t > (0 / totalStakes) + rewardPerTokenStored:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 17
                                            if not accountStakes[address(msg.sender)]:
                                                _38307 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38307] = 26
                                                mem[_38307 + 32] = 'SafeMath: division by zero'
                                                if s < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41143 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41144 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41144 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _42924 = mem[_41144]
                                                    mem[_41143 + 132 len floor32(mem[_41144])] = mem[_41144 + 32 len floor32(mem[_41144])]
                                                    mem[_41143 + floor32(mem[_41144]) + -(mem[_41144] % 32) + 164 len mem[_41144] % 32] = mem[_41144 + -(mem[_41144] % 32) + floor32(mem[_41144]) + 64 len mem[_41144] % 32]
                                                    call stakingTokenAddress.mem[_41143 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41143 + 136 len _42924 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41143 + 242 len 22]
                                                    else:
                                                        mem[_41143 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41143 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41143 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41431 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41432 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41432 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43488 = mem[_41432]
                                                    mem[_41431 + 132 len floor32(mem[_41432])] = mem[_41432 + 32 len floor32(mem[_41432])]
                                                    mem[_41431 + floor32(mem[_41432]) + -(mem[_41432] % 32) + 164 len mem[_41432] % 32] = mem[_41432 + -(mem[_41432] % 32) + floor32(mem[_41432]) + 64 len mem[_41432] % 32]
                                                    call stakingTokenAddress.mem[_41431 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41431 + 136 len _43488 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41431 + 242 len 22]
                                                    else:
                                                        mem[_41431 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41431 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41431 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _38783 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38783] = 26
                                                mem[_38783 + 32] = 'SafeMath: division by zero'
                                                if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41765 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41766 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41766 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44120 = mem[_41766]
                                                    mem[_41765 + 132 len floor32(mem[_41766])] = mem[_41766 + 32 len floor32(mem[_41766])]
                                                    mem[_41765 + floor32(mem[_41766]) + -(mem[_41766] % 32) + 164 len mem[_41766] % 32] = mem[_41766 + -(mem[_41766] % 32) + floor32(mem[_41766]) + 64 len mem[_41766] % 32]
                                                    call stakingTokenAddress.mem[_41765 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41765 + 136 len _44120 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41765 + 242 len 22]
                                                    else:
                                                        mem[_41765 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41765 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41765 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _42067 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _42068 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_42068 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44758 = mem[_42068]
                                                    mem[_42067 + 132 len floor32(mem[_42068])] = mem[_42068 + 32 len floor32(mem[_42068])]
                                                    mem[_42067 + floor32(mem[_42068]) + -(mem[_42068] % 32) + 164 len mem[_42068] % 32] = mem[_42068 + -(mem[_42068] % 32) + floor32(mem[_42068]) + 64 len mem[_42068] % 32]
                                                    call stakingTokenAddress.mem[_42067 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_42067 + 136 len _44758 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42067 + 242 len 22]
                                                    else:
                                                        mem[_42067 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_42067 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42067 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _34180 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34180] = 26
                                            mem[_34180 + 32] = 'SafeMath: division by zero'
                                            if not totalStakes:
                                                revert with 0, 'SafeMath: division by zero'
                                            if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _36184 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36184] = 30
                                            mem[_36184 + 32] = 'SafeMath: subtraction overflow'
                                            if t > ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 17
                                            if not accountStakes[address(msg.sender)]:
                                                _38782 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38782] = 26
                                                mem[_38782 + 32] = 'SafeMath: division by zero'
                                                if s < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41760 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41761 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41761 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44114 = mem[_41761]
                                                    mem[_41760 + 132 len floor32(mem[_41761])] = mem[_41761 + 32 len floor32(mem[_41761])]
                                                    mem[_41760 + floor32(mem[_41761]) + -(mem[_41761] % 32) + 164 len mem[_41761] % 32] = mem[_41761 + -(mem[_41761] % 32) + floor32(mem[_41761]) + 64 len mem[_41761] % 32]
                                                    call stakingTokenAddress.mem[_41760 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41760 + 136 len _44114 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41760 + 242 len 22]
                                                    else:
                                                        mem[_41760 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41760 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41760 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _42064 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _42065 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_42065 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44752 = mem[_42065]
                                                    mem[_42064 + 132 len floor32(mem[_42065])] = mem[_42065 + 32 len floor32(mem[_42065])]
                                                    mem[_42064 + floor32(mem[_42065]) + -(mem[_42065] % 32) + 164 len mem[_42065] % 32] = mem[_42065 + -(mem[_42065] % 32) + floor32(mem[_42065]) + 64 len mem[_42065] % 32]
                                                    call stakingTokenAddress.mem[_42064 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_42064 + 136 len _44752 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42064 + 242 len 22]
                                                    else:
                                                        mem[_42064 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_42064 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42064 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored - t:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _39385 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39385] = 26
                                                mem[_39385 + 32] = 'SafeMath: division by zero'
                                                if s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _42522 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _42523 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_42523 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _45588 = mem[_42523]
                                                    mem[_42522 + 132 len floor32(mem[_42523])] = mem[_42523 + 32 len floor32(mem[_42523])]
                                                    mem[_42522 + floor32(mem[_42523]) + -(mem[_42523] % 32) + 164 len mem[_42523] % 32] = mem[_42523 + -(mem[_42523] % 32) + floor32(mem[_42523]) + 64 len mem[_42523] % 32]
                                                    call stakingTokenAddress.mem[_42522 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_42522 + 136 len _45588 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42522 + 242 len 22]
                                                    else:
                                                        mem[_42522 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_42522 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42522 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _42918 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _42919 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_42919 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _46317 = mem[_42919]
                                                    mem[_42918 + 132 len floor32(mem[_42919])] = mem[_42919 + 32 len floor32(mem[_42919])]
                                                    mem[_42918 + floor32(mem[_42919]) + -(mem[_42919] % 32) + 164 len mem[_42919] % 32] = mem[_42919 + -(mem[_42919] % 32) + floor32(mem[_42919]) + 64 len mem[_42919] % 32]
                                                    call stakingTokenAddress.mem[_42918 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_42918 + 136 len _46317 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42918 + 242 len 22]
                                                    else:
                                                        mem[_42918 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_42918 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42918 + ceil32(return_data.size) + 243 len 22]
                    else:
                        lastUpdateTime = periodFinish
                        if not msg.sender:
                            if arg1 <= 0:
                                revert with 0, 'staking 0'
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                revert with 0, 'SafeERC20: call to non-contract'
                            if not ext_code.hash(stakingTokenAddress):
                                revert with 0, 'SafeERC20: call to non-contract'
                            mem[356 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg1) >> 32
                            mem[480 len 4] = uint32(arg1)
                            call stakingTokenAddress with:
                                 gas gas_remaining wei
                                args Mask(224, 32, arg1) << 480, mem[452 len 4]
                            if not return_data.size:
                                require not ext_call.success
                                revert with 0, 'SafeERC20: low-level call failed'
                            mem[388 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[388]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[ceil32(return_data.size) + 467 len 22]
                        else:
                            mem[224] = 0
                            mem[256] = 0
                            mem[288] = 0
                            mem[320] = 0
                            mem[0] = msg.sender
                            mem[32] = 16
                            mem[64] = 480
                            mem[352] = sub_183ddbfb[address(msg.sender)].field_0
                            mem[384] = sub_183ddbfb[address(msg.sender)].field_256
                            mem[416] = sub_183ddbfb[address(msg.sender)].field_512
                            mem[448] = sub_183ddbfb[address(msg.sender)].field_768
                            idx = sub_183ddbfb[address(msg.sender)].field_768
                            s = sub_183ddbfb[address(msg.sender)].field_512
                            t = sub_183ddbfb[address(msg.sender)].field_256
                            while idx < sub_e7690c44:
                                require idx < sub_155b0a71.length
                                mem[0] = 15
                                if not t:
                                    _32434 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32434] = 26
                                    mem[_32434 + 32] = 'SafeMath: division by zero'
                                    require idx < sub_155b0a71.length
                                    mem[0] = 15
                                    if not s:
                                        _33678 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33678] = 26
                                        mem[_33678 + 32] = 'SafeMath: division by zero'
                                        idx = idx + 1
                                        s = 0
                                        t = 0
                                        continue 
                                    if sub_155b0a71[idx] * s / s != sub_155b0a71[idx]:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _33762 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33762] = 26
                                    mem[_33762 + 32] = 'SafeMath: division by zero'
                                    idx = idx + 1
                                    s = sub_155b0a71[idx] * s / 10^18
                                    t = 0
                                    continue 
                                if sub_155b0a71[idx] * t / t != sub_155b0a71[idx]:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _32548 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32548] = 26
                                mem[_32548 + 32] = 'SafeMath: division by zero'
                                require idx < sub_155b0a71.length
                                mem[0] = 15
                                if not s:
                                    _33761 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33761] = 26
                                    mem[_33761 + 32] = 'SafeMath: division by zero'
                                    idx = idx + 1
                                    s = 0
                                    t = sub_155b0a71[idx] * t / 10^18
                                    continue 
                                if sub_155b0a71[idx] * s / s != sub_155b0a71[idx]:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _33812 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33812] = 26
                                mem[_33812 + 32] = 'SafeMath: division by zero'
                                idx = idx + 1
                                s = sub_155b0a71[idx] * s / 10^18
                                t = sub_155b0a71[idx] * t / 10^18
                                continue 
                            if 0 == totalStakes:
                                _32362 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32362] = 30
                                mem[_32362 + 32] = 'SafeMath: subtraction overflow'
                                if t > rewardPerTokenStored:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 17
                                if not accountStakes[address(msg.sender)]:
                                    _33297 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33297] = 26
                                    mem[_33297 + 32] = 'SafeMath: division by zero'
                                    if s < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_183ddbfb[address(msg.sender)].field_512 = s
                                    sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                    sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                    if sub_183ddbfb[address(msg.sender)].field_0:
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _34356 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _34357 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_34357 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _34978 = mem[_34357]
                                        mem[_34356 + 132 len floor32(mem[_34357])] = mem[_34357 + 32 len floor32(mem[_34357])]
                                        mem[_34356 + floor32(mem[_34357]) + -(mem[_34357] % 32) + 164 len mem[_34357] % 32] = mem[_34357 + -(mem[_34357] % 32) + floor32(mem[_34357]) + 64 len mem[_34357] % 32]
                                        call stakingTokenAddress.mem[_34356 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_34356 + 136 len _34978 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34356 + 242 len 22]
                                        else:
                                            mem[_34356 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_34356 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34356 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _34494 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _34495 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_34495 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _35124 = mem[_34495]
                                        mem[_34494 + 132 len floor32(mem[_34495])] = mem[_34495 + 32 len floor32(mem[_34495])]
                                        mem[_34494 + floor32(mem[_34495]) + -(mem[_34495] % 32) + 164 len mem[_34495] % 32] = mem[_34495 + -(mem[_34495] % 32) + floor32(mem[_34495]) + 64 len mem[_34495] % 32]
                                        call stakingTokenAddress.mem[_34494 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_34494 + 136 len _35124 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34494 + 242 len 22]
                                        else:
                                            mem[_34494 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_34494 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34494 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    if (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != rewardPerTokenStored - t:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _33560 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33560] = 26
                                    mem[_33560 + 32] = 'SafeMath: division by zero'
                                    if s + ((rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_183ddbfb[address(msg.sender)].field_512 = s + ((rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                    sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                    sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                    if sub_183ddbfb[address(msg.sender)].field_0:
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _34678 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _34679 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_34679 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _35228 = mem[_34679]
                                        mem[_34678 + 132 len floor32(mem[_34679])] = mem[_34679 + 32 len floor32(mem[_34679])]
                                        mem[_34678 + floor32(mem[_34679]) + -(mem[_34679] % 32) + 164 len mem[_34679] % 32] = mem[_34679 + -(mem[_34679] % 32) + floor32(mem[_34679]) + 64 len mem[_34679] % 32]
                                        call stakingTokenAddress.mem[_34678 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_34678 + 136 len _35228 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34678 + 242 len 22]
                                        else:
                                            mem[_34678 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_34678 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34678 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _34808 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _34809 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_34809 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _35403 = mem[_34809]
                                        mem[_34808 + 132 len floor32(mem[_34809])] = mem[_34809 + 32 len floor32(mem[_34809])]
                                        mem[_34808 + floor32(mem[_34809]) + -(mem[_34809] % 32) + 164 len mem[_34809] % 32] = mem[_34809 + -(mem[_34809] % 32) + floor32(mem[_34809]) + 64 len mem[_34809] % 32]
                                        call stakingTokenAddress.mem[_34808 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_34808 + 136 len _35403 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34808 + 242 len 22]
                                        else:
                                            mem[_34808 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_34808 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34808 + ceil32(return_data.size) + 243 len 22]
                            else:
                                if block.timestamp < periodFinish:
                                    _32624 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32624] = 30
                                    mem[_32624 + 32] = 'SafeMath: subtraction overflow'
                                    if lastUpdateTime > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not block.timestamp - lastUpdateTime:
                                        _33828 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33828] = 26
                                        mem[_33828 + 32] = 'SafeMath: division by zero'
                                        if not totalStakes:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _35120 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35120] = 30
                                        mem[_35120 + 32] = 'SafeMath: subtraction overflow'
                                        if t > (0 / totalStakes) + rewardPerTokenStored:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 17
                                        if not accountStakes[address(msg.sender)]:
                                            _37398 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37398] = 26
                                            mem[_37398 + 32] = 'SafeMath: division by zero'
                                            if s < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40466 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40467 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40467 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _41448 = mem[_40467]
                                                mem[_40466 + 132 len floor32(mem[_40467])] = mem[_40467 + 32 len floor32(mem[_40467])]
                                                mem[_40466 + floor32(mem[_40467]) + -(mem[_40467] % 32) + 164 len mem[_40467] % 32] = mem[_40467 + -(mem[_40467] % 32) + floor32(mem[_40467]) + 64 len mem[_40467] % 32]
                                                call stakingTokenAddress.mem[_40466 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40466 + 136 len _41448 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40466 + 242 len 22]
                                                else:
                                                    mem[_40466 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40466 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40466 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40546 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40547 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40547 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _41778 = mem[_40547]
                                                mem[_40546 + 132 len floor32(mem[_40547])] = mem[_40547 + 32 len floor32(mem[_40547])]
                                                mem[_40546 + floor32(mem[_40547]) + -(mem[_40547] % 32) + 164 len mem[_40547] % 32] = mem[_40547 + -(mem[_40547] % 32) + floor32(mem[_40547]) + 64 len mem[_40547] % 32]
                                                call stakingTokenAddress.mem[_40546 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40546 + 136 len _41778 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40546 + 242 len 22]
                                                else:
                                                    mem[_40546 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40546 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40546 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _37873 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37873] = 26
                                            mem[_37873 + 32] = 'SafeMath: division by zero'
                                            if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40705 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40706 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40706 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42088 = mem[_40706]
                                                mem[_40705 + 132 len floor32(mem[_40706])] = mem[_40706 + 32 len floor32(mem[_40706])]
                                                mem[_40705 + floor32(mem[_40706]) + -(mem[_40706] % 32) + 164 len mem[_40706] % 32] = mem[_40706 + -(mem[_40706] % 32) + floor32(mem[_40706]) + 64 len mem[_40706] % 32]
                                                call stakingTokenAddress.mem[_40705 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40705 + 136 len _42088 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40705 + 242 len 22]
                                                else:
                                                    mem[_40705 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40705 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40705 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40919 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40920 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40920 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42542 = mem[_40920]
                                                mem[_40919 + 132 len floor32(mem[_40920])] = mem[_40920 + 32 len floor32(mem[_40920])]
                                                mem[_40919 + floor32(mem[_40920]) + -(mem[_40920] % 32) + 164 len mem[_40920] % 32] = mem[_40920 + -(mem[_40920] % 32) + floor32(mem[_40920]) + 64 len mem[_40920] % 32]
                                                call stakingTokenAddress.mem[_40919 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40919 + 136 len _42542 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40919 + 242 len 22]
                                                else:
                                                    mem[_40919 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40919 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40919 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        if (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) / block.timestamp - lastUpdateTime != rewardRate:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate):
                                            _33902 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33902] = 26
                                            mem[_33902 + 32] = 'SafeMath: division by zero'
                                            if not totalStakes:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _35395 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35395] = 30
                                            mem[_35395 + 32] = 'SafeMath: subtraction overflow'
                                            if t > (0 / totalStakes) + rewardPerTokenStored:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 17
                                            if not accountStakes[address(msg.sender)]:
                                                _37872 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37872] = 26
                                                mem[_37872 + 32] = 'SafeMath: division by zero'
                                                if s < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _40700 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _40701 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_40701 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _42082 = mem[_40701]
                                                    mem[_40700 + 132 len floor32(mem[_40701])] = mem[_40701 + 32 len floor32(mem[_40701])]
                                                    mem[_40700 + floor32(mem[_40701]) + -(mem[_40701] % 32) + 164 len mem[_40701] % 32] = mem[_40701 + -(mem[_40701] % 32) + floor32(mem[_40701]) + 64 len mem[_40701] % 32]
                                                    call stakingTokenAddress.mem[_40700 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_40700 + 136 len _42082 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_40700 + 242 len 22]
                                                    else:
                                                        mem[_40700 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_40700 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_40700 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _40916 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _40917 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_40917 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _42536 = mem[_40917]
                                                    mem[_40916 + 132 len floor32(mem[_40917])] = mem[_40917 + 32 len floor32(mem[_40917])]
                                                    mem[_40916 + floor32(mem[_40917]) + -(mem[_40917] % 32) + 164 len mem[_40917] % 32] = mem[_40917 + -(mem[_40917] % 32) + floor32(mem[_40917]) + 64 len mem[_40917] % 32]
                                                    call stakingTokenAddress.mem[_40916 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_40916 + 136 len _42536 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_40916 + 242 len 22]
                                                    else:
                                                        mem[_40916 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_40916 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_40916 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _38322 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38322] = 26
                                                mem[_38322 + 32] = 'SafeMath: division by zero'
                                                if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41158 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41159 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41159 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _42946 = mem[_41159]
                                                    mem[_41158 + 132 len floor32(mem[_41159])] = mem[_41159 + 32 len floor32(mem[_41159])]
                                                    mem[_41158 + floor32(mem[_41159]) + -(mem[_41159] % 32) + 164 len mem[_41159] % 32] = mem[_41159 + -(mem[_41159] % 32) + floor32(mem[_41159]) + 64 len mem[_41159] % 32]
                                                    call stakingTokenAddress.mem[_41158 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41158 + 136 len _42946 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41158 + 242 len 22]
                                                    else:
                                                        mem[_41158 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41158 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41158 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41442 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41443 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41443 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43511 = mem[_41443]
                                                    mem[_41442 + 132 len floor32(mem[_41443])] = mem[_41443 + 32 len floor32(mem[_41443])]
                                                    mem[_41442 + floor32(mem[_41443]) + -(mem[_41443] % 32) + 164 len mem[_41443] % 32] = mem[_41443 + -(mem[_41443] % 32) + floor32(mem[_41443]) + 64 len mem[_41443] % 32]
                                                    call stakingTokenAddress.mem[_41442 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41442 + 136 len _43511 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41442 + 242 len 22]
                                                    else:
                                                        mem[_41442 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41442 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41442 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _34030 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34030] = 26
                                            mem[_34030 + 32] = 'SafeMath: division by zero'
                                            if not totalStakes:
                                                revert with 0, 'SafeMath: division by zero'
                                            if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _35708 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35708] = 30
                                            mem[_35708 + 32] = 'SafeMath: subtraction overflow'
                                            if t > ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 17
                                            if not accountStakes[address(msg.sender)]:
                                                _38321 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38321] = 26
                                                mem[_38321 + 32] = 'SafeMath: division by zero'
                                                if s < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41153 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41154 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41154 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _42940 = mem[_41154]
                                                    mem[_41153 + 132 len floor32(mem[_41154])] = mem[_41154 + 32 len floor32(mem[_41154])]
                                                    mem[_41153 + floor32(mem[_41154]) + -(mem[_41154] % 32) + 164 len mem[_41154] % 32] = mem[_41154 + -(mem[_41154] % 32) + floor32(mem[_41154]) + 64 len mem[_41154] % 32]
                                                    call stakingTokenAddress.mem[_41153 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41153 + 136 len _42940 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41153 + 242 len 22]
                                                    else:
                                                        mem[_41153 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41153 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41153 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41439 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41440 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41440 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43505 = mem[_41440]
                                                    mem[_41439 + 132 len floor32(mem[_41440])] = mem[_41440 + 32 len floor32(mem[_41440])]
                                                    mem[_41439 + floor32(mem[_41440]) + -(mem[_41440] % 32) + 164 len mem[_41440] % 32] = mem[_41440 + -(mem[_41440] % 32) + floor32(mem[_41440]) + 64 len mem[_41440] % 32]
                                                    call stakingTokenAddress.mem[_41439 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41439 + 136 len _43505 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41439 + 242 len 22]
                                                    else:
                                                        mem[_41439 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41439 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41439 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored - t:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _38804 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38804] = 26
                                                mem[_38804 + 32] = 'SafeMath: division by zero'
                                                if s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41770 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41771 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41771 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44135 = mem[_41771]
                                                    mem[_41770 + 132 len floor32(mem[_41771])] = mem[_41771 + 32 len floor32(mem[_41771])]
                                                    mem[_41770 + floor32(mem[_41771]) + -(mem[_41771] % 32) + 164 len mem[_41771] % 32] = mem[_41771 + -(mem[_41771] % 32) + floor32(mem[_41771]) + 64 len mem[_41771] % 32]
                                                    call stakingTokenAddress.mem[_41770 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41770 + 136 len _44135 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41770 + 242 len 22]
                                                    else:
                                                        mem[_41770 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41770 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41770 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _42076 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _42077 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_42077 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44780 = mem[_42077]
                                                    mem[_42076 + 132 len floor32(mem[_42077])] = mem[_42077 + 32 len floor32(mem[_42077])]
                                                    mem[_42076 + floor32(mem[_42077]) + -(mem[_42077] % 32) + 164 len mem[_42077] % 32] = mem[_42077 + -(mem[_42077] % 32) + floor32(mem[_42077]) + 64 len mem[_42077] % 32]
                                                    call stakingTokenAddress.mem[_42076 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_42076 + 136 len _44780 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42076 + 242 len 22]
                                                    else:
                                                        mem[_42076 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_42076 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42076 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    _32798 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32798] = 30
                                    mem[_32798 + 32] = 'SafeMath: subtraction overflow'
                                    if lastUpdateTime > periodFinish:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not periodFinish - lastUpdateTime:
                                        _33906 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33906] = 26
                                        mem[_33906 + 32] = 'SafeMath: division by zero'
                                        if not totalStakes:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _35399 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35399] = 30
                                        mem[_35399 + 32] = 'SafeMath: subtraction overflow'
                                        if t > (0 / totalStakes) + rewardPerTokenStored:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 17
                                        if not accountStakes[address(msg.sender)]:
                                            _37876 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37876] = 26
                                            mem[_37876 + 32] = 'SafeMath: division by zero'
                                            if s < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40710 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40711 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40711 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42106 = mem[_40711]
                                                mem[_40710 + 132 len floor32(mem[_40711])] = mem[_40711 + 32 len floor32(mem[_40711])]
                                                mem[_40710 + floor32(mem[_40711]) + -(mem[_40711] % 32) + 164 len mem[_40711] % 32] = mem[_40711 + -(mem[_40711] % 32) + floor32(mem[_40711]) + 64 len mem[_40711] % 32]
                                                call stakingTokenAddress.mem[_40710 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40710 + 136 len _42106 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40710 + 242 len 22]
                                                else:
                                                    mem[_40710 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40710 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40710 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40926 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40927 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40927 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42558 = mem[_40927]
                                                mem[_40926 + 132 len floor32(mem[_40927])] = mem[_40927 + 32 len floor32(mem[_40927])]
                                                mem[_40926 + floor32(mem[_40927]) + -(mem[_40927] % 32) + 164 len mem[_40927] % 32] = mem[_40927 + -(mem[_40927] % 32) + floor32(mem[_40927]) + 64 len mem[_40927] % 32]
                                                call stakingTokenAddress.mem[_40926 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40926 + 136 len _42558 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40926 + 242 len 22]
                                                else:
                                                    mem[_40926 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40926 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40926 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _38324 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38324] = 26
                                            mem[_38324 + 32] = 'SafeMath: division by zero'
                                            if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41168 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41169 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41169 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42970 = mem[_41169]
                                                mem[_41168 + 132 len floor32(mem[_41169])] = mem[_41169 + 32 len floor32(mem[_41169])]
                                                mem[_41168 + floor32(mem[_41169]) + -(mem[_41169] % 32) + 164 len mem[_41169] % 32] = mem[_41169 + -(mem[_41169] % 32) + floor32(mem[_41169]) + 64 len mem[_41169] % 32]
                                                call stakingTokenAddress.mem[_41168 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41168 + 136 len _42970 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41168 + 242 len 22]
                                                else:
                                                    mem[_41168 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41168 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41168 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41458 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41459 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41459 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43539 = mem[_41459]
                                                mem[_41458 + 132 len floor32(mem[_41459])] = mem[_41459 + 32 len floor32(mem[_41459])]
                                                mem[_41458 + floor32(mem[_41459]) + -(mem[_41459] % 32) + 164 len mem[_41459] % 32] = mem[_41459 + -(mem[_41459] % 32) + floor32(mem[_41459]) + 64 len mem[_41459] % 32]
                                                call stakingTokenAddress.mem[_41458 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41458 + 136 len _43539 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41458 + 242 len 22]
                                                else:
                                                    mem[_41458 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41458 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41458 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        if (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) / periodFinish - lastUpdateTime != rewardRate:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not (periodFinish * rewardRate) - (lastUpdateTime * rewardRate):
                                            _34035 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34035] = 26
                                            mem[_34035 + 32] = 'SafeMath: division by zero'
                                            if not totalStakes:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _35714 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35714] = 30
                                            mem[_35714 + 32] = 'SafeMath: subtraction overflow'
                                            if t > (0 / totalStakes) + rewardPerTokenStored:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 17
                                            if not accountStakes[address(msg.sender)]:
                                                _38323 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38323] = 26
                                                mem[_38323 + 32] = 'SafeMath: division by zero'
                                                if s < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41163 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41164 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41164 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _42964 = mem[_41164]
                                                    mem[_41163 + 132 len floor32(mem[_41164])] = mem[_41164 + 32 len floor32(mem[_41164])]
                                                    mem[_41163 + floor32(mem[_41164]) + -(mem[_41164] % 32) + 164 len mem[_41164] % 32] = mem[_41164 + -(mem[_41164] % 32) + floor32(mem[_41164]) + 64 len mem[_41164] % 32]
                                                    call stakingTokenAddress.mem[_41163 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41163 + 136 len _42964 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41163 + 242 len 22]
                                                    else:
                                                        mem[_41163 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41163 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41163 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41455 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41456 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41456 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43533 = mem[_41456]
                                                    mem[_41455 + 132 len floor32(mem[_41456])] = mem[_41456 + 32 len floor32(mem[_41456])]
                                                    mem[_41455 + floor32(mem[_41456]) + -(mem[_41456] % 32) + 164 len mem[_41456] % 32] = mem[_41456 + -(mem[_41456] % 32) + floor32(mem[_41456]) + 64 len mem[_41456] % 32]
                                                    call stakingTokenAddress.mem[_41455 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41455 + 136 len _43533 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41455 + 242 len 22]
                                                    else:
                                                        mem[_41455 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41455 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41455 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _38806 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38806] = 26
                                                mem[_38806 + 32] = 'SafeMath: division by zero'
                                                if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41786 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41787 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41787 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44165 = mem[_41787]
                                                    mem[_41786 + 132 len floor32(mem[_41787])] = mem[_41787 + 32 len floor32(mem[_41787])]
                                                    mem[_41786 + floor32(mem[_41787]) + -(mem[_41787] % 32) + 164 len mem[_41787] % 32] = mem[_41787 + -(mem[_41787] % 32) + floor32(mem[_41787]) + 64 len mem[_41787] % 32]
                                                    call stakingTokenAddress.mem[_41786 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41786 + 136 len _44165 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41786 + 242 len 22]
                                                    else:
                                                        mem[_41786 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41786 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41786 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _42100 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _42101 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_42101 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44818 = mem[_42101]
                                                    mem[_42100 + 132 len floor32(mem[_42101])] = mem[_42101 + 32 len floor32(mem[_42101])]
                                                    mem[_42100 + floor32(mem[_42101]) + -(mem[_42101] % 32) + 164 len mem[_42101] % 32] = mem[_42101 + -(mem[_42101] % 32) + floor32(mem[_42101]) + 64 len mem[_42101] % 32]
                                                    call stakingTokenAddress.mem[_42100 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_42100 + 136 len _44818 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42100 + 242 len 22]
                                                    else:
                                                        mem[_42100 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_42100 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42100 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _34192 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34192] = 26
                                            mem[_34192 + 32] = 'SafeMath: division by zero'
                                            if not totalStakes:
                                                revert with 0, 'SafeMath: division by zero'
                                            if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _36207 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36207] = 30
                                            mem[_36207 + 32] = 'SafeMath: subtraction overflow'
                                            if t > ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 17
                                            if not accountStakes[address(msg.sender)]:
                                                _38805 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38805] = 26
                                                mem[_38805 + 32] = 'SafeMath: division by zero'
                                                if s < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41781 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41782 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41782 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44159 = mem[_41782]
                                                    mem[_41781 + 132 len floor32(mem[_41782])] = mem[_41782 + 32 len floor32(mem[_41782])]
                                                    mem[_41781 + floor32(mem[_41782]) + -(mem[_41782] % 32) + 164 len mem[_41782] % 32] = mem[_41782 + -(mem[_41782] % 32) + floor32(mem[_41782]) + 64 len mem[_41782] % 32]
                                                    call stakingTokenAddress.mem[_41781 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41781 + 136 len _44159 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41781 + 242 len 22]
                                                    else:
                                                        mem[_41781 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41781 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41781 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _42097 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _42098 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_42098 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44812 = mem[_42098]
                                                    mem[_42097 + 132 len floor32(mem[_42098])] = mem[_42098 + 32 len floor32(mem[_42098])]
                                                    mem[_42097 + floor32(mem[_42098]) + -(mem[_42098] % 32) + 164 len mem[_42098] % 32] = mem[_42098 + -(mem[_42098] % 32) + floor32(mem[_42098]) + 64 len mem[_42098] % 32]
                                                    call stakingTokenAddress.mem[_42097 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_42097 + 136 len _44812 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42097 + 242 len 22]
                                                    else:
                                                        mem[_42097 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_42097 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42097 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored - t:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _39412 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39412] = 26
                                                mem[_39412 + 32] = 'SafeMath: division by zero'
                                                if s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _42550 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _42551 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_42551 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _45640 = mem[_42551]
                                                    mem[_42550 + 132 len floor32(mem[_42551])] = mem[_42551 + 32 len floor32(mem[_42551])]
                                                    mem[_42550 + floor32(mem[_42551]) + -(mem[_42551] % 32) + 164 len mem[_42551] % 32] = mem[_42551 + -(mem[_42551] % 32) + floor32(mem[_42551]) + 64 len mem[_42551] % 32]
                                                    call stakingTokenAddress.mem[_42550 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_42550 + 136 len _45640 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42550 + 242 len 22]
                                                    else:
                                                        mem[_42550 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_42550 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42550 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _42958 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _42959 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_42959 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _46378 = mem[_42959]
                                                    mem[_42958 + 132 len floor32(mem[_42959])] = mem[_42959 + 32 len floor32(mem[_42959])]
                                                    mem[_42958 + floor32(mem[_42959]) + -(mem[_42959] % 32) + 164 len mem[_42959] % 32] = mem[_42959 + -(mem[_42959] % 32) + floor32(mem[_42959]) + 64 len mem[_42959] % 32]
                                                    call stakingTokenAddress.mem[_42958 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_42958 + 136 len _46378 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42958 + 242 len 22]
                                                    else:
                                                        mem[_42958 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_42958 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42958 + ceil32(return_data.size) + 243 len 22]
        else:
            if lastUpdateTime > periodFinish:
                revert with 0, 'SafeMath: subtraction overflow'
            if not periodFinish - lastUpdateTime:
                mem[160] = 26
                mem[192] = 'SafeMath: division by zero'
                if not totalStakes:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                    revert with 0, 'SafeMath: addition overflow'
                rewardPerTokenStored += 0 / totalStakes
                if block.timestamp < periodFinish:
                    lastUpdateTime = block.timestamp
                    if not msg.sender:
                        if arg1 <= 0:
                            revert with 0, 'staking 0'
                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                            revert with 0, 'SafeERC20: call to non-contract'
                        if not ext_code.hash(stakingTokenAddress):
                            revert with 0, 'SafeERC20: call to non-contract'
                        mem[356 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg1) >> 32
                        mem[480 len 4] = uint32(arg1)
                        call stakingTokenAddress with:
                             gas gas_remaining wei
                            args Mask(224, 32, arg1) << 480, mem[452 len 4]
                        if not return_data.size:
                            require not ext_call.success
                            revert with 0, 'SafeERC20: low-level call failed'
                        mem[388 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            if not mem[388]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[ceil32(return_data.size) + 467 len 22]
                    else:
                        mem[224] = 0
                        mem[256] = 0
                        mem[288] = 0
                        mem[320] = 0
                        mem[0] = msg.sender
                        mem[32] = 16
                        mem[64] = 480
                        mem[352] = sub_183ddbfb[address(msg.sender)].field_0
                        mem[384] = sub_183ddbfb[address(msg.sender)].field_256
                        mem[416] = sub_183ddbfb[address(msg.sender)].field_512
                        mem[448] = sub_183ddbfb[address(msg.sender)].field_768
                        idx = sub_183ddbfb[address(msg.sender)].field_768
                        s = sub_183ddbfb[address(msg.sender)].field_512
                        t = sub_183ddbfb[address(msg.sender)].field_256
                        while idx < sub_e7690c44:
                            require idx < sub_155b0a71.length
                            mem[0] = 15
                            if not t:
                                _32479 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32479] = 26
                                mem[_32479 + 32] = 'SafeMath: division by zero'
                                require idx < sub_155b0a71.length
                                mem[0] = 15
                                if not s:
                                    _33714 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33714] = 26
                                    mem[_33714 + 32] = 'SafeMath: division by zero'
                                    idx = idx + 1
                                    s = 0
                                    t = 0
                                    continue 
                                if sub_155b0a71[idx] * s / s != sub_155b0a71[idx]:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _33798 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33798] = 26
                                mem[_33798 + 32] = 'SafeMath: division by zero'
                                idx = idx + 1
                                s = sub_155b0a71[idx] * s / 10^18
                                t = 0
                                continue 
                            if sub_155b0a71[idx] * t / t != sub_155b0a71[idx]:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _32602 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32602] = 26
                            mem[_32602 + 32] = 'SafeMath: division by zero'
                            require idx < sub_155b0a71.length
                            mem[0] = 15
                            if not s:
                                _33797 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33797] = 26
                                mem[_33797 + 32] = 'SafeMath: division by zero'
                                idx = idx + 1
                                s = 0
                                t = sub_155b0a71[idx] * t / 10^18
                                continue 
                            if sub_155b0a71[idx] * s / s != sub_155b0a71[idx]:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _33821 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33821] = 26
                            mem[_33821 + 32] = 'SafeMath: division by zero'
                            idx = idx + 1
                            s = sub_155b0a71[idx] * s / 10^18
                            t = sub_155b0a71[idx] * t / 10^18
                            continue 
                        if 0 == totalStakes:
                            _32407 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32407] = 30
                            mem[_32407 + 32] = 'SafeMath: subtraction overflow'
                            if t > rewardPerTokenStored:
                                revert with 0, 'SafeMath: subtraction overflow'
                            mem[0] = msg.sender
                            mem[32] = 17
                            if not accountStakes[address(msg.sender)]:
                                _33387 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33387] = 26
                                mem[_33387 + 32] = 'SafeMath: division by zero'
                                if s < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                if sub_183ddbfb[address(msg.sender)].field_0:
                                    if arg1 <= 0:
                                        revert with 0, 'staking 0'
                                    _34437 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = this.address
                                    mem[mem[64] + 100] = arg1
                                    _34438 = mem[64]
                                    mem[mem[64]] = 100
                                    mem[64] = mem[64] + 132
                                    mem[_34438 + 32 len 4] = unknown_0x23b872dd(?????)
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    _35077 = mem[_34438]
                                    mem[_34437 + 132 len floor32(mem[_34438])] = mem[_34438 + 32 len floor32(mem[_34438])]
                                    mem[_34437 + floor32(mem[_34438]) + -(mem[_34438] % 32) + 164 len mem[_34438] % 32] = mem[_34438 + -(mem[_34438] % 32) + floor32(mem[_34438]) + 64 len mem[_34438] % 32]
                                    call stakingTokenAddress.mem[_34437 + 132 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_34437 + 136 len _35077 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_34437 + 242 len 22]
                                    else:
                                        mem[_34437 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[_34437 + 164]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_34437 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                    if arg1 <= 0:
                                        revert with 0, 'staking 0'
                                    _34620 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = this.address
                                    mem[mem[64] + 100] = arg1
                                    _34621 = mem[64]
                                    mem[mem[64]] = 100
                                    mem[64] = mem[64] + 132
                                    mem[_34621 + 32 len 4] = unknown_0x23b872dd(?????)
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    _35187 = mem[_34621]
                                    mem[_34620 + 132 len floor32(mem[_34621])] = mem[_34621 + 32 len floor32(mem[_34621])]
                                    mem[_34620 + floor32(mem[_34621]) + -(mem[_34621] % 32) + 164 len mem[_34621] % 32] = mem[_34621 + -(mem[_34621] % 32) + floor32(mem[_34621]) + 64 len mem[_34621] % 32]
                                    call stakingTokenAddress.mem[_34620 + 132 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_34620 + 136 len _35187 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_34620 + 242 len 22]
                                    else:
                                        mem[_34620 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[_34620 + 164]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_34620 + ceil32(return_data.size) + 243 len 22]
                            else:
                                if (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != rewardPerTokenStored - t:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _33641 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33641] = 26
                                mem[_33641 + 32] = 'SafeMath: division by zero'
                                if s + ((rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_183ddbfb[address(msg.sender)].field_512 = s + ((rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                if sub_183ddbfb[address(msg.sender)].field_0:
                                    if arg1 <= 0:
                                        revert with 0, 'staking 0'
                                    _34759 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = this.address
                                    mem[mem[64] + 100] = arg1
                                    _34760 = mem[64]
                                    mem[mem[64]] = 100
                                    mem[64] = mem[64] + 132
                                    mem[_34760 + 32 len 4] = unknown_0x23b872dd(?????)
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    _35336 = mem[_34760]
                                    mem[_34759 + 132 len floor32(mem[_34760])] = mem[_34760 + 32 len floor32(mem[_34760])]
                                    mem[_34759 + floor32(mem[_34760]) + -(mem[_34760] % 32) + 164 len mem[_34760] % 32] = mem[_34760 + -(mem[_34760] % 32) + floor32(mem[_34760]) + 64 len mem[_34760] % 32]
                                    call stakingTokenAddress.mem[_34759 + 132 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_34759 + 136 len _35336 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_34759 + 242 len 22]
                                    else:
                                        mem[_34759 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[_34759 + 164]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_34759 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                    if arg1 <= 0:
                                        revert with 0, 'staking 0'
                                    _34898 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = this.address
                                    mem[mem[64] + 100] = arg1
                                    _34899 = mem[64]
                                    mem[mem[64]] = 100
                                    mem[64] = mem[64] + 132
                                    mem[_34899 + 32 len 4] = unknown_0x23b872dd(?????)
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    _35547 = mem[_34899]
                                    mem[_34898 + 132 len floor32(mem[_34899])] = mem[_34899 + 32 len floor32(mem[_34899])]
                                    mem[_34898 + floor32(mem[_34899]) + -(mem[_34899] % 32) + 164 len mem[_34899] % 32] = mem[_34899 + -(mem[_34899] % 32) + floor32(mem[_34899]) + 64 len mem[_34899] % 32]
                                    call stakingTokenAddress.mem[_34898 + 132 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_34898 + 136 len _35547 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_34898 + 242 len 22]
                                    else:
                                        mem[_34898 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[_34898 + 164]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_34898 + ceil32(return_data.size) + 243 len 22]
                        else:
                            if block.timestamp < periodFinish:
                                _32651 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32651] = 30
                                mem[_32651 + 32] = 'SafeMath: subtraction overflow'
                                if lastUpdateTime > block.timestamp:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if not block.timestamp - lastUpdateTime:
                                    _33855 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33855] = 26
                                    mem[_33855 + 32] = 'SafeMath: division by zero'
                                    if not totalStakes:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _35183 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35183] = 30
                                    mem[_35183 + 32] = 'SafeMath: subtraction overflow'
                                    if t > (0 / totalStakes) + rewardPerTokenStored:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 17
                                    if not accountStakes[address(msg.sender)]:
                                        _37533 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37533] = 26
                                        mem[_37533 + 32] = 'SafeMath: division by zero'
                                        if s < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_183ddbfb[address(msg.sender)].field_512 = s
                                        sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                        sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                        if sub_183ddbfb[address(msg.sender)].field_0:
                                            if arg1 <= 0:
                                                revert with 0, 'staking 0'
                                            _40511 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = this.address
                                            mem[mem[64] + 100] = arg1
                                            _40512 = mem[64]
                                            mem[mem[64]] = 100
                                            mem[64] = mem[64] + 132
                                            mem[_40512 + 32 len 4] = unknown_0x23b872dd(?????)
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            _41664 = mem[_40512]
                                            mem[_40511 + 132 len floor32(mem[_40512])] = mem[_40512 + 32 len floor32(mem[_40512])]
                                            mem[_40511 + floor32(mem[_40512]) + -(mem[_40512] % 32) + 164 len mem[_40512] % 32] = mem[_40512 + -(mem[_40512] % 32) + floor32(mem[_40512]) + 64 len mem[_40512] % 32]
                                            call stakingTokenAddress.mem[_40511 + 132 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_40511 + 136 len _41664 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40511 + 242 len 22]
                                            else:
                                                mem[_40511 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[_40511 + 164]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40511 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                            if arg1 <= 0:
                                                revert with 0, 'staking 0'
                                            _40645 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = this.address
                                            mem[mem[64] + 100] = arg1
                                            _40646 = mem[64]
                                            mem[mem[64]] = 100
                                            mem[64] = mem[64] + 132
                                            mem[_40646 + 32 len 4] = unknown_0x23b872dd(?????)
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            _41967 = mem[_40646]
                                            mem[_40645 + 132 len floor32(mem[_40646])] = mem[_40646 + 32 len floor32(mem[_40646])]
                                            mem[_40645 + floor32(mem[_40646]) + -(mem[_40646] % 32) + 164 len mem[_40646] % 32] = mem[_40646 + -(mem[_40646] % 32) + floor32(mem[_40646]) + 64 len mem[_40646] % 32]
                                            call stakingTokenAddress.mem[_40645 + 132 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_40645 + 136 len _41967 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40645 + 242 len 22]
                                            else:
                                                mem[_40645 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[_40645 + 164]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40645 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _38008 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38008] = 26
                                        mem[_38008 + 32] = 'SafeMath: division by zero'
                                        if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                        sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                        sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                        if sub_183ddbfb[address(msg.sender)].field_0:
                                            if arg1 <= 0:
                                                revert with 0, 'staking 0'
                                            _40840 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = this.address
                                            mem[mem[64] + 100] = arg1
                                            _40841 = mem[64]
                                            mem[mem[64]] = 100
                                            mem[64] = mem[64] + 132
                                            mem[_40841 + 32 len 4] = unknown_0x23b872dd(?????)
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            _42385 = mem[_40841]
                                            mem[_40840 + 132 len floor32(mem[_40841])] = mem[_40841 + 32 len floor32(mem[_40841])]
                                            mem[_40840 + floor32(mem[_40841]) + -(mem[_40841] % 32) + 164 len mem[_40841] % 32] = mem[_40841 + -(mem[_40841] % 32) + floor32(mem[_40841]) + 64 len mem[_40841] % 32]
                                            call stakingTokenAddress.mem[_40840 + 132 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_40840 + 136 len _42385 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40840 + 242 len 22]
                                            else:
                                                mem[_40840 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[_40840 + 164]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40840 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                            if arg1 <= 0:
                                                revert with 0, 'staking 0'
                                            _41072 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = this.address
                                            mem[mem[64] + 100] = arg1
                                            _41073 = mem[64]
                                            mem[mem[64]] = 100
                                            mem[64] = mem[64] + 132
                                            mem[_41073 + 32 len 4] = unknown_0x23b872dd(?????)
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            _42794 = mem[_41073]
                                            mem[_41072 + 132 len floor32(mem[_41073])] = mem[_41073 + 32 len floor32(mem[_41073])]
                                            mem[_41072 + floor32(mem[_41073]) + -(mem[_41073] % 32) + 164 len mem[_41073] % 32] = mem[_41073 + -(mem[_41073] % 32) + floor32(mem[_41073]) + 64 len mem[_41073] % 32]
                                            call stakingTokenAddress.mem[_41072 + 132 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_41072 + 136 len _42794 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_41072 + 242 len 22]
                                            else:
                                                mem[_41072 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[_41072 + 164]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_41072 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    if (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) / block.timestamp - lastUpdateTime != rewardRate:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate):
                                        _33965 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33965] = 26
                                        mem[_33965 + 32] = 'SafeMath: division by zero'
                                        if not totalStakes:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _35539 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35539] = 30
                                        mem[_35539 + 32] = 'SafeMath: subtraction overflow'
                                        if t > (0 / totalStakes) + rewardPerTokenStored:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 17
                                        if not accountStakes[address(msg.sender)]:
                                            _38007 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38007] = 26
                                            mem[_38007 + 32] = 'SafeMath: division by zero'
                                            if s < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40835 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40836 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40836 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42379 = mem[_40836]
                                                mem[_40835 + 132 len floor32(mem[_40836])] = mem[_40836 + 32 len floor32(mem[_40836])]
                                                mem[_40835 + floor32(mem[_40836]) + -(mem[_40836] % 32) + 164 len mem[_40836] % 32] = mem[_40836 + -(mem[_40836] % 32) + floor32(mem[_40836]) + 64 len mem[_40836] % 32]
                                                call stakingTokenAddress.mem[_40835 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40835 + 136 len _42379 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40835 + 242 len 22]
                                                else:
                                                    mem[_40835 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40835 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40835 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41069 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41070 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41070 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42788 = mem[_41070]
                                                mem[_41069 + 132 len floor32(mem[_41070])] = mem[_41070 + 32 len floor32(mem[_41070])]
                                                mem[_41069 + floor32(mem[_41070]) + -(mem[_41070] % 32) + 164 len mem[_41070] % 32] = mem[_41070 + -(mem[_41070] % 32) + floor32(mem[_41070]) + 64 len mem[_41070] % 32]
                                                call stakingTokenAddress.mem[_41069 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41069 + 136 len _42788 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41069 + 242 len 22]
                                                else:
                                                    mem[_41069 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41069 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41069 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _38466 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38466] = 26
                                            mem[_38466 + 32] = 'SafeMath: division by zero'
                                            if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41338 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41339 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41339 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43306 = mem[_41339]
                                                mem[_41338 + 132 len floor32(mem[_41339])] = mem[_41339 + 32 len floor32(mem[_41339])]
                                                mem[_41338 + floor32(mem[_41339]) + -(mem[_41339] % 32) + 164 len mem[_41339] % 32] = mem[_41339 + -(mem[_41339] % 32) + floor32(mem[_41339]) + 64 len mem[_41339] % 32]
                                                call stakingTokenAddress.mem[_41338 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41338 + 136 len _43306 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41338 + 242 len 22]
                                                else:
                                                    mem[_41338 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41338 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41338 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41658 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41659 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41659 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43916 = mem[_41659]
                                                mem[_41658 + 132 len floor32(mem[_41659])] = mem[_41659 + 32 len floor32(mem[_41659])]
                                                mem[_41658 + floor32(mem[_41659]) + -(mem[_41659] % 32) + 164 len mem[_41659] % 32] = mem[_41659 + -(mem[_41659] % 32) + floor32(mem[_41659]) + 64 len mem[_41659] % 32]
                                                call stakingTokenAddress.mem[_41658 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41658 + 136 len _43916 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41658 + 242 len 22]
                                                else:
                                                    mem[_41658 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41658 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41658 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        if (10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _34111 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34111] = 26
                                        mem[_34111 + 32] = 'SafeMath: division by zero'
                                        if not totalStakes:
                                            revert with 0, 'SafeMath: division by zero'
                                        if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _35897 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35897] = 30
                                        mem[_35897 + 32] = 'SafeMath: subtraction overflow'
                                        if t > ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 17
                                        if not accountStakes[address(msg.sender)]:
                                            _38465 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38465] = 26
                                            mem[_38465 + 32] = 'SafeMath: division by zero'
                                            if s < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41333 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41334 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41334 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43300 = mem[_41334]
                                                mem[_41333 + 132 len floor32(mem[_41334])] = mem[_41334 + 32 len floor32(mem[_41334])]
                                                mem[_41333 + floor32(mem[_41334]) + -(mem[_41334] % 32) + 164 len mem[_41334] % 32] = mem[_41334 + -(mem[_41334] % 32) + floor32(mem[_41334]) + 64 len mem[_41334] % 32]
                                                call stakingTokenAddress.mem[_41333 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41333 + 136 len _43300 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41333 + 242 len 22]
                                                else:
                                                    mem[_41333 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41333 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41333 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41655 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41656 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41656 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43910 = mem[_41656]
                                                mem[_41655 + 132 len floor32(mem[_41656])] = mem[_41656 + 32 len floor32(mem[_41656])]
                                                mem[_41655 + floor32(mem[_41656]) + -(mem[_41656] % 32) + 164 len mem[_41656] % 32] = mem[_41656 + -(mem[_41656] % 32) + floor32(mem[_41656]) + 64 len mem[_41656] % 32]
                                                call stakingTokenAddress.mem[_41655 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41655 + 136 len _43910 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41655 + 242 len 22]
                                                else:
                                                    mem[_41655 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41655 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41655 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored - t:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39011 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39011] = 26
                                            mem[_39011 + 32] = 'SafeMath: division by zero'
                                            if s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41959 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41960 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41960 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _44540 = mem[_41960]
                                                mem[_41959 + 132 len floor32(mem[_41960])] = mem[_41960 + 32 len floor32(mem[_41960])]
                                                mem[_41959 + floor32(mem[_41960]) + -(mem[_41960] % 32) + 164 len mem[_41960] % 32] = mem[_41960 + -(mem[_41960] % 32) + floor32(mem[_41960]) + 64 len mem[_41960] % 32]
                                                call stakingTokenAddress.mem[_41959 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41959 + 136 len _44540 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41959 + 242 len 22]
                                                else:
                                                    mem[_41959 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41959 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41959 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _42373 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _42374 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_42374 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _45320 = mem[_42374]
                                                mem[_42373 + 132 len floor32(mem[_42374])] = mem[_42374 + 32 len floor32(mem[_42374])]
                                                mem[_42373 + floor32(mem[_42374]) + -(mem[_42374] % 32) + 164 len mem[_42374] % 32] = mem[_42374 + -(mem[_42374] % 32) + floor32(mem[_42374]) + 64 len mem[_42374] % 32]
                                                call stakingTokenAddress.mem[_42373 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_42373 + 136 len _45320 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_42373 + 242 len 22]
                                                else:
                                                    mem[_42373 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_42373 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_42373 + ceil32(return_data.size) + 243 len 22]
                            else:
                                _32852 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32852] = 30
                                mem[_32852 + 32] = 'SafeMath: subtraction overflow'
                                if lastUpdateTime > periodFinish:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if not periodFinish - lastUpdateTime:
                                    _33969 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33969] = 26
                                    mem[_33969 + 32] = 'SafeMath: division by zero'
                                    if not totalStakes:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _35543 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35543] = 30
                                    mem[_35543 + 32] = 'SafeMath: subtraction overflow'
                                    if t > (0 / totalStakes) + rewardPerTokenStored:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 17
                                    if not accountStakes[address(msg.sender)]:
                                        _38011 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38011] = 26
                                        mem[_38011 + 32] = 'SafeMath: division by zero'
                                        if s < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_183ddbfb[address(msg.sender)].field_512 = s
                                        sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                        sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                        if sub_183ddbfb[address(msg.sender)].field_0:
                                            if arg1 <= 0:
                                                revert with 0, 'staking 0'
                                            _40845 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = this.address
                                            mem[mem[64] + 100] = arg1
                                            _40846 = mem[64]
                                            mem[mem[64]] = 100
                                            mem[64] = mem[64] + 132
                                            mem[_40846 + 32 len 4] = unknown_0x23b872dd(?????)
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            _42403 = mem[_40846]
                                            mem[_40845 + 132 len floor32(mem[_40846])] = mem[_40846 + 32 len floor32(mem[_40846])]
                                            mem[_40845 + floor32(mem[_40846]) + -(mem[_40846] % 32) + 164 len mem[_40846] % 32] = mem[_40846 + -(mem[_40846] % 32) + floor32(mem[_40846]) + 64 len mem[_40846] % 32]
                                            call stakingTokenAddress.mem[_40845 + 132 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_40845 + 136 len _42403 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40845 + 242 len 22]
                                            else:
                                                mem[_40845 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[_40845 + 164]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40845 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                            if arg1 <= 0:
                                                revert with 0, 'staking 0'
                                            _41079 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = this.address
                                            mem[mem[64] + 100] = arg1
                                            _41080 = mem[64]
                                            mem[mem[64]] = 100
                                            mem[64] = mem[64] + 132
                                            mem[_41080 + 32 len 4] = unknown_0x23b872dd(?????)
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            _42810 = mem[_41080]
                                            mem[_41079 + 132 len floor32(mem[_41080])] = mem[_41080 + 32 len floor32(mem[_41080])]
                                            mem[_41079 + floor32(mem[_41080]) + -(mem[_41080] % 32) + 164 len mem[_41080] % 32] = mem[_41080 + -(mem[_41080] % 32) + floor32(mem[_41080]) + 64 len mem[_41080] % 32]
                                            call stakingTokenAddress.mem[_41079 + 132 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_41079 + 136 len _42810 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_41079 + 242 len 22]
                                            else:
                                                mem[_41079 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[_41079 + 164]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_41079 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _38468 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38468] = 26
                                        mem[_38468 + 32] = 'SafeMath: division by zero'
                                        if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                        sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                        sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                        if sub_183ddbfb[address(msg.sender)].field_0:
                                            if arg1 <= 0:
                                                revert with 0, 'staking 0'
                                            _41348 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = this.address
                                            mem[mem[64] + 100] = arg1
                                            _41349 = mem[64]
                                            mem[mem[64]] = 100
                                            mem[64] = mem[64] + 132
                                            mem[_41349 + 32 len 4] = unknown_0x23b872dd(?????)
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            _43330 = mem[_41349]
                                            mem[_41348 + 132 len floor32(mem[_41349])] = mem[_41349 + 32 len floor32(mem[_41349])]
                                            mem[_41348 + floor32(mem[_41349]) + -(mem[_41349] % 32) + 164 len mem[_41349] % 32] = mem[_41349 + -(mem[_41349] % 32) + floor32(mem[_41349]) + 64 len mem[_41349] % 32]
                                            call stakingTokenAddress.mem[_41348 + 132 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_41348 + 136 len _43330 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_41348 + 242 len 22]
                                            else:
                                                mem[_41348 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[_41348 + 164]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_41348 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                            if arg1 <= 0:
                                                revert with 0, 'staking 0'
                                            _41674 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = this.address
                                            mem[mem[64] + 100] = arg1
                                            _41675 = mem[64]
                                            mem[mem[64]] = 100
                                            mem[64] = mem[64] + 132
                                            mem[_41675 + 32 len 4] = unknown_0x23b872dd(?????)
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            _43944 = mem[_41675]
                                            mem[_41674 + 132 len floor32(mem[_41675])] = mem[_41675 + 32 len floor32(mem[_41675])]
                                            mem[_41674 + floor32(mem[_41675]) + -(mem[_41675] % 32) + 164 len mem[_41675] % 32] = mem[_41675 + -(mem[_41675] % 32) + floor32(mem[_41675]) + 64 len mem[_41675] % 32]
                                            call stakingTokenAddress.mem[_41674 + 132 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_41674 + 136 len _43944 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_41674 + 242 len 22]
                                            else:
                                                mem[_41674 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[_41674 + 164]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_41674 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    if (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) / periodFinish - lastUpdateTime != rewardRate:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not (periodFinish * rewardRate) - (lastUpdateTime * rewardRate):
                                        _34116 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34116] = 26
                                        mem[_34116 + 32] = 'SafeMath: division by zero'
                                        if not totalStakes:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _35903 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35903] = 30
                                        mem[_35903 + 32] = 'SafeMath: subtraction overflow'
                                        if t > (0 / totalStakes) + rewardPerTokenStored:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 17
                                        if not accountStakes[address(msg.sender)]:
                                            _38467 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38467] = 26
                                            mem[_38467 + 32] = 'SafeMath: division by zero'
                                            if s < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41343 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41344 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41344 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43324 = mem[_41344]
                                                mem[_41343 + 132 len floor32(mem[_41344])] = mem[_41344 + 32 len floor32(mem[_41344])]
                                                mem[_41343 + floor32(mem[_41344]) + -(mem[_41344] % 32) + 164 len mem[_41344] % 32] = mem[_41344 + -(mem[_41344] % 32) + floor32(mem[_41344]) + 64 len mem[_41344] % 32]
                                                call stakingTokenAddress.mem[_41343 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41343 + 136 len _43324 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41343 + 242 len 22]
                                                else:
                                                    mem[_41343 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41343 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41343 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41671 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41672 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41672 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43938 = mem[_41672]
                                                mem[_41671 + 132 len floor32(mem[_41672])] = mem[_41672 + 32 len floor32(mem[_41672])]
                                                mem[_41671 + floor32(mem[_41672]) + -(mem[_41672] % 32) + 164 len mem[_41672] % 32] = mem[_41672 + -(mem[_41672] % 32) + floor32(mem[_41672]) + 64 len mem[_41672] % 32]
                                                call stakingTokenAddress.mem[_41671 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41671 + 136 len _43938 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41671 + 242 len 22]
                                                else:
                                                    mem[_41671 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41671 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41671 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39013 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39013] = 26
                                            mem[_39013 + 32] = 'SafeMath: division by zero'
                                            if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41975 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41976 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41976 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _44570 = mem[_41976]
                                                mem[_41975 + 132 len floor32(mem[_41976])] = mem[_41976 + 32 len floor32(mem[_41976])]
                                                mem[_41975 + floor32(mem[_41976]) + -(mem[_41976] % 32) + 164 len mem[_41976] % 32] = mem[_41976 + -(mem[_41976] % 32) + floor32(mem[_41976]) + 64 len mem[_41976] % 32]
                                                call stakingTokenAddress.mem[_41975 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41975 + 136 len _44570 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41975 + 242 len 22]
                                                else:
                                                    mem[_41975 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41975 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41975 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _42397 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _42398 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_42398 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _45358 = mem[_42398]
                                                mem[_42397 + 132 len floor32(mem[_42398])] = mem[_42398 + 32 len floor32(mem[_42398])]
                                                mem[_42397 + floor32(mem[_42398]) + -(mem[_42398] % 32) + 164 len mem[_42398] % 32] = mem[_42398 + -(mem[_42398] % 32) + floor32(mem[_42398]) + 64 len mem[_42398] % 32]
                                                call stakingTokenAddress.mem[_42397 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_42397 + 136 len _45358 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_42397 + 242 len 22]
                                                else:
                                                    mem[_42397 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_42397 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_42397 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        if (10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _34300 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34300] = 26
                                        mem[_34300 + 32] = 'SafeMath: division by zero'
                                        if not totalStakes:
                                            revert with 0, 'SafeMath: division by zero'
                                        if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _36414 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36414] = 30
                                        mem[_36414 + 32] = 'SafeMath: subtraction overflow'
                                        if t > ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 17
                                        if not accountStakes[address(msg.sender)]:
                                            _39012 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39012] = 26
                                            mem[_39012 + 32] = 'SafeMath: division by zero'
                                            if s < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41970 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41971 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41971 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _44564 = mem[_41971]
                                                mem[_41970 + 132 len floor32(mem[_41971])] = mem[_41971 + 32 len floor32(mem[_41971])]
                                                mem[_41970 + floor32(mem[_41971]) + -(mem[_41971] % 32) + 164 len mem[_41971] % 32] = mem[_41971 + -(mem[_41971] % 32) + floor32(mem[_41971]) + 64 len mem[_41971] % 32]
                                                call stakingTokenAddress.mem[_41970 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41970 + 136 len _44564 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41970 + 242 len 22]
                                                else:
                                                    mem[_41970 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41970 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41970 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _42394 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _42395 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_42395 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _45352 = mem[_42395]
                                                mem[_42394 + 132 len floor32(mem[_42395])] = mem[_42395 + 32 len floor32(mem[_42395])]
                                                mem[_42394 + floor32(mem[_42395]) + -(mem[_42395] % 32) + 164 len mem[_42395] % 32] = mem[_42395 + -(mem[_42395] % 32) + floor32(mem[_42395]) + 64 len mem[_42395] % 32]
                                                call stakingTokenAddress.mem[_42394 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_42394 + 136 len _45352 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_42394 + 242 len 22]
                                                else:
                                                    mem[_42394 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_42394 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_42394 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored - t:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39655 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39655] = 26
                                            mem[_39655 + 32] = 'SafeMath: division by zero'
                                            if s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _42802 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _42803 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_42803 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _46108 = mem[_42803]
                                                mem[_42802 + 132 len floor32(mem[_42803])] = mem[_42803 + 32 len floor32(mem[_42803])]
                                                mem[_42802 + floor32(mem[_42803]) + -(mem[_42803] % 32) + 164 len mem[_42803] % 32] = mem[_42803 + -(mem[_42803] % 32) + floor32(mem[_42803]) + 64 len mem[_42803] % 32]
                                                call stakingTokenAddress.mem[_42802 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_42802 + 136 len _46108 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_42802 + 242 len 22]
                                                else:
                                                    mem[_42802 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_42802 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_42802 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _43318 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _43319 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_43319 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _46927 = mem[_43319]
                                                mem[_43318 + 132 len floor32(mem[_43319])] = mem[_43319 + 32 len floor32(mem[_43319])]
                                                mem[_43318 + floor32(mem[_43319]) + -(mem[_43319] % 32) + 164 len mem[_43319] % 32] = mem[_43319 + -(mem[_43319] % 32) + floor32(mem[_43319]) + 64 len mem[_43319] % 32]
                                                call stakingTokenAddress.mem[_43318 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_43318 + 136 len _46927 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_43318 + 242 len 22]
                                                else:
                                                    mem[_43318 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_43318 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_43318 + ceil32(return_data.size) + 243 len 22]
                else:
                    lastUpdateTime = periodFinish
                    if not msg.sender:
                        if arg1 <= 0:
                            revert with 0, 'staking 0'
                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                            revert with 0, 'SafeERC20: call to non-contract'
                        if not ext_code.hash(stakingTokenAddress):
                            revert with 0, 'SafeERC20: call to non-contract'
                        mem[356 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg1) >> 32
                        mem[480 len 4] = uint32(arg1)
                        call stakingTokenAddress with:
                             gas gas_remaining wei
                            args Mask(224, 32, arg1) << 480, mem[452 len 4]
                        if not return_data.size:
                            require not ext_call.success
                            revert with 0, 'SafeERC20: low-level call failed'
                        mem[388 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            if not mem[388]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[ceil32(return_data.size) + 467 len 22]
                    else:
                        mem[224] = 0
                        mem[256] = 0
                        mem[288] = 0
                        mem[320] = 0
                        mem[0] = msg.sender
                        mem[32] = 16
                        mem[64] = 480
                        mem[352] = sub_183ddbfb[address(msg.sender)].field_0
                        mem[384] = sub_183ddbfb[address(msg.sender)].field_256
                        mem[416] = sub_183ddbfb[address(msg.sender)].field_512
                        mem[448] = sub_183ddbfb[address(msg.sender)].field_768
                        idx = sub_183ddbfb[address(msg.sender)].field_768
                        s = sub_183ddbfb[address(msg.sender)].field_512
                        t = sub_183ddbfb[address(msg.sender)].field_256
                        while idx < sub_e7690c44:
                            require idx < sub_155b0a71.length
                            mem[0] = 15
                            if not t:
                                _32484 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32484] = 26
                                mem[_32484 + 32] = 'SafeMath: division by zero'
                                require idx < sub_155b0a71.length
                                mem[0] = 15
                                if not s:
                                    _33718 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33718] = 26
                                    mem[_33718 + 32] = 'SafeMath: division by zero'
                                    idx = idx + 1
                                    s = 0
                                    t = 0
                                    continue 
                                if sub_155b0a71[idx] * s / s != sub_155b0a71[idx]:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _33802 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33802] = 26
                                mem[_33802 + 32] = 'SafeMath: division by zero'
                                idx = idx + 1
                                s = sub_155b0a71[idx] * s / 10^18
                                t = 0
                                continue 
                            if sub_155b0a71[idx] * t / t != sub_155b0a71[idx]:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _32608 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32608] = 26
                            mem[_32608 + 32] = 'SafeMath: division by zero'
                            require idx < sub_155b0a71.length
                            mem[0] = 15
                            if not s:
                                _33801 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33801] = 26
                                mem[_33801 + 32] = 'SafeMath: division by zero'
                                idx = idx + 1
                                s = 0
                                t = sub_155b0a71[idx] * t / 10^18
                                continue 
                            if sub_155b0a71[idx] * s / s != sub_155b0a71[idx]:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _33822 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33822] = 26
                            mem[_33822 + 32] = 'SafeMath: division by zero'
                            idx = idx + 1
                            s = sub_155b0a71[idx] * s / 10^18
                            t = sub_155b0a71[idx] * t / 10^18
                            continue 
                        if 0 == totalStakes:
                            _32412 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32412] = 30
                            mem[_32412 + 32] = 'SafeMath: subtraction overflow'
                            if t > rewardPerTokenStored:
                                revert with 0, 'SafeMath: subtraction overflow'
                            mem[0] = msg.sender
                            mem[32] = 17
                            if not accountStakes[address(msg.sender)]:
                                _33397 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33397] = 26
                                mem[_33397 + 32] = 'SafeMath: division by zero'
                                if s < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                if sub_183ddbfb[address(msg.sender)].field_0:
                                    if arg1 <= 0:
                                        revert with 0, 'staking 0'
                                    _34446 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = this.address
                                    mem[mem[64] + 100] = arg1
                                    _34447 = mem[64]
                                    mem[mem[64]] = 100
                                    mem[64] = mem[64] + 132
                                    mem[_34447 + 32 len 4] = unknown_0x23b872dd(?????)
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    _35088 = mem[_34447]
                                    mem[_34446 + 132 len floor32(mem[_34447])] = mem[_34447 + 32 len floor32(mem[_34447])]
                                    mem[_34446 + floor32(mem[_34447]) + -(mem[_34447] % 32) + 164 len mem[_34447] % 32] = mem[_34447 + -(mem[_34447] % 32) + floor32(mem[_34447]) + 64 len mem[_34447] % 32]
                                    call stakingTokenAddress.mem[_34446 + 132 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_34446 + 136 len _35088 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_34446 + 242 len 22]
                                    else:
                                        mem[_34446 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[_34446 + 164]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_34446 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                    if arg1 <= 0:
                                        revert with 0, 'staking 0'
                                    _34634 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = this.address
                                    mem[mem[64] + 100] = arg1
                                    _34635 = mem[64]
                                    mem[mem[64]] = 100
                                    mem[64] = mem[64] + 132
                                    mem[_34635 + 32 len 4] = unknown_0x23b872dd(?????)
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    _35194 = mem[_34635]
                                    mem[_34634 + 132 len floor32(mem[_34635])] = mem[_34635 + 32 len floor32(mem[_34635])]
                                    mem[_34634 + floor32(mem[_34635]) + -(mem[_34635] % 32) + 164 len mem[_34635] % 32] = mem[_34635 + -(mem[_34635] % 32) + floor32(mem[_34635]) + 64 len mem[_34635] % 32]
                                    call stakingTokenAddress.mem[_34634 + 132 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_34634 + 136 len _35194 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_34634 + 242 len 22]
                                    else:
                                        mem[_34634 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[_34634 + 164]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_34634 + ceil32(return_data.size) + 243 len 22]
                            else:
                                if (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != rewardPerTokenStored - t:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _33650 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33650] = 26
                                mem[_33650 + 32] = 'SafeMath: division by zero'
                                if s + ((rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_183ddbfb[address(msg.sender)].field_512 = s + ((rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                if sub_183ddbfb[address(msg.sender)].field_0:
                                    if arg1 <= 0:
                                        revert with 0, 'staking 0'
                                    _34768 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = this.address
                                    mem[mem[64] + 100] = arg1
                                    _34769 = mem[64]
                                    mem[mem[64]] = 100
                                    mem[64] = mem[64] + 132
                                    mem[_34769 + 32 len 4] = unknown_0x23b872dd(?????)
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    _35348 = mem[_34769]
                                    mem[_34768 + 132 len floor32(mem[_34769])] = mem[_34769 + 32 len floor32(mem[_34769])]
                                    mem[_34768 + floor32(mem[_34769]) + -(mem[_34769] % 32) + 164 len mem[_34769] % 32] = mem[_34769 + -(mem[_34769] % 32) + floor32(mem[_34769]) + 64 len mem[_34769] % 32]
                                    call stakingTokenAddress.mem[_34768 + 132 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_34768 + 136 len _35348 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_34768 + 242 len 22]
                                    else:
                                        mem[_34768 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[_34768 + 164]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_34768 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                    if arg1 <= 0:
                                        revert with 0, 'staking 0'
                                    _34908 = mem[64]
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = this.address
                                    mem[mem[64] + 100] = arg1
                                    _34909 = mem[64]
                                    mem[mem[64]] = 100
                                    mem[64] = mem[64] + 132
                                    mem[_34909 + 32 len 4] = unknown_0x23b872dd(?????)
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    if not ext_code.hash(stakingTokenAddress):
                                        revert with 0, 'SafeERC20: call to non-contract'
                                    _35563 = mem[_34909]
                                    mem[_34908 + 132 len floor32(mem[_34909])] = mem[_34909 + 32 len floor32(mem[_34909])]
                                    mem[_34908 + floor32(mem[_34909]) + -(mem[_34909] % 32) + 164 len mem[_34909] % 32] = mem[_34909 + -(mem[_34909] % 32) + floor32(mem[_34909]) + 64 len mem[_34909] % 32]
                                    call stakingTokenAddress.mem[_34908 + 132 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_34908 + 136 len _35563 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_34908 + 242 len 22]
                                    else:
                                        mem[_34908 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[_34908 + 164]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[_34908 + ceil32(return_data.size) + 243 len 22]
                        else:
                            if block.timestamp < periodFinish:
                                _32654 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32654] = 30
                                mem[_32654 + 32] = 'SafeMath: subtraction overflow'
                                if lastUpdateTime > block.timestamp:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if not block.timestamp - lastUpdateTime:
                                    _33858 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33858] = 26
                                    mem[_33858 + 32] = 'SafeMath: division by zero'
                                    if not totalStakes:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _35190 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35190] = 30
                                    mem[_35190 + 32] = 'SafeMath: subtraction overflow'
                                    if t > (0 / totalStakes) + rewardPerTokenStored:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 17
                                    if not accountStakes[address(msg.sender)]:
                                        _37548 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37548] = 26
                                        mem[_37548 + 32] = 'SafeMath: division by zero'
                                        if s < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_183ddbfb[address(msg.sender)].field_512 = s
                                        sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                        sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                        if sub_183ddbfb[address(msg.sender)].field_0:
                                            if arg1 <= 0:
                                                revert with 0, 'staking 0'
                                            _40516 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = this.address
                                            mem[mem[64] + 100] = arg1
                                            _40517 = mem[64]
                                            mem[mem[64]] = 100
                                            mem[64] = mem[64] + 132
                                            mem[_40517 + 32 len 4] = unknown_0x23b872dd(?????)
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            _41688 = mem[_40517]
                                            mem[_40516 + 132 len floor32(mem[_40517])] = mem[_40517 + 32 len floor32(mem[_40517])]
                                            mem[_40516 + floor32(mem[_40517]) + -(mem[_40517] % 32) + 164 len mem[_40517] % 32] = mem[_40517 + -(mem[_40517] % 32) + floor32(mem[_40517]) + 64 len mem[_40517] % 32]
                                            call stakingTokenAddress.mem[_40516 + 132 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_40516 + 136 len _41688 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40516 + 242 len 22]
                                            else:
                                                mem[_40516 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[_40516 + 164]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40516 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                            if arg1 <= 0:
                                                revert with 0, 'staking 0'
                                            _40656 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = this.address
                                            mem[mem[64] + 100] = arg1
                                            _40657 = mem[64]
                                            mem[mem[64]] = 100
                                            mem[64] = mem[64] + 132
                                            mem[_40657 + 32 len 4] = unknown_0x23b872dd(?????)
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            _41988 = mem[_40657]
                                            mem[_40656 + 132 len floor32(mem[_40657])] = mem[_40657 + 32 len floor32(mem[_40657])]
                                            mem[_40656 + floor32(mem[_40657]) + -(mem[_40657] % 32) + 164 len mem[_40657] % 32] = mem[_40657 + -(mem[_40657] % 32) + floor32(mem[_40657]) + 64 len mem[_40657] % 32]
                                            call stakingTokenAddress.mem[_40656 + 132 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_40656 + 136 len _41988 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40656 + 242 len 22]
                                            else:
                                                mem[_40656 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[_40656 + 164]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40656 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _38023 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38023] = 26
                                        mem[_38023 + 32] = 'SafeMath: division by zero'
                                        if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                        sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                        sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                        if sub_183ddbfb[address(msg.sender)].field_0:
                                            if arg1 <= 0:
                                                revert with 0, 'staking 0'
                                            _40855 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = this.address
                                            mem[mem[64] + 100] = arg1
                                            _40856 = mem[64]
                                            mem[mem[64]] = 100
                                            mem[64] = mem[64] + 132
                                            mem[_40856 + 32 len 4] = unknown_0x23b872dd(?????)
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            _42418 = mem[_40856]
                                            mem[_40855 + 132 len floor32(mem[_40856])] = mem[_40856 + 32 len floor32(mem[_40856])]
                                            mem[_40855 + floor32(mem[_40856]) + -(mem[_40856] % 32) + 164 len mem[_40856] % 32] = mem[_40856 + -(mem[_40856] % 32) + floor32(mem[_40856]) + 64 len mem[_40856] % 32]
                                            call stakingTokenAddress.mem[_40855 + 132 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_40855 + 136 len _42418 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40855 + 242 len 22]
                                            else:
                                                mem[_40855 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[_40855 + 164]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40855 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                            if arg1 <= 0:
                                                revert with 0, 'staking 0'
                                            _41089 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = this.address
                                            mem[mem[64] + 100] = arg1
                                            _41090 = mem[64]
                                            mem[mem[64]] = 100
                                            mem[64] = mem[64] + 132
                                            mem[_41090 + 32 len 4] = unknown_0x23b872dd(?????)
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            _42822 = mem[_41090]
                                            mem[_41089 + 132 len floor32(mem[_41090])] = mem[_41090 + 32 len floor32(mem[_41090])]
                                            mem[_41089 + floor32(mem[_41090]) + -(mem[_41090] % 32) + 164 len mem[_41090] % 32] = mem[_41090 + -(mem[_41090] % 32) + floor32(mem[_41090]) + 64 len mem[_41090] % 32]
                                            call stakingTokenAddress.mem[_41089 + 132 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_41089 + 136 len _42822 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_41089 + 242 len 22]
                                            else:
                                                mem[_41089 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[_41089 + 164]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_41089 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    if (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) / block.timestamp - lastUpdateTime != rewardRate:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate):
                                        _33972 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33972] = 26
                                        mem[_33972 + 32] = 'SafeMath: division by zero'
                                        if not totalStakes:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _35555 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35555] = 30
                                        mem[_35555 + 32] = 'SafeMath: subtraction overflow'
                                        if t > (0 / totalStakes) + rewardPerTokenStored:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 17
                                        if not accountStakes[address(msg.sender)]:
                                            _38022 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38022] = 26
                                            mem[_38022 + 32] = 'SafeMath: division by zero'
                                            if s < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40850 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40851 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40851 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42412 = mem[_40851]
                                                mem[_40850 + 132 len floor32(mem[_40851])] = mem[_40851 + 32 len floor32(mem[_40851])]
                                                mem[_40850 + floor32(mem[_40851]) + -(mem[_40851] % 32) + 164 len mem[_40851] % 32] = mem[_40851 + -(mem[_40851] % 32) + floor32(mem[_40851]) + 64 len mem[_40851] % 32]
                                                call stakingTokenAddress.mem[_40850 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40850 + 136 len _42412 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40850 + 242 len 22]
                                                else:
                                                    mem[_40850 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40850 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40850 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41086 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41087 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41087 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42816 = mem[_41087]
                                                mem[_41086 + 132 len floor32(mem[_41087])] = mem[_41087 + 32 len floor32(mem[_41087])]
                                                mem[_41086 + floor32(mem[_41087]) + -(mem[_41087] % 32) + 164 len mem[_41087] % 32] = mem[_41087 + -(mem[_41087] % 32) + floor32(mem[_41087]) + 64 len mem[_41087] % 32]
                                                call stakingTokenAddress.mem[_41086 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41086 + 136 len _42816 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41086 + 242 len 22]
                                                else:
                                                    mem[_41086 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41086 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41086 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _38482 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38482] = 26
                                            mem[_38482 + 32] = 'SafeMath: division by zero'
                                            if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41358 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41359 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41359 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43346 = mem[_41359]
                                                mem[_41358 + 132 len floor32(mem[_41359])] = mem[_41359 + 32 len floor32(mem[_41359])]
                                                mem[_41358 + floor32(mem[_41359]) + -(mem[_41359] % 32) + 164 len mem[_41359] % 32] = mem[_41359 + -(mem[_41359] % 32) + floor32(mem[_41359]) + 64 len mem[_41359] % 32]
                                                call stakingTokenAddress.mem[_41358 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41358 + 136 len _43346 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41358 + 242 len 22]
                                                else:
                                                    mem[_41358 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41358 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41358 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41682 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41683 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41683 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43961 = mem[_41683]
                                                mem[_41682 + 132 len floor32(mem[_41683])] = mem[_41683 + 32 len floor32(mem[_41683])]
                                                mem[_41682 + floor32(mem[_41683]) + -(mem[_41683] % 32) + 164 len mem[_41683] % 32] = mem[_41683 + -(mem[_41683] % 32) + floor32(mem[_41683]) + 64 len mem[_41683] % 32]
                                                call stakingTokenAddress.mem[_41682 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41682 + 136 len _43961 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41682 + 242 len 22]
                                                else:
                                                    mem[_41682 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41682 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41682 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        if (10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _34120 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34120] = 26
                                        mem[_34120 + 32] = 'SafeMath: division by zero'
                                        if not totalStakes:
                                            revert with 0, 'SafeMath: division by zero'
                                        if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _35918 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35918] = 30
                                        mem[_35918 + 32] = 'SafeMath: subtraction overflow'
                                        if t > ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 17
                                        if not accountStakes[address(msg.sender)]:
                                            _38481 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38481] = 26
                                            mem[_38481 + 32] = 'SafeMath: division by zero'
                                            if s < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41353 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41354 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41354 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43340 = mem[_41354]
                                                mem[_41353 + 132 len floor32(mem[_41354])] = mem[_41354 + 32 len floor32(mem[_41354])]
                                                mem[_41353 + floor32(mem[_41354]) + -(mem[_41354] % 32) + 164 len mem[_41354] % 32] = mem[_41354 + -(mem[_41354] % 32) + floor32(mem[_41354]) + 64 len mem[_41354] % 32]
                                                call stakingTokenAddress.mem[_41353 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41353 + 136 len _43340 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41353 + 242 len 22]
                                                else:
                                                    mem[_41353 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41353 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41353 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41679 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41680 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41680 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43955 = mem[_41680]
                                                mem[_41679 + 132 len floor32(mem[_41680])] = mem[_41680 + 32 len floor32(mem[_41680])]
                                                mem[_41679 + floor32(mem[_41680]) + -(mem[_41680] % 32) + 164 len mem[_41680] % 32] = mem[_41680 + -(mem[_41680] % 32) + floor32(mem[_41680]) + 64 len mem[_41680] % 32]
                                                call stakingTokenAddress.mem[_41679 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41679 + 136 len _43955 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41679 + 242 len 22]
                                                else:
                                                    mem[_41679 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41679 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41679 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored - t:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39034 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39034] = 26
                                            mem[_39034 + 32] = 'SafeMath: division by zero'
                                            if s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41980 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41981 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41981 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _44585 = mem[_41981]
                                                mem[_41980 + 132 len floor32(mem[_41981])] = mem[_41981 + 32 len floor32(mem[_41981])]
                                                mem[_41980 + floor32(mem[_41981]) + -(mem[_41981] % 32) + 164 len mem[_41981] % 32] = mem[_41981 + -(mem[_41981] % 32) + floor32(mem[_41981]) + 64 len mem[_41981] % 32]
                                                call stakingTokenAddress.mem[_41980 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41980 + 136 len _44585 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41980 + 242 len 22]
                                                else:
                                                    mem[_41980 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41980 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41980 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _42406 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _42407 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_42407 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _45380 = mem[_42407]
                                                mem[_42406 + 132 len floor32(mem[_42407])] = mem[_42407 + 32 len floor32(mem[_42407])]
                                                mem[_42406 + floor32(mem[_42407]) + -(mem[_42407] % 32) + 164 len mem[_42407] % 32] = mem[_42407 + -(mem[_42407] % 32) + floor32(mem[_42407]) + 64 len mem[_42407] % 32]
                                                call stakingTokenAddress.mem[_42406 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_42406 + 136 len _45380 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_42406 + 242 len 22]
                                                else:
                                                    mem[_42406 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_42406 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_42406 + ceil32(return_data.size) + 243 len 22]
                            else:
                                _32858 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32858] = 30
                                mem[_32858 + 32] = 'SafeMath: subtraction overflow'
                                if lastUpdateTime > periodFinish:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if not periodFinish - lastUpdateTime:
                                    _33976 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33976] = 26
                                    mem[_33976 + 32] = 'SafeMath: division by zero'
                                    if not totalStakes:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _35559 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35559] = 30
                                    mem[_35559 + 32] = 'SafeMath: subtraction overflow'
                                    if t > (0 / totalStakes) + rewardPerTokenStored:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 17
                                    if not accountStakes[address(msg.sender)]:
                                        _38026 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38026] = 26
                                        mem[_38026 + 32] = 'SafeMath: division by zero'
                                        if s < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_183ddbfb[address(msg.sender)].field_512 = s
                                        sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                        sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                        if sub_183ddbfb[address(msg.sender)].field_0:
                                            if arg1 <= 0:
                                                revert with 0, 'staking 0'
                                            _40860 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = this.address
                                            mem[mem[64] + 100] = arg1
                                            _40861 = mem[64]
                                            mem[mem[64]] = 100
                                            mem[64] = mem[64] + 132
                                            mem[_40861 + 32 len 4] = unknown_0x23b872dd(?????)
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            _42436 = mem[_40861]
                                            mem[_40860 + 132 len floor32(mem[_40861])] = mem[_40861 + 32 len floor32(mem[_40861])]
                                            mem[_40860 + floor32(mem[_40861]) + -(mem[_40861] % 32) + 164 len mem[_40861] % 32] = mem[_40861 + -(mem[_40861] % 32) + floor32(mem[_40861]) + 64 len mem[_40861] % 32]
                                            call stakingTokenAddress.mem[_40860 + 132 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_40860 + 136 len _42436 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40860 + 242 len 22]
                                            else:
                                                mem[_40860 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[_40860 + 164]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_40860 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                            if arg1 <= 0:
                                                revert with 0, 'staking 0'
                                            _41096 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = this.address
                                            mem[mem[64] + 100] = arg1
                                            _41097 = mem[64]
                                            mem[mem[64]] = 100
                                            mem[64] = mem[64] + 132
                                            mem[_41097 + 32 len 4] = unknown_0x23b872dd(?????)
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            _42838 = mem[_41097]
                                            mem[_41096 + 132 len floor32(mem[_41097])] = mem[_41097 + 32 len floor32(mem[_41097])]
                                            mem[_41096 + floor32(mem[_41097]) + -(mem[_41097] % 32) + 164 len mem[_41097] % 32] = mem[_41097 + -(mem[_41097] % 32) + floor32(mem[_41097]) + 64 len mem[_41097] % 32]
                                            call stakingTokenAddress.mem[_41096 + 132 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_41096 + 136 len _42838 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_41096 + 242 len 22]
                                            else:
                                                mem[_41096 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[_41096 + 164]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_41096 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _38484 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38484] = 26
                                        mem[_38484 + 32] = 'SafeMath: division by zero'
                                        if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                        sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                        sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                        if sub_183ddbfb[address(msg.sender)].field_0:
                                            if arg1 <= 0:
                                                revert with 0, 'staking 0'
                                            _41368 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = this.address
                                            mem[mem[64] + 100] = arg1
                                            _41369 = mem[64]
                                            mem[mem[64]] = 100
                                            mem[64] = mem[64] + 132
                                            mem[_41369 + 32 len 4] = unknown_0x23b872dd(?????)
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            _43370 = mem[_41369]
                                            mem[_41368 + 132 len floor32(mem[_41369])] = mem[_41369 + 32 len floor32(mem[_41369])]
                                            mem[_41368 + floor32(mem[_41369]) + -(mem[_41369] % 32) + 164 len mem[_41369] % 32] = mem[_41369 + -(mem[_41369] % 32) + floor32(mem[_41369]) + 64 len mem[_41369] % 32]
                                            call stakingTokenAddress.mem[_41368 + 132 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_41368 + 136 len _43370 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_41368 + 242 len 22]
                                            else:
                                                mem[_41368 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[_41368 + 164]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_41368 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                            if arg1 <= 0:
                                                revert with 0, 'staking 0'
                                            _41698 = mem[64]
                                            mem[mem[64] + 36] = msg.sender
                                            mem[mem[64] + 68] = this.address
                                            mem[mem[64] + 100] = arg1
                                            _41699 = mem[64]
                                            mem[mem[64]] = 100
                                            mem[64] = mem[64] + 132
                                            mem[_41699 + 32 len 4] = unknown_0x23b872dd(?????)
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            if not ext_code.hash(stakingTokenAddress):
                                                revert with 0, 'SafeERC20: call to non-contract'
                                            _43989 = mem[_41699]
                                            mem[_41698 + 132 len floor32(mem[_41699])] = mem[_41699 + 32 len floor32(mem[_41699])]
                                            mem[_41698 + floor32(mem[_41699]) + -(mem[_41699] % 32) + 164 len mem[_41699] % 32] = mem[_41699 + -(mem[_41699] % 32) + floor32(mem[_41699]) + 64 len mem[_41699] % 32]
                                            call stakingTokenAddress.mem[_41698 + 132 len 4] with:
                                                 gas gas_remaining wei
                                                args mem[_41698 + 136 len _43989 - 4]
                                            if not return_data.size:
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if mem[96]:
                                                    require mem[96] >= 32
                                                    if not mem[128]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_41698 + 242 len 22]
                                            else:
                                                mem[_41698 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                if not ext_call.success:
                                                    revert with 0, 'SafeERC20: low-level call failed'
                                                if return_data.size:
                                                    require return_data.size >= 32
                                                    if not mem[_41698 + 164]:
                                                        revert with 0, 
                                                                    32,
                                                                    42,
                                                                    0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                    mem[_41698 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    if (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) / periodFinish - lastUpdateTime != rewardRate:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not (periodFinish * rewardRate) - (lastUpdateTime * rewardRate):
                                        _34125 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34125] = 26
                                        mem[_34125 + 32] = 'SafeMath: division by zero'
                                        if not totalStakes:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _35924 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35924] = 30
                                        mem[_35924 + 32] = 'SafeMath: subtraction overflow'
                                        if t > (0 / totalStakes) + rewardPerTokenStored:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 17
                                        if not accountStakes[address(msg.sender)]:
                                            _38483 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38483] = 26
                                            mem[_38483 + 32] = 'SafeMath: division by zero'
                                            if s < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41363 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41364 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41364 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43364 = mem[_41364]
                                                mem[_41363 + 132 len floor32(mem[_41364])] = mem[_41364 + 32 len floor32(mem[_41364])]
                                                mem[_41363 + floor32(mem[_41364]) + -(mem[_41364] % 32) + 164 len mem[_41364] % 32] = mem[_41364 + -(mem[_41364] % 32) + floor32(mem[_41364]) + 64 len mem[_41364] % 32]
                                                call stakingTokenAddress.mem[_41363 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41363 + 136 len _43364 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41363 + 242 len 22]
                                                else:
                                                    mem[_41363 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41363 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41363 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41695 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41696 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41696 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43983 = mem[_41696]
                                                mem[_41695 + 132 len floor32(mem[_41696])] = mem[_41696 + 32 len floor32(mem[_41696])]
                                                mem[_41695 + floor32(mem[_41696]) + -(mem[_41696] % 32) + 164 len mem[_41696] % 32] = mem[_41696 + -(mem[_41696] % 32) + floor32(mem[_41696]) + 64 len mem[_41696] % 32]
                                                call stakingTokenAddress.mem[_41695 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41695 + 136 len _43983 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41695 + 242 len 22]
                                                else:
                                                    mem[_41695 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41695 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41695 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39036 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39036] = 26
                                            mem[_39036 + 32] = 'SafeMath: division by zero'
                                            if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41996 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41997 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41997 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _44615 = mem[_41997]
                                                mem[_41996 + 132 len floor32(mem[_41997])] = mem[_41997 + 32 len floor32(mem[_41997])]
                                                mem[_41996 + floor32(mem[_41997]) + -(mem[_41997] % 32) + 164 len mem[_41997] % 32] = mem[_41997 + -(mem[_41997] % 32) + floor32(mem[_41997]) + 64 len mem[_41997] % 32]
                                                call stakingTokenAddress.mem[_41996 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41996 + 136 len _44615 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41996 + 242 len 22]
                                                else:
                                                    mem[_41996 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41996 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41996 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _42430 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _42431 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_42431 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _45418 = mem[_42431]
                                                mem[_42430 + 132 len floor32(mem[_42431])] = mem[_42431 + 32 len floor32(mem[_42431])]
                                                mem[_42430 + floor32(mem[_42431]) + -(mem[_42431] % 32) + 164 len mem[_42431] % 32] = mem[_42431 + -(mem[_42431] % 32) + floor32(mem[_42431]) + 64 len mem[_42431] % 32]
                                                call stakingTokenAddress.mem[_42430 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_42430 + 136 len _45418 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_42430 + 242 len 22]
                                                else:
                                                    mem[_42430 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_42430 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_42430 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        if (10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _34312 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34312] = 26
                                        mem[_34312 + 32] = 'SafeMath: division by zero'
                                        if not totalStakes:
                                            revert with 0, 'SafeMath: division by zero'
                                        if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _36437 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36437] = 30
                                        mem[_36437 + 32] = 'SafeMath: subtraction overflow'
                                        if t > ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 17
                                        if not accountStakes[address(msg.sender)]:
                                            _39035 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39035] = 26
                                            mem[_39035 + 32] = 'SafeMath: division by zero'
                                            if s < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41991 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41992 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41992 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _44609 = mem[_41992]
                                                mem[_41991 + 132 len floor32(mem[_41992])] = mem[_41992 + 32 len floor32(mem[_41992])]
                                                mem[_41991 + floor32(mem[_41992]) + -(mem[_41992] % 32) + 164 len mem[_41992] % 32] = mem[_41992 + -(mem[_41992] % 32) + floor32(mem[_41992]) + 64 len mem[_41992] % 32]
                                                call stakingTokenAddress.mem[_41991 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41991 + 136 len _44609 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41991 + 242 len 22]
                                                else:
                                                    mem[_41991 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41991 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41991 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _42427 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _42428 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_42428 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _45412 = mem[_42428]
                                                mem[_42427 + 132 len floor32(mem[_42428])] = mem[_42428 + 32 len floor32(mem[_42428])]
                                                mem[_42427 + floor32(mem[_42428]) + -(mem[_42428] % 32) + 164 len mem[_42428] % 32] = mem[_42428 + -(mem[_42428] % 32) + floor32(mem[_42428]) + 64 len mem[_42428] % 32]
                                                call stakingTokenAddress.mem[_42427 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_42427 + 136 len _45412 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_42427 + 242 len 22]
                                                else:
                                                    mem[_42427 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_42427 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_42427 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored - t:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _39682 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39682] = 26
                                            mem[_39682 + 32] = 'SafeMath: division by zero'
                                            if s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _42830 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _42831 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_42831 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _46160 = mem[_42831]
                                                mem[_42830 + 132 len floor32(mem[_42831])] = mem[_42831 + 32 len floor32(mem[_42831])]
                                                mem[_42830 + floor32(mem[_42831]) + -(mem[_42831] % 32) + 164 len mem[_42831] % 32] = mem[_42831 + -(mem[_42831] % 32) + floor32(mem[_42831]) + 64 len mem[_42831] % 32]
                                                call stakingTokenAddress.mem[_42830 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_42830 + 136 len _46160 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_42830 + 242 len 22]
                                                else:
                                                    mem[_42830 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_42830 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_42830 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _43358 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _43359 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_43359 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _46988 = mem[_43359]
                                                mem[_43358 + 132 len floor32(mem[_43359])] = mem[_43359 + 32 len floor32(mem[_43359])]
                                                mem[_43358 + floor32(mem[_43359]) + -(mem[_43359] % 32) + 164 len mem[_43359] % 32] = mem[_43359 + -(mem[_43359] % 32) + floor32(mem[_43359]) + 64 len mem[_43359] % 32]
                                                call stakingTokenAddress.mem[_43358 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_43358 + 136 len _46988 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_43358 + 242 len 22]
                                                else:
                                                    mem[_43358 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_43358 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_43358 + ceil32(return_data.size) + 243 len 22]
            else:
                if (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) / periodFinish - lastUpdateTime != rewardRate:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                if not (periodFinish * rewardRate) - (lastUpdateTime * rewardRate):
                    mem[160] = 26
                    mem[192] = 'SafeMath: division by zero'
                    if not totalStakes:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                        revert with 0, 'SafeMath: addition overflow'
                    rewardPerTokenStored += 0 / totalStakes
                    if block.timestamp < periodFinish:
                        lastUpdateTime = block.timestamp
                        if not msg.sender:
                            if arg1 <= 0:
                                revert with 0, 'staking 0'
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                revert with 0, 'SafeERC20: call to non-contract'
                            if not ext_code.hash(stakingTokenAddress):
                                revert with 0, 'SafeERC20: call to non-contract'
                            mem[356 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg1) >> 32
                            mem[480 len 4] = uint32(arg1)
                            call stakingTokenAddress with:
                                 gas gas_remaining wei
                                args Mask(224, 32, arg1) << 480, mem[452 len 4]
                            if not return_data.size:
                                require not ext_call.success
                                revert with 0, 'SafeERC20: low-level call failed'
                            mem[388 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[388]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[ceil32(return_data.size) + 467 len 22]
                        else:
                            mem[224] = 0
                            mem[256] = 0
                            mem[288] = 0
                            mem[320] = 0
                            mem[0] = msg.sender
                            mem[32] = 16
                            mem[64] = 480
                            mem[352] = sub_183ddbfb[address(msg.sender)].field_0
                            mem[384] = sub_183ddbfb[address(msg.sender)].field_256
                            mem[416] = sub_183ddbfb[address(msg.sender)].field_512
                            mem[448] = sub_183ddbfb[address(msg.sender)].field_768
                            idx = sub_183ddbfb[address(msg.sender)].field_768
                            s = sub_183ddbfb[address(msg.sender)].field_512
                            t = sub_183ddbfb[address(msg.sender)].field_256
                            while idx < sub_e7690c44:
                                require idx < sub_155b0a71.length
                                mem[0] = 15
                                if not t:
                                    _32469 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32469] = 26
                                    mem[_32469 + 32] = 'SafeMath: division by zero'
                                    require idx < sub_155b0a71.length
                                    mem[0] = 15
                                    if not s:
                                        _33706 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33706] = 26
                                        mem[_33706 + 32] = 'SafeMath: division by zero'
                                        idx = idx + 1
                                        s = 0
                                        t = 0
                                        continue 
                                    if sub_155b0a71[idx] * s / s != sub_155b0a71[idx]:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _33790 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33790] = 26
                                    mem[_33790 + 32] = 'SafeMath: division by zero'
                                    idx = idx + 1
                                    s = sub_155b0a71[idx] * s / 10^18
                                    t = 0
                                    continue 
                                if sub_155b0a71[idx] * t / t != sub_155b0a71[idx]:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _32590 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32590] = 26
                                mem[_32590 + 32] = 'SafeMath: division by zero'
                                require idx < sub_155b0a71.length
                                mem[0] = 15
                                if not s:
                                    _33789 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33789] = 26
                                    mem[_33789 + 32] = 'SafeMath: division by zero'
                                    idx = idx + 1
                                    s = 0
                                    t = sub_155b0a71[idx] * t / 10^18
                                    continue 
                                if sub_155b0a71[idx] * s / s != sub_155b0a71[idx]:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _33819 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33819] = 26
                                mem[_33819 + 32] = 'SafeMath: division by zero'
                                idx = idx + 1
                                s = sub_155b0a71[idx] * s / 10^18
                                t = sub_155b0a71[idx] * t / 10^18
                                continue 
                            if 0 == totalStakes:
                                _32397 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32397] = 30
                                mem[_32397 + 32] = 'SafeMath: subtraction overflow'
                                if t > rewardPerTokenStored:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 17
                                if not accountStakes[address(msg.sender)]:
                                    _33367 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33367] = 26
                                    mem[_33367 + 32] = 'SafeMath: division by zero'
                                    if s < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_183ddbfb[address(msg.sender)].field_512 = s
                                    sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                    sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                    if sub_183ddbfb[address(msg.sender)].field_0:
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _34419 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _34420 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_34420 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _35055 = mem[_34420]
                                        mem[_34419 + 132 len floor32(mem[_34420])] = mem[_34420 + 32 len floor32(mem[_34420])]
                                        mem[_34419 + floor32(mem[_34420]) + -(mem[_34420] % 32) + 164 len mem[_34420] % 32] = mem[_34420 + -(mem[_34420] % 32) + floor32(mem[_34420]) + 64 len mem[_34420] % 32]
                                        call stakingTokenAddress.mem[_34419 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_34419 + 136 len _35055 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34419 + 242 len 22]
                                        else:
                                            mem[_34419 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_34419 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34419 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _34592 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _34593 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_34593 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _35173 = mem[_34593]
                                        mem[_34592 + 132 len floor32(mem[_34593])] = mem[_34593 + 32 len floor32(mem[_34593])]
                                        mem[_34592 + floor32(mem[_34593]) + -(mem[_34593] % 32) + 164 len mem[_34593] % 32] = mem[_34593 + -(mem[_34593] % 32) + floor32(mem[_34593]) + 64 len mem[_34593] % 32]
                                        call stakingTokenAddress.mem[_34592 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_34592 + 136 len _35173 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34592 + 242 len 22]
                                        else:
                                            mem[_34592 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_34592 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34592 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    if (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != rewardPerTokenStored - t:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _33623 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33623] = 26
                                    mem[_33623 + 32] = 'SafeMath: division by zero'
                                    if s + ((rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_183ddbfb[address(msg.sender)].field_512 = s + ((rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                    sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                    sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                    if sub_183ddbfb[address(msg.sender)].field_0:
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _34741 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _34742 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_34742 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _35312 = mem[_34742]
                                        mem[_34741 + 132 len floor32(mem[_34742])] = mem[_34742 + 32 len floor32(mem[_34742])]
                                        mem[_34741 + floor32(mem[_34742]) + -(mem[_34742] % 32) + 164 len mem[_34742] % 32] = mem[_34742 + -(mem[_34742] % 32) + floor32(mem[_34742]) + 64 len mem[_34742] % 32]
                                        call stakingTokenAddress.mem[_34741 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_34741 + 136 len _35312 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34741 + 242 len 22]
                                        else:
                                            mem[_34741 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_34741 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34741 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _34878 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _34879 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_34879 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _35515 = mem[_34879]
                                        mem[_34878 + 132 len floor32(mem[_34879])] = mem[_34879 + 32 len floor32(mem[_34879])]
                                        mem[_34878 + floor32(mem[_34879]) + -(mem[_34879] % 32) + 164 len mem[_34879] % 32] = mem[_34879 + -(mem[_34879] % 32) + floor32(mem[_34879]) + 64 len mem[_34879] % 32]
                                        call stakingTokenAddress.mem[_34878 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_34878 + 136 len _35515 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34878 + 242 len 22]
                                        else:
                                            mem[_34878 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_34878 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34878 + ceil32(return_data.size) + 243 len 22]
                            else:
                                if block.timestamp < periodFinish:
                                    _32645 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32645] = 30
                                    mem[_32645 + 32] = 'SafeMath: subtraction overflow'
                                    if lastUpdateTime > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not block.timestamp - lastUpdateTime:
                                        _33849 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33849] = 26
                                        mem[_33849 + 32] = 'SafeMath: division by zero'
                                        if not totalStakes:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _35169 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35169] = 30
                                        mem[_35169 + 32] = 'SafeMath: subtraction overflow'
                                        if t > (0 / totalStakes) + rewardPerTokenStored:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 17
                                        if not accountStakes[address(msg.sender)]:
                                            _37503 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37503] = 26
                                            mem[_37503 + 32] = 'SafeMath: division by zero'
                                            if s < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40501 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40502 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40502 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _41616 = mem[_40502]
                                                mem[_40501 + 132 len floor32(mem[_40502])] = mem[_40502 + 32 len floor32(mem[_40502])]
                                                mem[_40501 + floor32(mem[_40502]) + -(mem[_40502] % 32) + 164 len mem[_40502] % 32] = mem[_40502 + -(mem[_40502] % 32) + floor32(mem[_40502]) + 64 len mem[_40502] % 32]
                                                call stakingTokenAddress.mem[_40501 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40501 + 136 len _41616 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40501 + 242 len 22]
                                                else:
                                                    mem[_40501 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40501 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40501 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40623 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40624 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40624 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _41925 = mem[_40624]
                                                mem[_40623 + 132 len floor32(mem[_40624])] = mem[_40624 + 32 len floor32(mem[_40624])]
                                                mem[_40623 + floor32(mem[_40624]) + -(mem[_40624] % 32) + 164 len mem[_40624] % 32] = mem[_40624 + -(mem[_40624] % 32) + floor32(mem[_40624]) + 64 len mem[_40624] % 32]
                                                call stakingTokenAddress.mem[_40623 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40623 + 136 len _41925 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40623 + 242 len 22]
                                                else:
                                                    mem[_40623 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40623 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40623 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _37978 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37978] = 26
                                            mem[_37978 + 32] = 'SafeMath: division by zero'
                                            if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40810 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40811 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40811 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42319 = mem[_40811]
                                                mem[_40810 + 132 len floor32(mem[_40811])] = mem[_40811 + 32 len floor32(mem[_40811])]
                                                mem[_40810 + floor32(mem[_40811]) + -(mem[_40811] % 32) + 164 len mem[_40811] % 32] = mem[_40811 + -(mem[_40811] % 32) + floor32(mem[_40811]) + 64 len mem[_40811] % 32]
                                                call stakingTokenAddress.mem[_40810 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40810 + 136 len _42319 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40810 + 242 len 22]
                                                else:
                                                    mem[_40810 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40810 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40810 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41038 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41039 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41039 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42738 = mem[_41039]
                                                mem[_41038 + 132 len floor32(mem[_41039])] = mem[_41039 + 32 len floor32(mem[_41039])]
                                                mem[_41038 + floor32(mem[_41039]) + -(mem[_41039] % 32) + 164 len mem[_41039] % 32] = mem[_41039 + -(mem[_41039] % 32) + floor32(mem[_41039]) + 64 len mem[_41039] % 32]
                                                call stakingTokenAddress.mem[_41038 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41038 + 136 len _42738 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41038 + 242 len 22]
                                                else:
                                                    mem[_41038 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41038 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41038 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        if (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) / block.timestamp - lastUpdateTime != rewardRate:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate):
                                            _33951 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33951] = 26
                                            mem[_33951 + 32] = 'SafeMath: division by zero'
                                            if not totalStakes:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _35507 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35507] = 30
                                            mem[_35507 + 32] = 'SafeMath: subtraction overflow'
                                            if t > (0 / totalStakes) + rewardPerTokenStored:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 17
                                            if not accountStakes[address(msg.sender)]:
                                                _37977 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37977] = 26
                                                mem[_37977 + 32] = 'SafeMath: division by zero'
                                                if s < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _40805 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _40806 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_40806 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _42313 = mem[_40806]
                                                    mem[_40805 + 132 len floor32(mem[_40806])] = mem[_40806 + 32 len floor32(mem[_40806])]
                                                    mem[_40805 + floor32(mem[_40806]) + -(mem[_40806] % 32) + 164 len mem[_40806] % 32] = mem[_40806 + -(mem[_40806] % 32) + floor32(mem[_40806]) + 64 len mem[_40806] % 32]
                                                    call stakingTokenAddress.mem[_40805 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_40805 + 136 len _42313 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_40805 + 242 len 22]
                                                    else:
                                                        mem[_40805 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_40805 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_40805 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41035 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41036 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41036 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _42732 = mem[_41036]
                                                    mem[_41035 + 132 len floor32(mem[_41036])] = mem[_41036 + 32 len floor32(mem[_41036])]
                                                    mem[_41035 + floor32(mem[_41036]) + -(mem[_41036] % 32) + 164 len mem[_41036] % 32] = mem[_41036 + -(mem[_41036] % 32) + floor32(mem[_41036]) + 64 len mem[_41036] % 32]
                                                    call stakingTokenAddress.mem[_41035 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41035 + 136 len _42732 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41035 + 242 len 22]
                                                    else:
                                                        mem[_41035 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41035 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41035 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _38434 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38434] = 26
                                                mem[_38434 + 32] = 'SafeMath: division by zero'
                                                if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41298 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41299 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41299 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43226 = mem[_41299]
                                                    mem[_41298 + 132 len floor32(mem[_41299])] = mem[_41299 + 32 len floor32(mem[_41299])]
                                                    mem[_41298 + floor32(mem[_41299]) + -(mem[_41299] % 32) + 164 len mem[_41299] % 32] = mem[_41299 + -(mem[_41299] % 32) + floor32(mem[_41299]) + 64 len mem[_41299] % 32]
                                                    call stakingTokenAddress.mem[_41298 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41298 + 136 len _43226 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41298 + 242 len 22]
                                                    else:
                                                        mem[_41298 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41298 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41298 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41610 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41611 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41611 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43826 = mem[_41611]
                                                    mem[_41610 + 132 len floor32(mem[_41611])] = mem[_41611 + 32 len floor32(mem[_41611])]
                                                    mem[_41610 + floor32(mem[_41611]) + -(mem[_41611] % 32) + 164 len mem[_41611] % 32] = mem[_41611 + -(mem[_41611] % 32) + floor32(mem[_41611]) + 64 len mem[_41611] % 32]
                                                    call stakingTokenAddress.mem[_41610 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41610 + 136 len _43826 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41610 + 242 len 22]
                                                    else:
                                                        mem[_41610 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41610 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41610 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _34093 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34093] = 26
                                            mem[_34093 + 32] = 'SafeMath: division by zero'
                                            if not totalStakes:
                                                revert with 0, 'SafeMath: division by zero'
                                            if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _35855 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35855] = 30
                                            mem[_35855 + 32] = 'SafeMath: subtraction overflow'
                                            if t > ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 17
                                            if not accountStakes[address(msg.sender)]:
                                                _38433 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38433] = 26
                                                mem[_38433 + 32] = 'SafeMath: division by zero'
                                                if s < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41293 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41294 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41294 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43220 = mem[_41294]
                                                    mem[_41293 + 132 len floor32(mem[_41294])] = mem[_41294 + 32 len floor32(mem[_41294])]
                                                    mem[_41293 + floor32(mem[_41294]) + -(mem[_41294] % 32) + 164 len mem[_41294] % 32] = mem[_41294 + -(mem[_41294] % 32) + floor32(mem[_41294]) + 64 len mem[_41294] % 32]
                                                    call stakingTokenAddress.mem[_41293 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41293 + 136 len _43220 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41293 + 242 len 22]
                                                    else:
                                                        mem[_41293 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41293 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41293 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41607 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41608 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41608 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43820 = mem[_41608]
                                                    mem[_41607 + 132 len floor32(mem[_41608])] = mem[_41608 + 32 len floor32(mem[_41608])]
                                                    mem[_41607 + floor32(mem[_41608]) + -(mem[_41608] % 32) + 164 len mem[_41608] % 32] = mem[_41608 + -(mem[_41608] % 32) + floor32(mem[_41608]) + 64 len mem[_41608] % 32]
                                                    call stakingTokenAddress.mem[_41607 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41607 + 136 len _43820 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41607 + 242 len 22]
                                                    else:
                                                        mem[_41607 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41607 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41607 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored - t:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _38965 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38965] = 26
                                                mem[_38965 + 32] = 'SafeMath: division by zero'
                                                if s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41917 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41918 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41918 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44450 = mem[_41918]
                                                    mem[_41917 + 132 len floor32(mem[_41918])] = mem[_41918 + 32 len floor32(mem[_41918])]
                                                    mem[_41917 + floor32(mem[_41918]) + -(mem[_41918] % 32) + 164 len mem[_41918] % 32] = mem[_41918 + -(mem[_41918] % 32) + floor32(mem[_41918]) + 64 len mem[_41918] % 32]
                                                    call stakingTokenAddress.mem[_41917 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41917 + 136 len _44450 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41917 + 242 len 22]
                                                    else:
                                                        mem[_41917 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41917 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41917 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _42307 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _42308 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_42308 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _45200 = mem[_42308]
                                                    mem[_42307 + 132 len floor32(mem[_42308])] = mem[_42308 + 32 len floor32(mem[_42308])]
                                                    mem[_42307 + floor32(mem[_42308]) + -(mem[_42308] % 32) + 164 len mem[_42308] % 32] = mem[_42308 + -(mem[_42308] % 32) + floor32(mem[_42308]) + 64 len mem[_42308] % 32]
                                                    call stakingTokenAddress.mem[_42307 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_42307 + 136 len _45200 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42307 + 242 len 22]
                                                    else:
                                                        mem[_42307 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_42307 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42307 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    _32840 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32840] = 30
                                    mem[_32840 + 32] = 'SafeMath: subtraction overflow'
                                    if lastUpdateTime > periodFinish:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not periodFinish - lastUpdateTime:
                                        _33955 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33955] = 26
                                        mem[_33955 + 32] = 'SafeMath: division by zero'
                                        if not totalStakes:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _35511 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35511] = 30
                                        mem[_35511 + 32] = 'SafeMath: subtraction overflow'
                                        if t > (0 / totalStakes) + rewardPerTokenStored:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 17
                                        if not accountStakes[address(msg.sender)]:
                                            _37981 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37981] = 26
                                            mem[_37981 + 32] = 'SafeMath: division by zero'
                                            if s < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40815 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40816 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40816 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42337 = mem[_40816]
                                                mem[_40815 + 132 len floor32(mem[_40816])] = mem[_40816 + 32 len floor32(mem[_40816])]
                                                mem[_40815 + floor32(mem[_40816]) + -(mem[_40816] % 32) + 164 len mem[_40816] % 32] = mem[_40816 + -(mem[_40816] % 32) + floor32(mem[_40816]) + 64 len mem[_40816] % 32]
                                                call stakingTokenAddress.mem[_40815 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40815 + 136 len _42337 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40815 + 242 len 22]
                                                else:
                                                    mem[_40815 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40815 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40815 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41045 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41046 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41046 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42754 = mem[_41046]
                                                mem[_41045 + 132 len floor32(mem[_41046])] = mem[_41046 + 32 len floor32(mem[_41046])]
                                                mem[_41045 + floor32(mem[_41046]) + -(mem[_41046] % 32) + 164 len mem[_41046] % 32] = mem[_41046 + -(mem[_41046] % 32) + floor32(mem[_41046]) + 64 len mem[_41046] % 32]
                                                call stakingTokenAddress.mem[_41045 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41045 + 136 len _42754 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41045 + 242 len 22]
                                                else:
                                                    mem[_41045 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41045 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41045 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _38436 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38436] = 26
                                            mem[_38436 + 32] = 'SafeMath: division by zero'
                                            if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41308 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41309 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41309 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43250 = mem[_41309]
                                                mem[_41308 + 132 len floor32(mem[_41309])] = mem[_41309 + 32 len floor32(mem[_41309])]
                                                mem[_41308 + floor32(mem[_41309]) + -(mem[_41309] % 32) + 164 len mem[_41309] % 32] = mem[_41309 + -(mem[_41309] % 32) + floor32(mem[_41309]) + 64 len mem[_41309] % 32]
                                                call stakingTokenAddress.mem[_41308 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41308 + 136 len _43250 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41308 + 242 len 22]
                                                else:
                                                    mem[_41308 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41308 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41308 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41626 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41627 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41627 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43854 = mem[_41627]
                                                mem[_41626 + 132 len floor32(mem[_41627])] = mem[_41627 + 32 len floor32(mem[_41627])]
                                                mem[_41626 + floor32(mem[_41627]) + -(mem[_41627] % 32) + 164 len mem[_41627] % 32] = mem[_41627 + -(mem[_41627] % 32) + floor32(mem[_41627]) + 64 len mem[_41627] % 32]
                                                call stakingTokenAddress.mem[_41626 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41626 + 136 len _43854 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41626 + 242 len 22]
                                                else:
                                                    mem[_41626 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41626 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41626 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        if (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) / periodFinish - lastUpdateTime != rewardRate:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not (periodFinish * rewardRate) - (lastUpdateTime * rewardRate):
                                            _34098 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34098] = 26
                                            mem[_34098 + 32] = 'SafeMath: division by zero'
                                            if not totalStakes:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _35861 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35861] = 30
                                            mem[_35861 + 32] = 'SafeMath: subtraction overflow'
                                            if t > (0 / totalStakes) + rewardPerTokenStored:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 17
                                            if not accountStakes[address(msg.sender)]:
                                                _38435 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38435] = 26
                                                mem[_38435 + 32] = 'SafeMath: division by zero'
                                                if s < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41303 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41304 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41304 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43244 = mem[_41304]
                                                    mem[_41303 + 132 len floor32(mem[_41304])] = mem[_41304 + 32 len floor32(mem[_41304])]
                                                    mem[_41303 + floor32(mem[_41304]) + -(mem[_41304] % 32) + 164 len mem[_41304] % 32] = mem[_41304 + -(mem[_41304] % 32) + floor32(mem[_41304]) + 64 len mem[_41304] % 32]
                                                    call stakingTokenAddress.mem[_41303 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41303 + 136 len _43244 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41303 + 242 len 22]
                                                    else:
                                                        mem[_41303 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41303 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41303 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41623 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41624 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41624 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43848 = mem[_41624]
                                                    mem[_41623 + 132 len floor32(mem[_41624])] = mem[_41624 + 32 len floor32(mem[_41624])]
                                                    mem[_41623 + floor32(mem[_41624]) + -(mem[_41624] % 32) + 164 len mem[_41624] % 32] = mem[_41624 + -(mem[_41624] % 32) + floor32(mem[_41624]) + 64 len mem[_41624] % 32]
                                                    call stakingTokenAddress.mem[_41623 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41623 + 136 len _43848 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41623 + 242 len 22]
                                                    else:
                                                        mem[_41623 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41623 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41623 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _38967 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38967] = 26
                                                mem[_38967 + 32] = 'SafeMath: division by zero'
                                                if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41933 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41934 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41934 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44480 = mem[_41934]
                                                    mem[_41933 + 132 len floor32(mem[_41934])] = mem[_41934 + 32 len floor32(mem[_41934])]
                                                    mem[_41933 + floor32(mem[_41934]) + -(mem[_41934] % 32) + 164 len mem[_41934] % 32] = mem[_41934 + -(mem[_41934] % 32) + floor32(mem[_41934]) + 64 len mem[_41934] % 32]
                                                    call stakingTokenAddress.mem[_41933 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41933 + 136 len _44480 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41933 + 242 len 22]
                                                    else:
                                                        mem[_41933 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41933 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41933 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _42331 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _42332 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_42332 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _45238 = mem[_42332]
                                                    mem[_42331 + 132 len floor32(mem[_42332])] = mem[_42332 + 32 len floor32(mem[_42332])]
                                                    mem[_42331 + floor32(mem[_42332]) + -(mem[_42332] % 32) + 164 len mem[_42332] % 32] = mem[_42332 + -(mem[_42332] % 32) + floor32(mem[_42332]) + 64 len mem[_42332] % 32]
                                                    call stakingTokenAddress.mem[_42331 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_42331 + 136 len _45238 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42331 + 242 len 22]
                                                    else:
                                                        mem[_42331 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_42331 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42331 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _34276 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34276] = 26
                                            mem[_34276 + 32] = 'SafeMath: division by zero'
                                            if not totalStakes:
                                                revert with 0, 'SafeMath: division by zero'
                                            if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _36368 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36368] = 30
                                            mem[_36368 + 32] = 'SafeMath: subtraction overflow'
                                            if t > ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 17
                                            if not accountStakes[address(msg.sender)]:
                                                _38966 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38966] = 26
                                                mem[_38966 + 32] = 'SafeMath: division by zero'
                                                if s < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41928 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41929 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41929 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44474 = mem[_41929]
                                                    mem[_41928 + 132 len floor32(mem[_41929])] = mem[_41929 + 32 len floor32(mem[_41929])]
                                                    mem[_41928 + floor32(mem[_41929]) + -(mem[_41929] % 32) + 164 len mem[_41929] % 32] = mem[_41929 + -(mem[_41929] % 32) + floor32(mem[_41929]) + 64 len mem[_41929] % 32]
                                                    call stakingTokenAddress.mem[_41928 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41928 + 136 len _44474 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41928 + 242 len 22]
                                                    else:
                                                        mem[_41928 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41928 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41928 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _42328 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _42329 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_42329 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _45232 = mem[_42329]
                                                    mem[_42328 + 132 len floor32(mem[_42329])] = mem[_42329 + 32 len floor32(mem[_42329])]
                                                    mem[_42328 + floor32(mem[_42329]) + -(mem[_42329] % 32) + 164 len mem[_42329] % 32] = mem[_42329 + -(mem[_42329] % 32) + floor32(mem[_42329]) + 64 len mem[_42329] % 32]
                                                    call stakingTokenAddress.mem[_42328 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_42328 + 136 len _45232 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42328 + 242 len 22]
                                                    else:
                                                        mem[_42328 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_42328 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42328 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored - t:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _39601 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39601] = 26
                                                mem[_39601 + 32] = 'SafeMath: division by zero'
                                                if s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _42746 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _42747 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_42747 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _46004 = mem[_42747]
                                                    mem[_42746 + 132 len floor32(mem[_42747])] = mem[_42747 + 32 len floor32(mem[_42747])]
                                                    mem[_42746 + floor32(mem[_42747]) + -(mem[_42747] % 32) + 164 len mem[_42747] % 32] = mem[_42747 + -(mem[_42747] % 32) + floor32(mem[_42747]) + 64 len mem[_42747] % 32]
                                                    call stakingTokenAddress.mem[_42746 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_42746 + 136 len _46004 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42746 + 242 len 22]
                                                    else:
                                                        mem[_42746 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_42746 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42746 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _43238 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _43239 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_43239 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _46805 = mem[_43239]
                                                    mem[_43238 + 132 len floor32(mem[_43239])] = mem[_43239 + 32 len floor32(mem[_43239])]
                                                    mem[_43238 + floor32(mem[_43239]) + -(mem[_43239] % 32) + 164 len mem[_43239] % 32] = mem[_43239 + -(mem[_43239] % 32) + floor32(mem[_43239]) + 64 len mem[_43239] % 32]
                                                    call stakingTokenAddress.mem[_43238 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_43238 + 136 len _46805 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_43238 + 242 len 22]
                                                    else:
                                                        mem[_43238 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_43238 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_43238 + ceil32(return_data.size) + 243 len 22]
                    else:
                        lastUpdateTime = periodFinish
                        if not msg.sender:
                            if arg1 <= 0:
                                revert with 0, 'staking 0'
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                revert with 0, 'SafeERC20: call to non-contract'
                            if not ext_code.hash(stakingTokenAddress):
                                revert with 0, 'SafeERC20: call to non-contract'
                            mem[356 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg1) >> 32
                            mem[480 len 4] = uint32(arg1)
                            call stakingTokenAddress with:
                                 gas gas_remaining wei
                                args Mask(224, 32, arg1) << 480, mem[452 len 4]
                            if not return_data.size:
                                require not ext_call.success
                                revert with 0, 'SafeERC20: low-level call failed'
                            mem[388 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[388]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[ceil32(return_data.size) + 467 len 22]
                        else:
                            mem[224] = 0
                            mem[256] = 0
                            mem[288] = 0
                            mem[320] = 0
                            mem[0] = msg.sender
                            mem[32] = 16
                            mem[64] = 480
                            mem[352] = sub_183ddbfb[address(msg.sender)].field_0
                            mem[384] = sub_183ddbfb[address(msg.sender)].field_256
                            mem[416] = sub_183ddbfb[address(msg.sender)].field_512
                            mem[448] = sub_183ddbfb[address(msg.sender)].field_768
                            idx = sub_183ddbfb[address(msg.sender)].field_768
                            s = sub_183ddbfb[address(msg.sender)].field_512
                            t = sub_183ddbfb[address(msg.sender)].field_256
                            while idx < sub_e7690c44:
                                require idx < sub_155b0a71.length
                                mem[0] = 15
                                if not t:
                                    _32474 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32474] = 26
                                    mem[_32474 + 32] = 'SafeMath: division by zero'
                                    require idx < sub_155b0a71.length
                                    mem[0] = 15
                                    if not s:
                                        _33710 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33710] = 26
                                        mem[_33710 + 32] = 'SafeMath: division by zero'
                                        idx = idx + 1
                                        s = 0
                                        t = 0
                                        continue 
                                    if sub_155b0a71[idx] * s / s != sub_155b0a71[idx]:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _33794 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33794] = 26
                                    mem[_33794 + 32] = 'SafeMath: division by zero'
                                    idx = idx + 1
                                    s = sub_155b0a71[idx] * s / 10^18
                                    t = 0
                                    continue 
                                if sub_155b0a71[idx] * t / t != sub_155b0a71[idx]:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _32596 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32596] = 26
                                mem[_32596 + 32] = 'SafeMath: division by zero'
                                require idx < sub_155b0a71.length
                                mem[0] = 15
                                if not s:
                                    _33793 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33793] = 26
                                    mem[_33793 + 32] = 'SafeMath: division by zero'
                                    idx = idx + 1
                                    s = 0
                                    t = sub_155b0a71[idx] * t / 10^18
                                    continue 
                                if sub_155b0a71[idx] * s / s != sub_155b0a71[idx]:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _33820 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33820] = 26
                                mem[_33820 + 32] = 'SafeMath: division by zero'
                                idx = idx + 1
                                s = sub_155b0a71[idx] * s / 10^18
                                t = sub_155b0a71[idx] * t / 10^18
                                continue 
                            if 0 == totalStakes:
                                _32402 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32402] = 30
                                mem[_32402 + 32] = 'SafeMath: subtraction overflow'
                                if t > rewardPerTokenStored:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 17
                                if not accountStakes[address(msg.sender)]:
                                    _33377 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33377] = 26
                                    mem[_33377 + 32] = 'SafeMath: division by zero'
                                    if s < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_183ddbfb[address(msg.sender)].field_512 = s
                                    sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                    sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                    if sub_183ddbfb[address(msg.sender)].field_0:
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _34428 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _34429 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_34429 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _35066 = mem[_34429]
                                        mem[_34428 + 132 len floor32(mem[_34429])] = mem[_34429 + 32 len floor32(mem[_34429])]
                                        mem[_34428 + floor32(mem[_34429]) + -(mem[_34429] % 32) + 164 len mem[_34429] % 32] = mem[_34429 + -(mem[_34429] % 32) + floor32(mem[_34429]) + 64 len mem[_34429] % 32]
                                        call stakingTokenAddress.mem[_34428 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_34428 + 136 len _35066 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34428 + 242 len 22]
                                        else:
                                            mem[_34428 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_34428 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34428 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _34606 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _34607 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_34607 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _35180 = mem[_34607]
                                        mem[_34606 + 132 len floor32(mem[_34607])] = mem[_34607 + 32 len floor32(mem[_34607])]
                                        mem[_34606 + floor32(mem[_34607]) + -(mem[_34607] % 32) + 164 len mem[_34607] % 32] = mem[_34607 + -(mem[_34607] % 32) + floor32(mem[_34607]) + 64 len mem[_34607] % 32]
                                        call stakingTokenAddress.mem[_34606 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_34606 + 136 len _35180 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34606 + 242 len 22]
                                        else:
                                            mem[_34606 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_34606 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34606 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    if (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != rewardPerTokenStored - t:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _33632 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33632] = 26
                                    mem[_33632 + 32] = 'SafeMath: division by zero'
                                    if s + ((rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_183ddbfb[address(msg.sender)].field_512 = s + ((rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                    sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                    sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                    if sub_183ddbfb[address(msg.sender)].field_0:
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _34750 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _34751 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_34751 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _35324 = mem[_34751]
                                        mem[_34750 + 132 len floor32(mem[_34751])] = mem[_34751 + 32 len floor32(mem[_34751])]
                                        mem[_34750 + floor32(mem[_34751]) + -(mem[_34751] % 32) + 164 len mem[_34751] % 32] = mem[_34751 + -(mem[_34751] % 32) + floor32(mem[_34751]) + 64 len mem[_34751] % 32]
                                        call stakingTokenAddress.mem[_34750 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_34750 + 136 len _35324 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34750 + 242 len 22]
                                        else:
                                            mem[_34750 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_34750 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34750 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _34888 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _34889 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_34889 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _35531 = mem[_34889]
                                        mem[_34888 + 132 len floor32(mem[_34889])] = mem[_34889 + 32 len floor32(mem[_34889])]
                                        mem[_34888 + floor32(mem[_34889]) + -(mem[_34889] % 32) + 164 len mem[_34889] % 32] = mem[_34889 + -(mem[_34889] % 32) + floor32(mem[_34889]) + 64 len mem[_34889] % 32]
                                        call stakingTokenAddress.mem[_34888 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_34888 + 136 len _35531 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34888 + 242 len 22]
                                        else:
                                            mem[_34888 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_34888 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34888 + ceil32(return_data.size) + 243 len 22]
                            else:
                                if block.timestamp < periodFinish:
                                    _32648 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32648] = 30
                                    mem[_32648 + 32] = 'SafeMath: subtraction overflow'
                                    if lastUpdateTime > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not block.timestamp - lastUpdateTime:
                                        _33852 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33852] = 26
                                        mem[_33852 + 32] = 'SafeMath: division by zero'
                                        if not totalStakes:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _35176 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35176] = 30
                                        mem[_35176 + 32] = 'SafeMath: subtraction overflow'
                                        if t > (0 / totalStakes) + rewardPerTokenStored:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 17
                                        if not accountStakes[address(msg.sender)]:
                                            _37518 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37518] = 26
                                            mem[_37518 + 32] = 'SafeMath: division by zero'
                                            if s < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40506 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40507 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40507 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _41640 = mem[_40507]
                                                mem[_40506 + 132 len floor32(mem[_40507])] = mem[_40507 + 32 len floor32(mem[_40507])]
                                                mem[_40506 + floor32(mem[_40507]) + -(mem[_40507] % 32) + 164 len mem[_40507] % 32] = mem[_40507 + -(mem[_40507] % 32) + floor32(mem[_40507]) + 64 len mem[_40507] % 32]
                                                call stakingTokenAddress.mem[_40506 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40506 + 136 len _41640 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40506 + 242 len 22]
                                                else:
                                                    mem[_40506 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40506 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40506 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40634 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40635 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40635 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _41946 = mem[_40635]
                                                mem[_40634 + 132 len floor32(mem[_40635])] = mem[_40635 + 32 len floor32(mem[_40635])]
                                                mem[_40634 + floor32(mem[_40635]) + -(mem[_40635] % 32) + 164 len mem[_40635] % 32] = mem[_40635 + -(mem[_40635] % 32) + floor32(mem[_40635]) + 64 len mem[_40635] % 32]
                                                call stakingTokenAddress.mem[_40634 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40634 + 136 len _41946 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40634 + 242 len 22]
                                                else:
                                                    mem[_40634 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40634 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40634 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _37993 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37993] = 26
                                            mem[_37993 + 32] = 'SafeMath: division by zero'
                                            if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40825 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40826 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40826 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42352 = mem[_40826]
                                                mem[_40825 + 132 len floor32(mem[_40826])] = mem[_40826 + 32 len floor32(mem[_40826])]
                                                mem[_40825 + floor32(mem[_40826]) + -(mem[_40826] % 32) + 164 len mem[_40826] % 32] = mem[_40826 + -(mem[_40826] % 32) + floor32(mem[_40826]) + 64 len mem[_40826] % 32]
                                                call stakingTokenAddress.mem[_40825 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40825 + 136 len _42352 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40825 + 242 len 22]
                                                else:
                                                    mem[_40825 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40825 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40825 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41055 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41056 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41056 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42766 = mem[_41056]
                                                mem[_41055 + 132 len floor32(mem[_41056])] = mem[_41056 + 32 len floor32(mem[_41056])]
                                                mem[_41055 + floor32(mem[_41056]) + -(mem[_41056] % 32) + 164 len mem[_41056] % 32] = mem[_41056 + -(mem[_41056] % 32) + floor32(mem[_41056]) + 64 len mem[_41056] % 32]
                                                call stakingTokenAddress.mem[_41055 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41055 + 136 len _42766 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41055 + 242 len 22]
                                                else:
                                                    mem[_41055 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41055 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41055 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        if (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) / block.timestamp - lastUpdateTime != rewardRate:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate):
                                            _33958 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33958] = 26
                                            mem[_33958 + 32] = 'SafeMath: division by zero'
                                            if not totalStakes:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _35523 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35523] = 30
                                            mem[_35523 + 32] = 'SafeMath: subtraction overflow'
                                            if t > (0 / totalStakes) + rewardPerTokenStored:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 17
                                            if not accountStakes[address(msg.sender)]:
                                                _37992 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37992] = 26
                                                mem[_37992 + 32] = 'SafeMath: division by zero'
                                                if s < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _40820 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _40821 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_40821 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _42346 = mem[_40821]
                                                    mem[_40820 + 132 len floor32(mem[_40821])] = mem[_40821 + 32 len floor32(mem[_40821])]
                                                    mem[_40820 + floor32(mem[_40821]) + -(mem[_40821] % 32) + 164 len mem[_40821] % 32] = mem[_40821 + -(mem[_40821] % 32) + floor32(mem[_40821]) + 64 len mem[_40821] % 32]
                                                    call stakingTokenAddress.mem[_40820 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_40820 + 136 len _42346 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_40820 + 242 len 22]
                                                    else:
                                                        mem[_40820 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_40820 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_40820 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41052 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41053 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41053 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _42760 = mem[_41053]
                                                    mem[_41052 + 132 len floor32(mem[_41053])] = mem[_41053 + 32 len floor32(mem[_41053])]
                                                    mem[_41052 + floor32(mem[_41053]) + -(mem[_41053] % 32) + 164 len mem[_41053] % 32] = mem[_41053 + -(mem[_41053] % 32) + floor32(mem[_41053]) + 64 len mem[_41053] % 32]
                                                    call stakingTokenAddress.mem[_41052 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41052 + 136 len _42760 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41052 + 242 len 22]
                                                    else:
                                                        mem[_41052 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41052 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41052 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _38450 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38450] = 26
                                                mem[_38450 + 32] = 'SafeMath: division by zero'
                                                if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41318 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41319 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41319 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43266 = mem[_41319]
                                                    mem[_41318 + 132 len floor32(mem[_41319])] = mem[_41319 + 32 len floor32(mem[_41319])]
                                                    mem[_41318 + floor32(mem[_41319]) + -(mem[_41319] % 32) + 164 len mem[_41319] % 32] = mem[_41319 + -(mem[_41319] % 32) + floor32(mem[_41319]) + 64 len mem[_41319] % 32]
                                                    call stakingTokenAddress.mem[_41318 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41318 + 136 len _43266 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41318 + 242 len 22]
                                                    else:
                                                        mem[_41318 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41318 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41318 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41634 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41635 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41635 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43871 = mem[_41635]
                                                    mem[_41634 + 132 len floor32(mem[_41635])] = mem[_41635 + 32 len floor32(mem[_41635])]
                                                    mem[_41634 + floor32(mem[_41635]) + -(mem[_41635] % 32) + 164 len mem[_41635] % 32] = mem[_41635 + -(mem[_41635] % 32) + floor32(mem[_41635]) + 64 len mem[_41635] % 32]
                                                    call stakingTokenAddress.mem[_41634 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41634 + 136 len _43871 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41634 + 242 len 22]
                                                    else:
                                                        mem[_41634 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41634 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41634 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _34102 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34102] = 26
                                            mem[_34102 + 32] = 'SafeMath: division by zero'
                                            if not totalStakes:
                                                revert with 0, 'SafeMath: division by zero'
                                            if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _35876 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35876] = 30
                                            mem[_35876 + 32] = 'SafeMath: subtraction overflow'
                                            if t > ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 17
                                            if not accountStakes[address(msg.sender)]:
                                                _38449 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38449] = 26
                                                mem[_38449 + 32] = 'SafeMath: division by zero'
                                                if s < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41313 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41314 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41314 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43260 = mem[_41314]
                                                    mem[_41313 + 132 len floor32(mem[_41314])] = mem[_41314 + 32 len floor32(mem[_41314])]
                                                    mem[_41313 + floor32(mem[_41314]) + -(mem[_41314] % 32) + 164 len mem[_41314] % 32] = mem[_41314 + -(mem[_41314] % 32) + floor32(mem[_41314]) + 64 len mem[_41314] % 32]
                                                    call stakingTokenAddress.mem[_41313 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41313 + 136 len _43260 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41313 + 242 len 22]
                                                    else:
                                                        mem[_41313 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41313 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41313 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41631 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41632 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41632 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43865 = mem[_41632]
                                                    mem[_41631 + 132 len floor32(mem[_41632])] = mem[_41632 + 32 len floor32(mem[_41632])]
                                                    mem[_41631 + floor32(mem[_41632]) + -(mem[_41632] % 32) + 164 len mem[_41632] % 32] = mem[_41632 + -(mem[_41632] % 32) + floor32(mem[_41632]) + 64 len mem[_41632] % 32]
                                                    call stakingTokenAddress.mem[_41631 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41631 + 136 len _43865 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41631 + 242 len 22]
                                                    else:
                                                        mem[_41631 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41631 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41631 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored - t:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _38988 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38988] = 26
                                                mem[_38988 + 32] = 'SafeMath: division by zero'
                                                if s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41938 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41939 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41939 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44495 = mem[_41939]
                                                    mem[_41938 + 132 len floor32(mem[_41939])] = mem[_41939 + 32 len floor32(mem[_41939])]
                                                    mem[_41938 + floor32(mem[_41939]) + -(mem[_41939] % 32) + 164 len mem[_41939] % 32] = mem[_41939 + -(mem[_41939] % 32) + floor32(mem[_41939]) + 64 len mem[_41939] % 32]
                                                    call stakingTokenAddress.mem[_41938 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41938 + 136 len _44495 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41938 + 242 len 22]
                                                    else:
                                                        mem[_41938 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41938 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41938 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _42340 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _42341 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_42341 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _45260 = mem[_42341]
                                                    mem[_42340 + 132 len floor32(mem[_42341])] = mem[_42341 + 32 len floor32(mem[_42341])]
                                                    mem[_42340 + floor32(mem[_42341]) + -(mem[_42341] % 32) + 164 len mem[_42341] % 32] = mem[_42341 + -(mem[_42341] % 32) + floor32(mem[_42341]) + 64 len mem[_42341] % 32]
                                                    call stakingTokenAddress.mem[_42340 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_42340 + 136 len _45260 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42340 + 242 len 22]
                                                    else:
                                                        mem[_42340 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_42340 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42340 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    _32846 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32846] = 30
                                    mem[_32846 + 32] = 'SafeMath: subtraction overflow'
                                    if lastUpdateTime > periodFinish:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not periodFinish - lastUpdateTime:
                                        _33962 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33962] = 26
                                        mem[_33962 + 32] = 'SafeMath: division by zero'
                                        if not totalStakes:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _35527 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35527] = 30
                                        mem[_35527 + 32] = 'SafeMath: subtraction overflow'
                                        if t > (0 / totalStakes) + rewardPerTokenStored:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 17
                                        if not accountStakes[address(msg.sender)]:
                                            _37996 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37996] = 26
                                            mem[_37996 + 32] = 'SafeMath: division by zero'
                                            if s < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40830 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40831 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40831 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42370 = mem[_40831]
                                                mem[_40830 + 132 len floor32(mem[_40831])] = mem[_40831 + 32 len floor32(mem[_40831])]
                                                mem[_40830 + floor32(mem[_40831]) + -(mem[_40831] % 32) + 164 len mem[_40831] % 32] = mem[_40831 + -(mem[_40831] % 32) + floor32(mem[_40831]) + 64 len mem[_40831] % 32]
                                                call stakingTokenAddress.mem[_40830 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40830 + 136 len _42370 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40830 + 242 len 22]
                                                else:
                                                    mem[_40830 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40830 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40830 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41062 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41063 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41063 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42782 = mem[_41063]
                                                mem[_41062 + 132 len floor32(mem[_41063])] = mem[_41063 + 32 len floor32(mem[_41063])]
                                                mem[_41062 + floor32(mem[_41063]) + -(mem[_41063] % 32) + 164 len mem[_41063] % 32] = mem[_41063 + -(mem[_41063] % 32) + floor32(mem[_41063]) + 64 len mem[_41063] % 32]
                                                call stakingTokenAddress.mem[_41062 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41062 + 136 len _42782 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41062 + 242 len 22]
                                                else:
                                                    mem[_41062 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41062 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41062 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _38452 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38452] = 26
                                            mem[_38452 + 32] = 'SafeMath: division by zero'
                                            if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41328 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41329 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41329 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43290 = mem[_41329]
                                                mem[_41328 + 132 len floor32(mem[_41329])] = mem[_41329 + 32 len floor32(mem[_41329])]
                                                mem[_41328 + floor32(mem[_41329]) + -(mem[_41329] % 32) + 164 len mem[_41329] % 32] = mem[_41329 + -(mem[_41329] % 32) + floor32(mem[_41329]) + 64 len mem[_41329] % 32]
                                                call stakingTokenAddress.mem[_41328 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41328 + 136 len _43290 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41328 + 242 len 22]
                                                else:
                                                    mem[_41328 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41328 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41328 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41650 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41651 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41651 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43899 = mem[_41651]
                                                mem[_41650 + 132 len floor32(mem[_41651])] = mem[_41651 + 32 len floor32(mem[_41651])]
                                                mem[_41650 + floor32(mem[_41651]) + -(mem[_41651] % 32) + 164 len mem[_41651] % 32] = mem[_41651 + -(mem[_41651] % 32) + floor32(mem[_41651]) + 64 len mem[_41651] % 32]
                                                call stakingTokenAddress.mem[_41650 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41650 + 136 len _43899 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41650 + 242 len 22]
                                                else:
                                                    mem[_41650 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41650 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41650 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        if (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) / periodFinish - lastUpdateTime != rewardRate:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not (periodFinish * rewardRate) - (lastUpdateTime * rewardRate):
                                            _34107 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34107] = 26
                                            mem[_34107 + 32] = 'SafeMath: division by zero'
                                            if not totalStakes:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _35882 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35882] = 30
                                            mem[_35882 + 32] = 'SafeMath: subtraction overflow'
                                            if t > (0 / totalStakes) + rewardPerTokenStored:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 17
                                            if not accountStakes[address(msg.sender)]:
                                                _38451 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38451] = 26
                                                mem[_38451 + 32] = 'SafeMath: division by zero'
                                                if s < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41323 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41324 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41324 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43284 = mem[_41324]
                                                    mem[_41323 + 132 len floor32(mem[_41324])] = mem[_41324 + 32 len floor32(mem[_41324])]
                                                    mem[_41323 + floor32(mem[_41324]) + -(mem[_41324] % 32) + 164 len mem[_41324] % 32] = mem[_41324 + -(mem[_41324] % 32) + floor32(mem[_41324]) + 64 len mem[_41324] % 32]
                                                    call stakingTokenAddress.mem[_41323 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41323 + 136 len _43284 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41323 + 242 len 22]
                                                    else:
                                                        mem[_41323 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41323 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41323 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41647 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41648 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41648 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43893 = mem[_41648]
                                                    mem[_41647 + 132 len floor32(mem[_41648])] = mem[_41648 + 32 len floor32(mem[_41648])]
                                                    mem[_41647 + floor32(mem[_41648]) + -(mem[_41648] % 32) + 164 len mem[_41648] % 32] = mem[_41648 + -(mem[_41648] % 32) + floor32(mem[_41648]) + 64 len mem[_41648] % 32]
                                                    call stakingTokenAddress.mem[_41647 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41647 + 136 len _43893 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41647 + 242 len 22]
                                                    else:
                                                        mem[_41647 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41647 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41647 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _38990 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38990] = 26
                                                mem[_38990 + 32] = 'SafeMath: division by zero'
                                                if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41954 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41955 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41955 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44525 = mem[_41955]
                                                    mem[_41954 + 132 len floor32(mem[_41955])] = mem[_41955 + 32 len floor32(mem[_41955])]
                                                    mem[_41954 + floor32(mem[_41955]) + -(mem[_41955] % 32) + 164 len mem[_41955] % 32] = mem[_41955 + -(mem[_41955] % 32) + floor32(mem[_41955]) + 64 len mem[_41955] % 32]
                                                    call stakingTokenAddress.mem[_41954 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41954 + 136 len _44525 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41954 + 242 len 22]
                                                    else:
                                                        mem[_41954 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41954 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41954 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _42364 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _42365 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_42365 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _45298 = mem[_42365]
                                                    mem[_42364 + 132 len floor32(mem[_42365])] = mem[_42365 + 32 len floor32(mem[_42365])]
                                                    mem[_42364 + floor32(mem[_42365]) + -(mem[_42365] % 32) + 164 len mem[_42365] % 32] = mem[_42365 + -(mem[_42365] % 32) + floor32(mem[_42365]) + 64 len mem[_42365] % 32]
                                                    call stakingTokenAddress.mem[_42364 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_42364 + 136 len _45298 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42364 + 242 len 22]
                                                    else:
                                                        mem[_42364 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_42364 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42364 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _34288 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34288] = 26
                                            mem[_34288 + 32] = 'SafeMath: division by zero'
                                            if not totalStakes:
                                                revert with 0, 'SafeMath: division by zero'
                                            if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _36391 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36391] = 30
                                            mem[_36391 + 32] = 'SafeMath: subtraction overflow'
                                            if t > ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 17
                                            if not accountStakes[address(msg.sender)]:
                                                _38989 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38989] = 26
                                                mem[_38989 + 32] = 'SafeMath: division by zero'
                                                if s < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41949 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41950 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41950 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44519 = mem[_41950]
                                                    mem[_41949 + 132 len floor32(mem[_41950])] = mem[_41950 + 32 len floor32(mem[_41950])]
                                                    mem[_41949 + floor32(mem[_41950]) + -(mem[_41950] % 32) + 164 len mem[_41950] % 32] = mem[_41950 + -(mem[_41950] % 32) + floor32(mem[_41950]) + 64 len mem[_41950] % 32]
                                                    call stakingTokenAddress.mem[_41949 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41949 + 136 len _44519 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41949 + 242 len 22]
                                                    else:
                                                        mem[_41949 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41949 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41949 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _42361 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _42362 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_42362 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _45292 = mem[_42362]
                                                    mem[_42361 + 132 len floor32(mem[_42362])] = mem[_42362 + 32 len floor32(mem[_42362])]
                                                    mem[_42361 + floor32(mem[_42362]) + -(mem[_42362] % 32) + 164 len mem[_42362] % 32] = mem[_42362 + -(mem[_42362] % 32) + floor32(mem[_42362]) + 64 len mem[_42362] % 32]
                                                    call stakingTokenAddress.mem[_42361 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_42361 + 136 len _45292 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42361 + 242 len 22]
                                                    else:
                                                        mem[_42361 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_42361 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42361 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored - t:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _39628 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39628] = 26
                                                mem[_39628 + 32] = 'SafeMath: division by zero'
                                                if s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _42774 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _42775 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_42775 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _46056 = mem[_42775]
                                                    mem[_42774 + 132 len floor32(mem[_42775])] = mem[_42775 + 32 len floor32(mem[_42775])]
                                                    mem[_42774 + floor32(mem[_42775]) + -(mem[_42775] % 32) + 164 len mem[_42775] % 32] = mem[_42775 + -(mem[_42775] % 32) + floor32(mem[_42775]) + 64 len mem[_42775] % 32]
                                                    call stakingTokenAddress.mem[_42774 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_42774 + 136 len _46056 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42774 + 242 len 22]
                                                    else:
                                                        mem[_42774 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_42774 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42774 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _43278 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _43279 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_43279 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _46866 = mem[_43279]
                                                    mem[_43278 + 132 len floor32(mem[_43279])] = mem[_43279 + 32 len floor32(mem[_43279])]
                                                    mem[_43278 + floor32(mem[_43279]) + -(mem[_43279] % 32) + 164 len mem[_43279] % 32] = mem[_43279 + -(mem[_43279] % 32) + floor32(mem[_43279]) + 64 len mem[_43279] % 32]
                                                    call stakingTokenAddress.mem[_43278 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_43278 + 136 len _46866 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_43278 + 242 len 22]
                                                    else:
                                                        mem[_43278 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_43278 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_43278 + ceil32(return_data.size) + 243 len 22]
                else:
                    if (10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                    mem[160] = 26
                    mem[192] = 'SafeMath: division by zero'
                    if not totalStakes:
                        revert with 0, 'SafeMath: division by zero'
                    if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                        revert with 0, 'SafeMath: addition overflow'
                    rewardPerTokenStored += (10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes
                    if block.timestamp < periodFinish:
                        lastUpdateTime = block.timestamp
                        if not msg.sender:
                            if arg1 <= 0:
                                revert with 0, 'staking 0'
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                revert with 0, 'SafeERC20: call to non-contract'
                            if not ext_code.hash(stakingTokenAddress):
                                revert with 0, 'SafeERC20: call to non-contract'
                            mem[356 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg1) >> 32
                            mem[480 len 4] = uint32(arg1)
                            call stakingTokenAddress with:
                                 gas gas_remaining wei
                                args Mask(224, 32, arg1) << 480, mem[452 len 4]
                            if not return_data.size:
                                require not ext_call.success
                                revert with 0, 'SafeERC20: low-level call failed'
                            mem[388 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[388]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[ceil32(return_data.size) + 467 len 22]
                        else:
                            mem[224] = 0
                            mem[256] = 0
                            mem[288] = 0
                            mem[320] = 0
                            mem[0] = msg.sender
                            mem[32] = 16
                            mem[64] = 480
                            mem[352] = sub_183ddbfb[address(msg.sender)].field_0
                            mem[384] = sub_183ddbfb[address(msg.sender)].field_256
                            mem[416] = sub_183ddbfb[address(msg.sender)].field_512
                            mem[448] = sub_183ddbfb[address(msg.sender)].field_768
                            idx = sub_183ddbfb[address(msg.sender)].field_768
                            s = sub_183ddbfb[address(msg.sender)].field_512
                            t = sub_183ddbfb[address(msg.sender)].field_256
                            while idx < sub_e7690c44:
                                require idx < sub_155b0a71.length
                                mem[0] = 15
                                if not t:
                                    _32459 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32459] = 26
                                    mem[_32459 + 32] = 'SafeMath: division by zero'
                                    require idx < sub_155b0a71.length
                                    mem[0] = 15
                                    if not s:
                                        _33698 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33698] = 26
                                        mem[_33698 + 32] = 'SafeMath: division by zero'
                                        idx = idx + 1
                                        s = 0
                                        t = 0
                                        continue 
                                    if sub_155b0a71[idx] * s / s != sub_155b0a71[idx]:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _33782 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33782] = 26
                                    mem[_33782 + 32] = 'SafeMath: division by zero'
                                    idx = idx + 1
                                    s = sub_155b0a71[idx] * s / 10^18
                                    t = 0
                                    continue 
                                if sub_155b0a71[idx] * t / t != sub_155b0a71[idx]:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _32578 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32578] = 26
                                mem[_32578 + 32] = 'SafeMath: division by zero'
                                require idx < sub_155b0a71.length
                                mem[0] = 15
                                if not s:
                                    _33781 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33781] = 26
                                    mem[_33781 + 32] = 'SafeMath: division by zero'
                                    idx = idx + 1
                                    s = 0
                                    t = sub_155b0a71[idx] * t / 10^18
                                    continue 
                                if sub_155b0a71[idx] * s / s != sub_155b0a71[idx]:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _33817 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33817] = 26
                                mem[_33817 + 32] = 'SafeMath: division by zero'
                                idx = idx + 1
                                s = sub_155b0a71[idx] * s / 10^18
                                t = sub_155b0a71[idx] * t / 10^18
                                continue 
                            if 0 == totalStakes:
                                _32387 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32387] = 30
                                mem[_32387 + 32] = 'SafeMath: subtraction overflow'
                                if t > rewardPerTokenStored:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 17
                                if not accountStakes[address(msg.sender)]:
                                    _33347 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33347] = 26
                                    mem[_33347 + 32] = 'SafeMath: division by zero'
                                    if s < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_183ddbfb[address(msg.sender)].field_512 = s
                                    sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                    sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                    if sub_183ddbfb[address(msg.sender)].field_0:
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _34401 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _34402 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_34402 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _35033 = mem[_34402]
                                        mem[_34401 + 132 len floor32(mem[_34402])] = mem[_34402 + 32 len floor32(mem[_34402])]
                                        mem[_34401 + floor32(mem[_34402]) + -(mem[_34402] % 32) + 164 len mem[_34402] % 32] = mem[_34402 + -(mem[_34402] % 32) + floor32(mem[_34402]) + 64 len mem[_34402] % 32]
                                        call stakingTokenAddress.mem[_34401 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_34401 + 136 len _35033 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34401 + 242 len 22]
                                        else:
                                            mem[_34401 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_34401 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34401 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _34564 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _34565 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_34565 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _35159 = mem[_34565]
                                        mem[_34564 + 132 len floor32(mem[_34565])] = mem[_34565 + 32 len floor32(mem[_34565])]
                                        mem[_34564 + floor32(mem[_34565]) + -(mem[_34565] % 32) + 164 len mem[_34565] % 32] = mem[_34565 + -(mem[_34565] % 32) + floor32(mem[_34565]) + 64 len mem[_34565] % 32]
                                        call stakingTokenAddress.mem[_34564 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_34564 + 136 len _35159 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34564 + 242 len 22]
                                        else:
                                            mem[_34564 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_34564 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34564 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    if (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != rewardPerTokenStored - t:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _33605 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33605] = 26
                                    mem[_33605 + 32] = 'SafeMath: division by zero'
                                    if s + ((rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_183ddbfb[address(msg.sender)].field_512 = s + ((rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                    sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                    sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                    if sub_183ddbfb[address(msg.sender)].field_0:
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _34723 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _34724 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_34724 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _35288 = mem[_34724]
                                        mem[_34723 + 132 len floor32(mem[_34724])] = mem[_34724 + 32 len floor32(mem[_34724])]
                                        mem[_34723 + floor32(mem[_34724]) + -(mem[_34724] % 32) + 164 len mem[_34724] % 32] = mem[_34724 + -(mem[_34724] % 32) + floor32(mem[_34724]) + 64 len mem[_34724] % 32]
                                        call stakingTokenAddress.mem[_34723 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_34723 + 136 len _35288 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34723 + 242 len 22]
                                        else:
                                            mem[_34723 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_34723 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34723 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _34858 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _34859 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_34859 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _35483 = mem[_34859]
                                        mem[_34858 + 132 len floor32(mem[_34859])] = mem[_34859 + 32 len floor32(mem[_34859])]
                                        mem[_34858 + floor32(mem[_34859]) + -(mem[_34859] % 32) + 164 len mem[_34859] % 32] = mem[_34859 + -(mem[_34859] % 32) + floor32(mem[_34859]) + 64 len mem[_34859] % 32]
                                        call stakingTokenAddress.mem[_34858 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_34858 + 136 len _35483 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34858 + 242 len 22]
                                        else:
                                            mem[_34858 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_34858 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34858 + ceil32(return_data.size) + 243 len 22]
                            else:
                                if block.timestamp < periodFinish:
                                    _32639 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32639] = 30
                                    mem[_32639 + 32] = 'SafeMath: subtraction overflow'
                                    if lastUpdateTime > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not block.timestamp - lastUpdateTime:
                                        _33843 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33843] = 26
                                        mem[_33843 + 32] = 'SafeMath: division by zero'
                                        if not totalStakes:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _35155 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35155] = 30
                                        mem[_35155 + 32] = 'SafeMath: subtraction overflow'
                                        if t > (0 / totalStakes) + rewardPerTokenStored:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 17
                                        if not accountStakes[address(msg.sender)]:
                                            _37473 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37473] = 26
                                            mem[_37473 + 32] = 'SafeMath: division by zero'
                                            if s < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40491 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40492 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40492 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _41568 = mem[_40492]
                                                mem[_40491 + 132 len floor32(mem[_40492])] = mem[_40492 + 32 len floor32(mem[_40492])]
                                                mem[_40491 + floor32(mem[_40492]) + -(mem[_40492] % 32) + 164 len mem[_40492] % 32] = mem[_40492 + -(mem[_40492] % 32) + floor32(mem[_40492]) + 64 len mem[_40492] % 32]
                                                call stakingTokenAddress.mem[_40491 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40491 + 136 len _41568 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40491 + 242 len 22]
                                                else:
                                                    mem[_40491 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40491 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40491 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40601 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40602 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40602 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _41883 = mem[_40602]
                                                mem[_40601 + 132 len floor32(mem[_40602])] = mem[_40602 + 32 len floor32(mem[_40602])]
                                                mem[_40601 + floor32(mem[_40602]) + -(mem[_40602] % 32) + 164 len mem[_40602] % 32] = mem[_40602 + -(mem[_40602] % 32) + floor32(mem[_40602]) + 64 len mem[_40602] % 32]
                                                call stakingTokenAddress.mem[_40601 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40601 + 136 len _41883 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40601 + 242 len 22]
                                                else:
                                                    mem[_40601 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40601 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40601 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _37948 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37948] = 26
                                            mem[_37948 + 32] = 'SafeMath: division by zero'
                                            if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40780 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40781 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40781 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42253 = mem[_40781]
                                                mem[_40780 + 132 len floor32(mem[_40781])] = mem[_40781 + 32 len floor32(mem[_40781])]
                                                mem[_40780 + floor32(mem[_40781]) + -(mem[_40781] % 32) + 164 len mem[_40781] % 32] = mem[_40781 + -(mem[_40781] % 32) + floor32(mem[_40781]) + 64 len mem[_40781] % 32]
                                                call stakingTokenAddress.mem[_40780 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40780 + 136 len _42253 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40780 + 242 len 22]
                                                else:
                                                    mem[_40780 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40780 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40780 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41004 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41005 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41005 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42682 = mem[_41005]
                                                mem[_41004 + 132 len floor32(mem[_41005])] = mem[_41005 + 32 len floor32(mem[_41005])]
                                                mem[_41004 + floor32(mem[_41005]) + -(mem[_41005] % 32) + 164 len mem[_41005] % 32] = mem[_41005 + -(mem[_41005] % 32) + floor32(mem[_41005]) + 64 len mem[_41005] % 32]
                                                call stakingTokenAddress.mem[_41004 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41004 + 136 len _42682 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41004 + 242 len 22]
                                                else:
                                                    mem[_41004 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41004 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41004 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        if (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) / block.timestamp - lastUpdateTime != rewardRate:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate):
                                            _33937 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33937] = 26
                                            mem[_33937 + 32] = 'SafeMath: division by zero'
                                            if not totalStakes:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _35475 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35475] = 30
                                            mem[_35475 + 32] = 'SafeMath: subtraction overflow'
                                            if t > (0 / totalStakes) + rewardPerTokenStored:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 17
                                            if not accountStakes[address(msg.sender)]:
                                                _37947 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37947] = 26
                                                mem[_37947 + 32] = 'SafeMath: division by zero'
                                                if s < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _40775 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _40776 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_40776 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _42247 = mem[_40776]
                                                    mem[_40775 + 132 len floor32(mem[_40776])] = mem[_40776 + 32 len floor32(mem[_40776])]
                                                    mem[_40775 + floor32(mem[_40776]) + -(mem[_40776] % 32) + 164 len mem[_40776] % 32] = mem[_40776 + -(mem[_40776] % 32) + floor32(mem[_40776]) + 64 len mem[_40776] % 32]
                                                    call stakingTokenAddress.mem[_40775 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_40775 + 136 len _42247 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_40775 + 242 len 22]
                                                    else:
                                                        mem[_40775 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_40775 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_40775 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41001 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41002 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41002 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _42676 = mem[_41002]
                                                    mem[_41001 + 132 len floor32(mem[_41002])] = mem[_41002 + 32 len floor32(mem[_41002])]
                                                    mem[_41001 + floor32(mem[_41002]) + -(mem[_41002] % 32) + 164 len mem[_41002] % 32] = mem[_41002 + -(mem[_41002] % 32) + floor32(mem[_41002]) + 64 len mem[_41002] % 32]
                                                    call stakingTokenAddress.mem[_41001 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41001 + 136 len _42676 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41001 + 242 len 22]
                                                    else:
                                                        mem[_41001 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41001 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41001 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _38402 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38402] = 26
                                                mem[_38402 + 32] = 'SafeMath: division by zero'
                                                if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41258 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41259 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41259 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43146 = mem[_41259]
                                                    mem[_41258 + 132 len floor32(mem[_41259])] = mem[_41259 + 32 len floor32(mem[_41259])]
                                                    mem[_41258 + floor32(mem[_41259]) + -(mem[_41259] % 32) + 164 len mem[_41259] % 32] = mem[_41259 + -(mem[_41259] % 32) + floor32(mem[_41259]) + 64 len mem[_41259] % 32]
                                                    call stakingTokenAddress.mem[_41258 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41258 + 136 len _43146 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41258 + 242 len 22]
                                                    else:
                                                        mem[_41258 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41258 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41258 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41562 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41563 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41563 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43736 = mem[_41563]
                                                    mem[_41562 + 132 len floor32(mem[_41563])] = mem[_41563 + 32 len floor32(mem[_41563])]
                                                    mem[_41562 + floor32(mem[_41563]) + -(mem[_41563] % 32) + 164 len mem[_41563] % 32] = mem[_41563 + -(mem[_41563] % 32) + floor32(mem[_41563]) + 64 len mem[_41563] % 32]
                                                    call stakingTokenAddress.mem[_41562 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41562 + 136 len _43736 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41562 + 242 len 22]
                                                    else:
                                                        mem[_41562 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41562 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41562 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _34075 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34075] = 26
                                            mem[_34075 + 32] = 'SafeMath: division by zero'
                                            if not totalStakes:
                                                revert with 0, 'SafeMath: division by zero'
                                            if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _35813 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35813] = 30
                                            mem[_35813 + 32] = 'SafeMath: subtraction overflow'
                                            if t > ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 17
                                            if not accountStakes[address(msg.sender)]:
                                                _38401 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38401] = 26
                                                mem[_38401 + 32] = 'SafeMath: division by zero'
                                                if s < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41253 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41254 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41254 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43140 = mem[_41254]
                                                    mem[_41253 + 132 len floor32(mem[_41254])] = mem[_41254 + 32 len floor32(mem[_41254])]
                                                    mem[_41253 + floor32(mem[_41254]) + -(mem[_41254] % 32) + 164 len mem[_41254] % 32] = mem[_41254 + -(mem[_41254] % 32) + floor32(mem[_41254]) + 64 len mem[_41254] % 32]
                                                    call stakingTokenAddress.mem[_41253 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41253 + 136 len _43140 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41253 + 242 len 22]
                                                    else:
                                                        mem[_41253 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41253 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41253 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41559 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41560 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41560 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43730 = mem[_41560]
                                                    mem[_41559 + 132 len floor32(mem[_41560])] = mem[_41560 + 32 len floor32(mem[_41560])]
                                                    mem[_41559 + floor32(mem[_41560]) + -(mem[_41560] % 32) + 164 len mem[_41560] % 32] = mem[_41560 + -(mem[_41560] % 32) + floor32(mem[_41560]) + 64 len mem[_41560] % 32]
                                                    call stakingTokenAddress.mem[_41559 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41559 + 136 len _43730 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41559 + 242 len 22]
                                                    else:
                                                        mem[_41559 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41559 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41559 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored - t:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _38919 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38919] = 26
                                                mem[_38919 + 32] = 'SafeMath: division by zero'
                                                if s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41875 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41876 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41876 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44360 = mem[_41876]
                                                    mem[_41875 + 132 len floor32(mem[_41876])] = mem[_41876 + 32 len floor32(mem[_41876])]
                                                    mem[_41875 + floor32(mem[_41876]) + -(mem[_41876] % 32) + 164 len mem[_41876] % 32] = mem[_41876 + -(mem[_41876] % 32) + floor32(mem[_41876]) + 64 len mem[_41876] % 32]
                                                    call stakingTokenAddress.mem[_41875 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41875 + 136 len _44360 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41875 + 242 len 22]
                                                    else:
                                                        mem[_41875 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41875 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41875 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _42241 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _42242 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_42242 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _45080 = mem[_42242]
                                                    mem[_42241 + 132 len floor32(mem[_42242])] = mem[_42242 + 32 len floor32(mem[_42242])]
                                                    mem[_42241 + floor32(mem[_42242]) + -(mem[_42242] % 32) + 164 len mem[_42242] % 32] = mem[_42242 + -(mem[_42242] % 32) + floor32(mem[_42242]) + 64 len mem[_42242] % 32]
                                                    call stakingTokenAddress.mem[_42241 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_42241 + 136 len _45080 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42241 + 242 len 22]
                                                    else:
                                                        mem[_42241 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_42241 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42241 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    _32828 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32828] = 30
                                    mem[_32828 + 32] = 'SafeMath: subtraction overflow'
                                    if lastUpdateTime > periodFinish:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not periodFinish - lastUpdateTime:
                                        _33941 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33941] = 26
                                        mem[_33941 + 32] = 'SafeMath: division by zero'
                                        if not totalStakes:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _35479 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35479] = 30
                                        mem[_35479 + 32] = 'SafeMath: subtraction overflow'
                                        if t > (0 / totalStakes) + rewardPerTokenStored:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 17
                                        if not accountStakes[address(msg.sender)]:
                                            _37951 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37951] = 26
                                            mem[_37951 + 32] = 'SafeMath: division by zero'
                                            if s < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40785 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40786 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40786 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42271 = mem[_40786]
                                                mem[_40785 + 132 len floor32(mem[_40786])] = mem[_40786 + 32 len floor32(mem[_40786])]
                                                mem[_40785 + floor32(mem[_40786]) + -(mem[_40786] % 32) + 164 len mem[_40786] % 32] = mem[_40786 + -(mem[_40786] % 32) + floor32(mem[_40786]) + 64 len mem[_40786] % 32]
                                                call stakingTokenAddress.mem[_40785 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40785 + 136 len _42271 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40785 + 242 len 22]
                                                else:
                                                    mem[_40785 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40785 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40785 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41011 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41012 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41012 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42698 = mem[_41012]
                                                mem[_41011 + 132 len floor32(mem[_41012])] = mem[_41012 + 32 len floor32(mem[_41012])]
                                                mem[_41011 + floor32(mem[_41012]) + -(mem[_41012] % 32) + 164 len mem[_41012] % 32] = mem[_41012 + -(mem[_41012] % 32) + floor32(mem[_41012]) + 64 len mem[_41012] % 32]
                                                call stakingTokenAddress.mem[_41011 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41011 + 136 len _42698 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41011 + 242 len 22]
                                                else:
                                                    mem[_41011 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41011 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41011 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _38404 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38404] = 26
                                            mem[_38404 + 32] = 'SafeMath: division by zero'
                                            if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41268 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41269 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41269 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43170 = mem[_41269]
                                                mem[_41268 + 132 len floor32(mem[_41269])] = mem[_41269 + 32 len floor32(mem[_41269])]
                                                mem[_41268 + floor32(mem[_41269]) + -(mem[_41269] % 32) + 164 len mem[_41269] % 32] = mem[_41269 + -(mem[_41269] % 32) + floor32(mem[_41269]) + 64 len mem[_41269] % 32]
                                                call stakingTokenAddress.mem[_41268 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41268 + 136 len _43170 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41268 + 242 len 22]
                                                else:
                                                    mem[_41268 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41268 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41268 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41578 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41579 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41579 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43764 = mem[_41579]
                                                mem[_41578 + 132 len floor32(mem[_41579])] = mem[_41579 + 32 len floor32(mem[_41579])]
                                                mem[_41578 + floor32(mem[_41579]) + -(mem[_41579] % 32) + 164 len mem[_41579] % 32] = mem[_41579 + -(mem[_41579] % 32) + floor32(mem[_41579]) + 64 len mem[_41579] % 32]
                                                call stakingTokenAddress.mem[_41578 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41578 + 136 len _43764 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41578 + 242 len 22]
                                                else:
                                                    mem[_41578 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41578 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41578 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        if (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) / periodFinish - lastUpdateTime != rewardRate:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not (periodFinish * rewardRate) - (lastUpdateTime * rewardRate):
                                            _34080 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34080] = 26
                                            mem[_34080 + 32] = 'SafeMath: division by zero'
                                            if not totalStakes:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _35819 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35819] = 30
                                            mem[_35819 + 32] = 'SafeMath: subtraction overflow'
                                            if t > (0 / totalStakes) + rewardPerTokenStored:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 17
                                            if not accountStakes[address(msg.sender)]:
                                                _38403 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38403] = 26
                                                mem[_38403 + 32] = 'SafeMath: division by zero'
                                                if s < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41263 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41264 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41264 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43164 = mem[_41264]
                                                    mem[_41263 + 132 len floor32(mem[_41264])] = mem[_41264 + 32 len floor32(mem[_41264])]
                                                    mem[_41263 + floor32(mem[_41264]) + -(mem[_41264] % 32) + 164 len mem[_41264] % 32] = mem[_41264 + -(mem[_41264] % 32) + floor32(mem[_41264]) + 64 len mem[_41264] % 32]
                                                    call stakingTokenAddress.mem[_41263 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41263 + 136 len _43164 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41263 + 242 len 22]
                                                    else:
                                                        mem[_41263 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41263 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41263 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41575 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41576 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41576 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43758 = mem[_41576]
                                                    mem[_41575 + 132 len floor32(mem[_41576])] = mem[_41576 + 32 len floor32(mem[_41576])]
                                                    mem[_41575 + floor32(mem[_41576]) + -(mem[_41576] % 32) + 164 len mem[_41576] % 32] = mem[_41576 + -(mem[_41576] % 32) + floor32(mem[_41576]) + 64 len mem[_41576] % 32]
                                                    call stakingTokenAddress.mem[_41575 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41575 + 136 len _43758 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41575 + 242 len 22]
                                                    else:
                                                        mem[_41575 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41575 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41575 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _38921 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38921] = 26
                                                mem[_38921 + 32] = 'SafeMath: division by zero'
                                                if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41891 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41892 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41892 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44390 = mem[_41892]
                                                    mem[_41891 + 132 len floor32(mem[_41892])] = mem[_41892 + 32 len floor32(mem[_41892])]
                                                    mem[_41891 + floor32(mem[_41892]) + -(mem[_41892] % 32) + 164 len mem[_41892] % 32] = mem[_41892 + -(mem[_41892] % 32) + floor32(mem[_41892]) + 64 len mem[_41892] % 32]
                                                    call stakingTokenAddress.mem[_41891 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41891 + 136 len _44390 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41891 + 242 len 22]
                                                    else:
                                                        mem[_41891 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41891 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41891 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _42265 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _42266 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_42266 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _45118 = mem[_42266]
                                                    mem[_42265 + 132 len floor32(mem[_42266])] = mem[_42266 + 32 len floor32(mem[_42266])]
                                                    mem[_42265 + floor32(mem[_42266]) + -(mem[_42266] % 32) + 164 len mem[_42266] % 32] = mem[_42266 + -(mem[_42266] % 32) + floor32(mem[_42266]) + 64 len mem[_42266] % 32]
                                                    call stakingTokenAddress.mem[_42265 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_42265 + 136 len _45118 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42265 + 242 len 22]
                                                    else:
                                                        mem[_42265 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_42265 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42265 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _34252 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34252] = 26
                                            mem[_34252 + 32] = 'SafeMath: division by zero'
                                            if not totalStakes:
                                                revert with 0, 'SafeMath: division by zero'
                                            if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _36322 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36322] = 30
                                            mem[_36322 + 32] = 'SafeMath: subtraction overflow'
                                            if t > ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 17
                                            if not accountStakes[address(msg.sender)]:
                                                _38920 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38920] = 26
                                                mem[_38920 + 32] = 'SafeMath: division by zero'
                                                if s < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41886 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41887 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41887 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44384 = mem[_41887]
                                                    mem[_41886 + 132 len floor32(mem[_41887])] = mem[_41887 + 32 len floor32(mem[_41887])]
                                                    mem[_41886 + floor32(mem[_41887]) + -(mem[_41887] % 32) + 164 len mem[_41887] % 32] = mem[_41887 + -(mem[_41887] % 32) + floor32(mem[_41887]) + 64 len mem[_41887] % 32]
                                                    call stakingTokenAddress.mem[_41886 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41886 + 136 len _44384 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41886 + 242 len 22]
                                                    else:
                                                        mem[_41886 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41886 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41886 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _42262 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _42263 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_42263 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _45112 = mem[_42263]
                                                    mem[_42262 + 132 len floor32(mem[_42263])] = mem[_42263 + 32 len floor32(mem[_42263])]
                                                    mem[_42262 + floor32(mem[_42263]) + -(mem[_42263] % 32) + 164 len mem[_42263] % 32] = mem[_42263 + -(mem[_42263] % 32) + floor32(mem[_42263]) + 64 len mem[_42263] % 32]
                                                    call stakingTokenAddress.mem[_42262 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_42262 + 136 len _45112 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42262 + 242 len 22]
                                                    else:
                                                        mem[_42262 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_42262 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42262 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored - t:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _39547 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39547] = 26
                                                mem[_39547 + 32] = 'SafeMath: division by zero'
                                                if s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _42690 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _42691 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_42691 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _45900 = mem[_42691]
                                                    mem[_42690 + 132 len floor32(mem[_42691])] = mem[_42691 + 32 len floor32(mem[_42691])]
                                                    mem[_42690 + floor32(mem[_42691]) + -(mem[_42691] % 32) + 164 len mem[_42691] % 32] = mem[_42691 + -(mem[_42691] % 32) + floor32(mem[_42691]) + 64 len mem[_42691] % 32]
                                                    call stakingTokenAddress.mem[_42690 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_42690 + 136 len _45900 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42690 + 242 len 22]
                                                    else:
                                                        mem[_42690 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_42690 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42690 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _43158 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _43159 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_43159 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _46683 = mem[_43159]
                                                    mem[_43158 + 132 len floor32(mem[_43159])] = mem[_43159 + 32 len floor32(mem[_43159])]
                                                    mem[_43158 + floor32(mem[_43159]) + -(mem[_43159] % 32) + 164 len mem[_43159] % 32] = mem[_43159 + -(mem[_43159] % 32) + floor32(mem[_43159]) + 64 len mem[_43159] % 32]
                                                    call stakingTokenAddress.mem[_43158 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_43158 + 136 len _46683 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_43158 + 242 len 22]
                                                    else:
                                                        mem[_43158 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_43158 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_43158 + ceil32(return_data.size) + 243 len 22]
                    else:
                        lastUpdateTime = periodFinish
                        if not msg.sender:
                            if arg1 <= 0:
                                revert with 0, 'staking 0'
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                revert with 0, 'SafeERC20: call to non-contract'
                            if not ext_code.hash(stakingTokenAddress):
                                revert with 0, 'SafeERC20: call to non-contract'
                            mem[356 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg1) >> 32
                            mem[480 len 4] = uint32(arg1)
                            call stakingTokenAddress with:
                                 gas gas_remaining wei
                                args Mask(224, 32, arg1) << 480, mem[452 len 4]
                            if not return_data.size:
                                require not ext_call.success
                                revert with 0, 'SafeERC20: low-level call failed'
                            mem[388 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[388]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[ceil32(return_data.size) + 467 len 22]
                        else:
                            mem[224] = 0
                            mem[256] = 0
                            mem[288] = 0
                            mem[320] = 0
                            mem[0] = msg.sender
                            mem[32] = 16
                            mem[64] = 480
                            mem[352] = sub_183ddbfb[address(msg.sender)].field_0
                            mem[384] = sub_183ddbfb[address(msg.sender)].field_256
                            mem[416] = sub_183ddbfb[address(msg.sender)].field_512
                            mem[448] = sub_183ddbfb[address(msg.sender)].field_768
                            idx = sub_183ddbfb[address(msg.sender)].field_768
                            s = sub_183ddbfb[address(msg.sender)].field_512
                            t = sub_183ddbfb[address(msg.sender)].field_256
                            while idx < sub_e7690c44:
                                require idx < sub_155b0a71.length
                                mem[0] = 15
                                if not t:
                                    _32464 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32464] = 26
                                    mem[_32464 + 32] = 'SafeMath: division by zero'
                                    require idx < sub_155b0a71.length
                                    mem[0] = 15
                                    if not s:
                                        _33702 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33702] = 26
                                        mem[_33702 + 32] = 'SafeMath: division by zero'
                                        idx = idx + 1
                                        s = 0
                                        t = 0
                                        continue 
                                    if sub_155b0a71[idx] * s / s != sub_155b0a71[idx]:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _33786 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33786] = 26
                                    mem[_33786 + 32] = 'SafeMath: division by zero'
                                    idx = idx + 1
                                    s = sub_155b0a71[idx] * s / 10^18
                                    t = 0
                                    continue 
                                if sub_155b0a71[idx] * t / t != sub_155b0a71[idx]:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _32584 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32584] = 26
                                mem[_32584 + 32] = 'SafeMath: division by zero'
                                require idx < sub_155b0a71.length
                                mem[0] = 15
                                if not s:
                                    _33785 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33785] = 26
                                    mem[_33785 + 32] = 'SafeMath: division by zero'
                                    idx = idx + 1
                                    s = 0
                                    t = sub_155b0a71[idx] * t / 10^18
                                    continue 
                                if sub_155b0a71[idx] * s / s != sub_155b0a71[idx]:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _33818 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33818] = 26
                                mem[_33818 + 32] = 'SafeMath: division by zero'
                                idx = idx + 1
                                s = sub_155b0a71[idx] * s / 10^18
                                t = sub_155b0a71[idx] * t / 10^18
                                continue 
                            if 0 == totalStakes:
                                _32392 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32392] = 30
                                mem[_32392 + 32] = 'SafeMath: subtraction overflow'
                                if t > rewardPerTokenStored:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 17
                                if not accountStakes[address(msg.sender)]:
                                    _33357 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33357] = 26
                                    mem[_33357 + 32] = 'SafeMath: division by zero'
                                    if s < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_183ddbfb[address(msg.sender)].field_512 = s
                                    sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                    sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                    if sub_183ddbfb[address(msg.sender)].field_0:
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _34410 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _34411 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_34411 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _35044 = mem[_34411]
                                        mem[_34410 + 132 len floor32(mem[_34411])] = mem[_34411 + 32 len floor32(mem[_34411])]
                                        mem[_34410 + floor32(mem[_34411]) + -(mem[_34411] % 32) + 164 len mem[_34411] % 32] = mem[_34411 + -(mem[_34411] % 32) + floor32(mem[_34411]) + 64 len mem[_34411] % 32]
                                        call stakingTokenAddress.mem[_34410 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_34410 + 136 len _35044 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34410 + 242 len 22]
                                        else:
                                            mem[_34410 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_34410 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34410 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _34578 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _34579 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_34579 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _35166 = mem[_34579]
                                        mem[_34578 + 132 len floor32(mem[_34579])] = mem[_34579 + 32 len floor32(mem[_34579])]
                                        mem[_34578 + floor32(mem[_34579]) + -(mem[_34579] % 32) + 164 len mem[_34579] % 32] = mem[_34579 + -(mem[_34579] % 32) + floor32(mem[_34579]) + 64 len mem[_34579] % 32]
                                        call stakingTokenAddress.mem[_34578 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_34578 + 136 len _35166 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34578 + 242 len 22]
                                        else:
                                            mem[_34578 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_34578 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34578 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    if (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != rewardPerTokenStored - t:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _33614 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33614] = 26
                                    mem[_33614 + 32] = 'SafeMath: division by zero'
                                    if s + ((rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    sub_183ddbfb[address(msg.sender)].field_512 = s + ((rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                    sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                    sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                    if sub_183ddbfb[address(msg.sender)].field_0:
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _34732 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _34733 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_34733 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _35300 = mem[_34733]
                                        mem[_34732 + 132 len floor32(mem[_34733])] = mem[_34733 + 32 len floor32(mem[_34733])]
                                        mem[_34732 + floor32(mem[_34733]) + -(mem[_34733] % 32) + 164 len mem[_34733] % 32] = mem[_34733 + -(mem[_34733] % 32) + floor32(mem[_34733]) + 64 len mem[_34733] % 32]
                                        call stakingTokenAddress.mem[_34732 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_34732 + 136 len _35300 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34732 + 242 len 22]
                                        else:
                                            mem[_34732 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_34732 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34732 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                        if arg1 <= 0:
                                            revert with 0, 'staking 0'
                                        _34868 = mem[64]
                                        mem[mem[64] + 36] = msg.sender
                                        mem[mem[64] + 68] = this.address
                                        mem[mem[64] + 100] = arg1
                                        _34869 = mem[64]
                                        mem[mem[64]] = 100
                                        mem[64] = mem[64] + 132
                                        mem[_34869 + 32 len 4] = unknown_0x23b872dd(?????)
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        if not ext_code.hash(stakingTokenAddress):
                                            revert with 0, 'SafeERC20: call to non-contract'
                                        _35499 = mem[_34869]
                                        mem[_34868 + 132 len floor32(mem[_34869])] = mem[_34869 + 32 len floor32(mem[_34869])]
                                        mem[_34868 + floor32(mem[_34869]) + -(mem[_34869] % 32) + 164 len mem[_34869] % 32] = mem[_34869 + -(mem[_34869] % 32) + floor32(mem[_34869]) + 64 len mem[_34869] % 32]
                                        call stakingTokenAddress.mem[_34868 + 132 len 4] with:
                                             gas gas_remaining wei
                                            args mem[_34868 + 136 len _35499 - 4]
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if mem[96]:
                                                require mem[96] >= 32
                                                if not mem[128]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34868 + 242 len 22]
                                        else:
                                            mem[_34868 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 'SafeERC20: low-level call failed'
                                            if return_data.size:
                                                require return_data.size >= 32
                                                if not mem[_34868 + 164]:
                                                    revert with 0, 
                                                                32,
                                                                42,
                                                                0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                mem[_34868 + ceil32(return_data.size) + 243 len 22]
                            else:
                                if block.timestamp < periodFinish:
                                    _32642 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32642] = 30
                                    mem[_32642 + 32] = 'SafeMath: subtraction overflow'
                                    if lastUpdateTime > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not block.timestamp - lastUpdateTime:
                                        _33846 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33846] = 26
                                        mem[_33846 + 32] = 'SafeMath: division by zero'
                                        if not totalStakes:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _35162 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35162] = 30
                                        mem[_35162 + 32] = 'SafeMath: subtraction overflow'
                                        if t > (0 / totalStakes) + rewardPerTokenStored:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 17
                                        if not accountStakes[address(msg.sender)]:
                                            _37488 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37488] = 26
                                            mem[_37488 + 32] = 'SafeMath: division by zero'
                                            if s < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40496 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40497 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40497 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _41592 = mem[_40497]
                                                mem[_40496 + 132 len floor32(mem[_40497])] = mem[_40497 + 32 len floor32(mem[_40497])]
                                                mem[_40496 + floor32(mem[_40497]) + -(mem[_40497] % 32) + 164 len mem[_40497] % 32] = mem[_40497 + -(mem[_40497] % 32) + floor32(mem[_40497]) + 64 len mem[_40497] % 32]
                                                call stakingTokenAddress.mem[_40496 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40496 + 136 len _41592 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40496 + 242 len 22]
                                                else:
                                                    mem[_40496 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40496 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40496 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40612 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40613 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40613 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _41904 = mem[_40613]
                                                mem[_40612 + 132 len floor32(mem[_40613])] = mem[_40613 + 32 len floor32(mem[_40613])]
                                                mem[_40612 + floor32(mem[_40613]) + -(mem[_40613] % 32) + 164 len mem[_40613] % 32] = mem[_40613 + -(mem[_40613] % 32) + floor32(mem[_40613]) + 64 len mem[_40613] % 32]
                                                call stakingTokenAddress.mem[_40612 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40612 + 136 len _41904 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40612 + 242 len 22]
                                                else:
                                                    mem[_40612 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40612 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40612 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _37963 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37963] = 26
                                            mem[_37963 + 32] = 'SafeMath: division by zero'
                                            if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40795 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40796 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40796 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42286 = mem[_40796]
                                                mem[_40795 + 132 len floor32(mem[_40796])] = mem[_40796 + 32 len floor32(mem[_40796])]
                                                mem[_40795 + floor32(mem[_40796]) + -(mem[_40796] % 32) + 164 len mem[_40796] % 32] = mem[_40796 + -(mem[_40796] % 32) + floor32(mem[_40796]) + 64 len mem[_40796] % 32]
                                                call stakingTokenAddress.mem[_40795 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40795 + 136 len _42286 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40795 + 242 len 22]
                                                else:
                                                    mem[_40795 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40795 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40795 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41021 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41022 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41022 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42710 = mem[_41022]
                                                mem[_41021 + 132 len floor32(mem[_41022])] = mem[_41022 + 32 len floor32(mem[_41022])]
                                                mem[_41021 + floor32(mem[_41022]) + -(mem[_41022] % 32) + 164 len mem[_41022] % 32] = mem[_41022 + -(mem[_41022] % 32) + floor32(mem[_41022]) + 64 len mem[_41022] % 32]
                                                call stakingTokenAddress.mem[_41021 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41021 + 136 len _42710 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41021 + 242 len 22]
                                                else:
                                                    mem[_41021 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41021 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41021 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        if (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) / block.timestamp - lastUpdateTime != rewardRate:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate):
                                            _33944 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33944] = 26
                                            mem[_33944 + 32] = 'SafeMath: division by zero'
                                            if not totalStakes:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _35491 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35491] = 30
                                            mem[_35491 + 32] = 'SafeMath: subtraction overflow'
                                            if t > (0 / totalStakes) + rewardPerTokenStored:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 17
                                            if not accountStakes[address(msg.sender)]:
                                                _37962 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37962] = 26
                                                mem[_37962 + 32] = 'SafeMath: division by zero'
                                                if s < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _40790 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _40791 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_40791 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _42280 = mem[_40791]
                                                    mem[_40790 + 132 len floor32(mem[_40791])] = mem[_40791 + 32 len floor32(mem[_40791])]
                                                    mem[_40790 + floor32(mem[_40791]) + -(mem[_40791] % 32) + 164 len mem[_40791] % 32] = mem[_40791 + -(mem[_40791] % 32) + floor32(mem[_40791]) + 64 len mem[_40791] % 32]
                                                    call stakingTokenAddress.mem[_40790 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_40790 + 136 len _42280 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_40790 + 242 len 22]
                                                    else:
                                                        mem[_40790 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_40790 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_40790 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41018 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41019 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41019 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _42704 = mem[_41019]
                                                    mem[_41018 + 132 len floor32(mem[_41019])] = mem[_41019 + 32 len floor32(mem[_41019])]
                                                    mem[_41018 + floor32(mem[_41019]) + -(mem[_41019] % 32) + 164 len mem[_41019] % 32] = mem[_41019 + -(mem[_41019] % 32) + floor32(mem[_41019]) + 64 len mem[_41019] % 32]
                                                    call stakingTokenAddress.mem[_41018 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41018 + 136 len _42704 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41018 + 242 len 22]
                                                    else:
                                                        mem[_41018 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41018 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41018 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _38418 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38418] = 26
                                                mem[_38418 + 32] = 'SafeMath: division by zero'
                                                if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41278 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41279 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41279 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43186 = mem[_41279]
                                                    mem[_41278 + 132 len floor32(mem[_41279])] = mem[_41279 + 32 len floor32(mem[_41279])]
                                                    mem[_41278 + floor32(mem[_41279]) + -(mem[_41279] % 32) + 164 len mem[_41279] % 32] = mem[_41279 + -(mem[_41279] % 32) + floor32(mem[_41279]) + 64 len mem[_41279] % 32]
                                                    call stakingTokenAddress.mem[_41278 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41278 + 136 len _43186 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41278 + 242 len 22]
                                                    else:
                                                        mem[_41278 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41278 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41278 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41586 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41587 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41587 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43781 = mem[_41587]
                                                    mem[_41586 + 132 len floor32(mem[_41587])] = mem[_41587 + 32 len floor32(mem[_41587])]
                                                    mem[_41586 + floor32(mem[_41587]) + -(mem[_41587] % 32) + 164 len mem[_41587] % 32] = mem[_41587 + -(mem[_41587] % 32) + floor32(mem[_41587]) + 64 len mem[_41587] % 32]
                                                    call stakingTokenAddress.mem[_41586 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41586 + 136 len _43781 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41586 + 242 len 22]
                                                    else:
                                                        mem[_41586 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41586 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41586 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (block.timestamp * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _34084 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34084] = 26
                                            mem[_34084 + 32] = 'SafeMath: division by zero'
                                            if not totalStakes:
                                                revert with 0, 'SafeMath: division by zero'
                                            if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _35834 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35834] = 30
                                            mem[_35834 + 32] = 'SafeMath: subtraction overflow'
                                            if t > ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 17
                                            if not accountStakes[address(msg.sender)]:
                                                _38417 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38417] = 26
                                                mem[_38417 + 32] = 'SafeMath: division by zero'
                                                if s < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41273 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41274 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41274 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43180 = mem[_41274]
                                                    mem[_41273 + 132 len floor32(mem[_41274])] = mem[_41274 + 32 len floor32(mem[_41274])]
                                                    mem[_41273 + floor32(mem[_41274]) + -(mem[_41274] % 32) + 164 len mem[_41274] % 32] = mem[_41274 + -(mem[_41274] % 32) + floor32(mem[_41274]) + 64 len mem[_41274] % 32]
                                                    call stakingTokenAddress.mem[_41273 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41273 + 136 len _43180 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41273 + 242 len 22]
                                                    else:
                                                        mem[_41273 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41273 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41273 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41583 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41584 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41584 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43775 = mem[_41584]
                                                    mem[_41583 + 132 len floor32(mem[_41584])] = mem[_41584 + 32 len floor32(mem[_41584])]
                                                    mem[_41583 + floor32(mem[_41584]) + -(mem[_41584] % 32) + 164 len mem[_41584] % 32] = mem[_41584 + -(mem[_41584] % 32) + floor32(mem[_41584]) + 64 len mem[_41584] % 32]
                                                    call stakingTokenAddress.mem[_41583 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41583 + 136 len _43775 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41583 + 242 len 22]
                                                    else:
                                                        mem[_41583 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41583 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41583 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                if ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored - t:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _38942 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38942] = 26
                                                mem[_38942 + 32] = 'SafeMath: division by zero'
                                                if s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < ((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s + (((10^18 * block.timestamp * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41896 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41897 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41897 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44405 = mem[_41897]
                                                    mem[_41896 + 132 len floor32(mem[_41897])] = mem[_41897 + 32 len floor32(mem[_41897])]
                                                    mem[_41896 + floor32(mem[_41897]) + -(mem[_41897] % 32) + 164 len mem[_41897] % 32] = mem[_41897 + -(mem[_41897] % 32) + floor32(mem[_41897]) + 64 len mem[_41897] % 32]
                                                    call stakingTokenAddress.mem[_41896 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41896 + 136 len _44405 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41896 + 242 len 22]
                                                    else:
                                                        mem[_41896 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41896 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41896 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _42274 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _42275 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_42275 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _45140 = mem[_42275]
                                                    mem[_42274 + 132 len floor32(mem[_42275])] = mem[_42275 + 32 len floor32(mem[_42275])]
                                                    mem[_42274 + floor32(mem[_42275]) + -(mem[_42275] % 32) + 164 len mem[_42275] % 32] = mem[_42275 + -(mem[_42275] % 32) + floor32(mem[_42275]) + 64 len mem[_42275] % 32]
                                                    call stakingTokenAddress.mem[_42274 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_42274 + 136 len _45140 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42274 + 242 len 22]
                                                    else:
                                                        mem[_42274 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_42274 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42274 + ceil32(return_data.size) + 243 len 22]
                                else:
                                    _32834 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32834] = 30
                                    mem[_32834 + 32] = 'SafeMath: subtraction overflow'
                                    if lastUpdateTime > periodFinish:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not periodFinish - lastUpdateTime:
                                        _33948 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33948] = 26
                                        mem[_33948 + 32] = 'SafeMath: division by zero'
                                        if not totalStakes:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _35495 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35495] = 30
                                        mem[_35495 + 32] = 'SafeMath: subtraction overflow'
                                        if t > (0 / totalStakes) + rewardPerTokenStored:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 17
                                        if not accountStakes[address(msg.sender)]:
                                            _37966 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37966] = 26
                                            mem[_37966 + 32] = 'SafeMath: division by zero'
                                            if s < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _40800 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _40801 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_40801 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42304 = mem[_40801]
                                                mem[_40800 + 132 len floor32(mem[_40801])] = mem[_40801 + 32 len floor32(mem[_40801])]
                                                mem[_40800 + floor32(mem[_40801]) + -(mem[_40801] % 32) + 164 len mem[_40801] % 32] = mem[_40801 + -(mem[_40801] % 32) + floor32(mem[_40801]) + 64 len mem[_40801] % 32]
                                                call stakingTokenAddress.mem[_40800 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_40800 + 136 len _42304 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40800 + 242 len 22]
                                                else:
                                                    mem[_40800 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_40800 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_40800 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41028 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41029 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41029 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _42726 = mem[_41029]
                                                mem[_41028 + 132 len floor32(mem[_41029])] = mem[_41029 + 32 len floor32(mem[_41029])]
                                                mem[_41028 + floor32(mem[_41029]) + -(mem[_41029] % 32) + 164 len mem[_41029] % 32] = mem[_41029 + -(mem[_41029] % 32) + floor32(mem[_41029]) + 64 len mem[_41029] % 32]
                                                call stakingTokenAddress.mem[_41028 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41028 + 136 len _42726 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41028 + 242 len 22]
                                                else:
                                                    mem[_41028 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41028 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41028 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _38420 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38420] = 26
                                            mem[_38420 + 32] = 'SafeMath: division by zero'
                                            if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                            sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                            sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                            if sub_183ddbfb[address(msg.sender)].field_0:
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41288 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41289 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41289 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43210 = mem[_41289]
                                                mem[_41288 + 132 len floor32(mem[_41289])] = mem[_41289 + 32 len floor32(mem[_41289])]
                                                mem[_41288 + floor32(mem[_41289]) + -(mem[_41289] % 32) + 164 len mem[_41289] % 32] = mem[_41289 + -(mem[_41289] % 32) + floor32(mem[_41289]) + 64 len mem[_41289] % 32]
                                                call stakingTokenAddress.mem[_41288 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41288 + 136 len _43210 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41288 + 242 len 22]
                                                else:
                                                    mem[_41288 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41288 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41288 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                if arg1 <= 0:
                                                    revert with 0, 'staking 0'
                                                _41602 = mem[64]
                                                mem[mem[64] + 36] = msg.sender
                                                mem[mem[64] + 68] = this.address
                                                mem[mem[64] + 100] = arg1
                                                _41603 = mem[64]
                                                mem[mem[64]] = 100
                                                mem[64] = mem[64] + 132
                                                mem[_41603 + 32 len 4] = unknown_0x23b872dd(?????)
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                if not ext_code.hash(stakingTokenAddress):
                                                    revert with 0, 'SafeERC20: call to non-contract'
                                                _43809 = mem[_41603]
                                                mem[_41602 + 132 len floor32(mem[_41603])] = mem[_41603 + 32 len floor32(mem[_41603])]
                                                mem[_41602 + floor32(mem[_41603]) + -(mem[_41603] % 32) + 164 len mem[_41603] % 32] = mem[_41603 + -(mem[_41603] % 32) + floor32(mem[_41603]) + 64 len mem[_41603] % 32]
                                                call stakingTokenAddress.mem[_41602 + 132 len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[_41602 + 136 len _43809 - 4]
                                                if not return_data.size:
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if mem[96]:
                                                        require mem[96] >= 32
                                                        if not mem[128]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41602 + 242 len 22]
                                                else:
                                                    mem[_41602 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    if not ext_call.success:
                                                        revert with 0, 'SafeERC20: low-level call failed'
                                                    if return_data.size:
                                                        require return_data.size >= 32
                                                        if not mem[_41602 + 164]:
                                                            revert with 0, 
                                                                        32,
                                                                        42,
                                                                        0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                        mem[_41602 + ceil32(return_data.size) + 243 len 22]
                                    else:
                                        if (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) / periodFinish - lastUpdateTime != rewardRate:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not (periodFinish * rewardRate) - (lastUpdateTime * rewardRate):
                                            _34089 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34089] = 26
                                            mem[_34089 + 32] = 'SafeMath: division by zero'
                                            if not totalStakes:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _35840 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35840] = 30
                                            mem[_35840 + 32] = 'SafeMath: subtraction overflow'
                                            if t > (0 / totalStakes) + rewardPerTokenStored:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 17
                                            if not accountStakes[address(msg.sender)]:
                                                _38419 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38419] = 26
                                                mem[_38419 + 32] = 'SafeMath: division by zero'
                                                if s < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41283 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41284 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41284 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43204 = mem[_41284]
                                                    mem[_41283 + 132 len floor32(mem[_41284])] = mem[_41284 + 32 len floor32(mem[_41284])]
                                                    mem[_41283 + floor32(mem[_41284]) + -(mem[_41284] % 32) + 164 len mem[_41284] % 32] = mem[_41284 + -(mem[_41284] % 32) + floor32(mem[_41284]) + 64 len mem[_41284] % 32]
                                                    call stakingTokenAddress.mem[_41283 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41283 + 136 len _43204 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41283 + 242 len 22]
                                                    else:
                                                        mem[_41283 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41283 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41283 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41599 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41600 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41600 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _43803 = mem[_41600]
                                                    mem[_41599 + 132 len floor32(mem[_41600])] = mem[_41600 + 32 len floor32(mem[_41600])]
                                                    mem[_41599 + floor32(mem[_41600]) + -(mem[_41600] % 32) + 164 len mem[_41600] % 32] = mem[_41600 + -(mem[_41600] % 32) + floor32(mem[_41600]) + 64 len mem[_41600] % 32]
                                                    call stakingTokenAddress.mem[_41599 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41599 + 136 len _43803 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41599 + 242 len 22]
                                                    else:
                                                        mem[_41599 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41599 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41599 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                if (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != (0 / totalStakes) + rewardPerTokenStored - t:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _38944 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38944] = 26
                                                mem[_38944 + 32] = 'SafeMath: division by zero'
                                                if s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < (0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s + ((0 / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41912 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41913 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41913 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44435 = mem[_41913]
                                                    mem[_41912 + 132 len floor32(mem[_41913])] = mem[_41913 + 32 len floor32(mem[_41913])]
                                                    mem[_41912 + floor32(mem[_41913]) + -(mem[_41913] % 32) + 164 len mem[_41913] % 32] = mem[_41913 + -(mem[_41913] % 32) + floor32(mem[_41913]) + 64 len mem[_41913] % 32]
                                                    call stakingTokenAddress.mem[_41912 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41912 + 136 len _44435 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41912 + 242 len 22]
                                                    else:
                                                        mem[_41912 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41912 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41912 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _42298 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _42299 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_42299 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _45178 = mem[_42299]
                                                    mem[_42298 + 132 len floor32(mem[_42299])] = mem[_42299 + 32 len floor32(mem[_42299])]
                                                    mem[_42298 + floor32(mem[_42299]) + -(mem[_42299] % 32) + 164 len mem[_42299] % 32] = mem[_42299 + -(mem[_42299] % 32) + floor32(mem[_42299]) + 64 len mem[_42299] % 32]
                                                    call stakingTokenAddress.mem[_42298 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_42298 + 136 len _45178 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42298 + 242 len 22]
                                                    else:
                                                        mem[_42298 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_42298 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42298 + ceil32(return_data.size) + 243 len 22]
                                        else:
                                            if (10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / (periodFinish * rewardRate) - (lastUpdateTime * rewardRate) != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _34264 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34264] = 26
                                            mem[_34264 + 32] = 'SafeMath: division by zero'
                                            if not totalStakes:
                                                revert with 0, 'SafeMath: division by zero'
                                            if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored < rewardPerTokenStored:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _36345 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36345] = 30
                                            mem[_36345 + 32] = 'SafeMath: subtraction overflow'
                                            if t > ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 17
                                            if not accountStakes[address(msg.sender)]:
                                                _38943 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38943] = 26
                                                mem[_38943 + 32] = 'SafeMath: division by zero'
                                                if s < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _41907 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _41908 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_41908 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _44429 = mem[_41908]
                                                    mem[_41907 + 132 len floor32(mem[_41908])] = mem[_41908 + 32 len floor32(mem[_41908])]
                                                    mem[_41907 + floor32(mem[_41908]) + -(mem[_41908] % 32) + 164 len mem[_41908] % 32] = mem[_41908 + -(mem[_41908] % 32) + floor32(mem[_41908]) + 64 len mem[_41908] % 32]
                                                    call stakingTokenAddress.mem[_41907 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_41907 + 136 len _44429 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41907 + 242 len 22]
                                                    else:
                                                        mem[_41907 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_41907 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_41907 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _42295 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _42296 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_42296 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _45172 = mem[_42296]
                                                    mem[_42295 + 132 len floor32(mem[_42296])] = mem[_42296 + 32 len floor32(mem[_42296])]
                                                    mem[_42295 + floor32(mem[_42296]) + -(mem[_42296] % 32) + 164 len mem[_42296] % 32] = mem[_42296 + -(mem[_42296] % 32) + floor32(mem[_42296]) + 64 len mem[_42296] % 32]
                                                    call stakingTokenAddress.mem[_42295 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_42295 + 136 len _45172 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42295 + 242 len 22]
                                                    else:
                                                        mem[_42295 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_42295 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42295 + ceil32(return_data.size) + 243 len 22]
                                            else:
                                                if ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / accountStakes[address(msg.sender)] != ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes) + rewardPerTokenStored - t:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _39574 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39574] = 26
                                                mem[_39574 + 32] = 'SafeMath: division by zero'
                                                if s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18) < ((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_183ddbfb[address(msg.sender)].field_512 = s + (((10^18 * periodFinish * rewardRate) - (10^18 * lastUpdateTime * rewardRate) / totalStakes * accountStakes[address(msg.sender)]) + (rewardPerTokenStored * accountStakes[address(msg.sender)]) - (t * accountStakes[address(msg.sender)]) / 10^18)
                                                sub_183ddbfb[address(msg.sender)].field_256 = rewardPerTokenStored
                                                sub_183ddbfb[address(msg.sender)].field_768 = sub_e7690c44
                                                if sub_183ddbfb[address(msg.sender)].field_0:
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _42718 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _42719 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_42719 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _45952 = mem[_42719]
                                                    mem[_42718 + 132 len floor32(mem[_42719])] = mem[_42719 + 32 len floor32(mem[_42719])]
                                                    mem[_42718 + floor32(mem[_42719]) + -(mem[_42719] % 32) + 164 len mem[_42719] % 32] = mem[_42719 + -(mem[_42719] % 32) + floor32(mem[_42719]) + 64 len mem[_42719] % 32]
                                                    call stakingTokenAddress.mem[_42718 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_42718 + 136 len _45952 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42718 + 242 len 22]
                                                    else:
                                                        mem[_42718 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_42718 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_42718 + ceil32(return_data.size) + 243 len 22]
                                                else:
                                                    sub_183ddbfb[address(msg.sender)].field_0 = block.timestamp
                                                    if arg1 <= 0:
                                                        revert with 0, 'staking 0'
                                                    _43198 = mem[64]
                                                    mem[mem[64] + 36] = msg.sender
                                                    mem[mem[64] + 68] = this.address
                                                    mem[mem[64] + 100] = arg1
                                                    _43199 = mem[64]
                                                    mem[mem[64]] = 100
                                                    mem[64] = mem[64] + 132
                                                    mem[_43199 + 32 len 4] = unknown_0x23b872dd(?????)
                                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    if not ext_code.hash(stakingTokenAddress):
                                                        revert with 0, 'SafeERC20: call to non-contract'
                                                    _46744 = mem[_43199]
                                                    mem[_43198 + 132 len floor32(mem[_43199])] = mem[_43199 + 32 len floor32(mem[_43199])]
                                                    mem[_43198 + floor32(mem[_43199]) + -(mem[_43199] % 32) + 164 len mem[_43199] % 32] = mem[_43199 + -(mem[_43199] % 32) + floor32(mem[_43199]) + 64 len mem[_43199] % 32]
                                                    call stakingTokenAddress.mem[_43198 + 132 len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[_43198 + 136 len _46744 - 4]
                                                    if not return_data.size:
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if mem[96]:
                                                            require mem[96] >= 32
                                                            if not mem[128]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_43198 + 242 len 22]
                                                    else:
                                                        mem[_43198 + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if not ext_call.success:
                                                            revert with 0, 'SafeERC20: low-level call failed'
                                                        if return_data.size:
                                                            require return_data.size >= 32
                                                            if not mem[_43198 + 164]:
                                                                revert with 0, 
                                                                            32,
                                                                            42,
                                                                            0x6e5361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                                            mem[_43198 + ceil32(return_data.size) + 243 len 22]
    if arg1 + totalStakes < totalStakes:
        revert with 0, 'SafeMath: addition overflow'
    totalStakes += arg1
    if arg1 + accountStakes[msg.sender] < accountStakes[msg.sender]:
        revert with 0, 'SafeMath: addition overflow'
    accountStakes[msg.sender] += arg1
    emit Staked(arg1, msg.sender);
    if stor1 + 1 != stor1:
        revert with 0, 'ReentrancyGuard: reentrant call'
}



}

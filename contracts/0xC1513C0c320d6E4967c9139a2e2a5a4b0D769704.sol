contract main {




// =====================  Runtime code  =====================


#
#  - transferFrom(address arg1, address arg2, uint256 arg3)
#  - deliver(uint256 arg1)
#  - transfer(address arg1, uint256 arg2)
#
const name = 't.me/wrongholefinance', 0

const decimals = 11

const symbol = 'Stepbro', 0


address owner;
mapping of uint256 stor1;
mapping of uint256 stor2;
mapping of uint256 allowance;
mapping of uint8 stor4;
mapping of uint8 stor5;
array of address stor6;
array of address stor7;
uint256 totalSupply;
uint256 stor9;
uint256 totalFees;
uint256 totalBurn;
uint256 totalCharity;
uint256 stor13;
uint256 stor14;
uint256 stor15;

function totalFees() payable {
    return totalFees
}

function totalSupply() payable {
    return totalSupply
}

function totalBurn() payable {
    return totalBurn
}

function owner() payable {
    return owner
}

function isExcluded(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor4[address(arg1)])
}

function totalCharity() payable {
    return totalCharity
}

function allowance(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return allowance[address(arg1)][address(arg2)]
}

function isCharity(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor5[address(arg1)])
}

function _fallback() payable {
    revert
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function approve(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = arg2
    emit Approval(arg2, msg.sender, arg1);
    return 1
}

function setAsCharityAccount(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg1 == 0x60ae616a2155ee3d9a68541ba4544862310933d4:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    'The TraderJoe router can not be the charity account.'
    if stor5[address(arg1)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Account is already charity account'
    stor5[address(arg1)] = 1
    stor7.length++
    stor7[stor7.length] = arg1
}

function decreaseAllowance(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if arg2 > allowance[address(msg.sender)][address(arg1)]:
        revert with 0, 32, 37, 0x6545524332303a2064656372656173656420616c6c6f77616e63652062656c6f77207a6572, mem[165 len 27] >> 40, 0
    if allowance[address(msg.sender)][address(arg1)] < arg2:
        revert with 'NH{q', 17
    if not msg.sender:
        revert with 0, 'ERC20: approve from the zero address'
    if not arg1:
        revert with 0, 'ERC20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] -= arg2
    emit Approval((allowance[address(msg.sender)][address(arg1)] - arg2), msg.sender, arg1);
    return 1
}

function increaseAllowance(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if allowance[address(msg.sender)][address(arg1)] > -arg2 - 1:
        revert with 'NH{q', 17
    if allowance[address(msg.sender)][address(arg1)] + arg2 < allowance[address(msg.sender)][address(arg1)]:
        revert with 0, 'SafeMath: addition overflow'
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] += arg2
    emit Approval((allowance[address(msg.sender)][address(arg1)] + arg2), msg.sender, arg1);
    return 1
}

function includeAccount(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not stor4[address(arg1)]:
        revert with 0, 'Account is already excluded'
    idx = 0
    while idx < stor6.length:
        mem[0] = 6
        if stor6[idx] != arg1:
            if idx == -1:
                revert with 'NH{q', 17
            idx = idx + 1
            continue 
        if stor6.length < 1:
            revert with 'NH{q', 17
        if stor6.length - 1 >= stor6.length:
            revert with 'NH{q', 50
        if idx >= stor6.length:
            revert with 'NH{q', 50
        stor6[idx] = stor6[stor6.length]
        stor2[address(arg1)] = 0
        stor4[address(arg1)] = 0
        if not stor6.length:
            revert with 'NH{q', 49
        stor6[stor6.length] = 0
        stor6.length--
}

function tokenFromReflection(uint256 arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if arg1 > stor9:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
    idx = 0
    s = totalSupply
    t = stor9
    while idx < stor6.length:
        mem[0] = stor6[idx]
        mem[32] = 1
        if stor1[stor6[idx]] > t:
            _92 = mem[64]
            mem[64] = mem[64] + 64
            mem[_92] = 26
            mem[_92 + 32] = 'SafeMath: division by zero'
            if totalSupply <= 0:
                _96 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_96 + idx + 68] = mem[_92 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_96 + 94] = 0
                revert with memory
                  from mem[64]
                   len _96 + -mem[64] + 100
            if not totalSupply:
                revert with 'NH{q', 18
            _112 = mem[64]
            mem[64] = mem[64] + 64
            mem[_112] = 26
            mem[_112 + 32] = 'SafeMath: division by zero'
            if stor9 / totalSupply > 0:
                if not stor9 / totalSupply:
                    revert with 'NH{q', 18
                return (arg1 / stor9 / totalSupply)
            _119 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_119 + idx + 68] = mem[_112 + idx + 32]
                idx = idx + 32
                continue 
            mem[_119 + 94] = 0
            revert with memory
              from mem[64]
               len _119 + -mem[64] + 100
        if idx >= stor6.length:
            revert with 'NH{q', 50
        mem[0] = stor6[idx]
        mem[32] = 2
        if stor2[stor6[idx]] > s:
            _97 = mem[64]
            mem[64] = mem[64] + 64
            mem[_97] = 26
            mem[_97 + 32] = 'SafeMath: division by zero'
            if totalSupply <= 0:
                _99 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_99 + idx + 68] = mem[_97 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_99 + 94] = 0
                revert with memory
                  from mem[64]
                   len _99 + -mem[64] + 100
            if not totalSupply:
                revert with 'NH{q', 18
            _120 = mem[64]
            mem[64] = mem[64] + 64
            mem[_120] = 26
            mem[_120 + 32] = 'SafeMath: division by zero'
            if stor9 / totalSupply > 0:
                if not stor9 / totalSupply:
                    revert with 'NH{q', 18
                return (arg1 / stor9 / totalSupply)
            _123 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_123 + idx + 68] = mem[_120 + idx + 32]
                idx = idx + 32
                continue 
            mem[_123 + 94] = 0
            revert with memory
              from mem[64]
               len _123 + -mem[64] + 100
        if idx >= stor6.length:
            revert with 'NH{q', 50
        mem[0] = stor6[idx]
        mem[32] = 1
        _95 = mem[64]
        mem[64] = mem[64] + 64
        mem[_95] = 30
        mem[_95 + 32] = 'SafeMath: subtraction overflow'
        if stor1[stor6[idx]] > t:
            _98 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_98 + idx + 68] = mem[_95 + idx + 32]
                idx = idx + 32
                continue 
            mem[_98 + 98] = 0
            revert with memory
              from mem[64]
               len _98 + -mem[64] + 100
        if t < stor1[stor6[idx]]:
            revert with 'NH{q', 17
        if idx >= stor6.length:
            revert with 'NH{q', 50
        mem[0] = stor6[idx]
        mem[32] = 2
        _116 = mem[64]
        mem[64] = mem[64] + 64
        mem[_116] = 30
        mem[_116 + 32] = 'SafeMath: subtraction overflow'
        if stor2[stor6[idx]] <= s:
            if s < stor2[stor6[idx]]:
                revert with 'NH{q', 17
            if idx == -1:
                revert with 'NH{q', 17
            idx = idx + 1
            s = s - stor2[stor6[idx]]
            t = t - stor1[stor6[idx]]
            continue 
        _121 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[_121 + idx + 68] = mem[_116 + idx + 32]
            idx = idx + 32
            continue 
        mem[_121 + 98] = 0
        revert with memory
          from mem[64]
           len _121 + -mem[64] + 100
    if totalSupply <= 0:
        revert with 0, 'SafeMath: division by zero', 0
    if not totalSupply:
        revert with 'NH{q', 18
    if t >= stor9 / totalSupply:
        if s <= 0:
            revert with 0, 'SafeMath: division by zero', 0
        if not s:
            revert with 'NH{q', 18
        if t / s <= 0:
            revert with 0, 'SafeMath: division by zero', 0
        if not t / s:
            revert with 'NH{q', 18
        return (arg1 / t / s)
    if totalSupply <= 0:
        revert with 0, 'SafeMath: division by zero', 0
    if not totalSupply:
        revert with 'NH{q', 18
    if stor9 / totalSupply <= 0:
        revert with 0, 'SafeMath: division by zero', 0
    if not stor9 / totalSupply:
        revert with 'NH{q', 18
    return (arg1 / stor9 / totalSupply)
}

function balanceOf(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if stor4[address(arg1)]:
        return stor2[address(arg1)]
    mem[0] = arg1
    mem[32] = 1
    if stor1[address(arg1)] > stor9:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
    idx = 0
    s = totalSupply
    t = stor9
    while idx < stor6.length:
        mem[0] = stor6[idx]
        mem[32] = 1
        if stor1[stor6[idx]] > t:
            _97 = mem[64]
            mem[64] = mem[64] + 64
            mem[_97] = 26
            mem[_97 + 32] = 'SafeMath: division by zero'
            if totalSupply <= 0:
                _101 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_101 + idx + 68] = mem[_97 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_101 + 94] = 0
                revert with memory
                  from mem[64]
                   len _101 + -mem[64] + 100
            if not totalSupply:
                revert with 'NH{q', 18
            _117 = mem[64]
            mem[64] = mem[64] + 64
            mem[_117] = 26
            mem[_117 + 32] = 'SafeMath: division by zero'
            if stor9 / totalSupply > 0:
                if not stor9 / totalSupply:
                    revert with 'NH{q', 18
                return (stor1[address(arg1)] / stor9 / totalSupply)
            _124 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_124 + idx + 68] = mem[_117 + idx + 32]
                idx = idx + 32
                continue 
            mem[_124 + 94] = 0
            revert with memory
              from mem[64]
               len _124 + -mem[64] + 100
        if idx >= stor6.length:
            revert with 'NH{q', 50
        mem[0] = stor6[idx]
        mem[32] = 2
        if stor2[stor6[idx]] > s:
            _102 = mem[64]
            mem[64] = mem[64] + 64
            mem[_102] = 26
            mem[_102 + 32] = 'SafeMath: division by zero'
            if totalSupply <= 0:
                _104 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_104 + idx + 68] = mem[_102 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_104 + 94] = 0
                revert with memory
                  from mem[64]
                   len _104 + -mem[64] + 100
            if not totalSupply:
                revert with 'NH{q', 18
            _125 = mem[64]
            mem[64] = mem[64] + 64
            mem[_125] = 26
            mem[_125 + 32] = 'SafeMath: division by zero'
            if stor9 / totalSupply > 0:
                if not stor9 / totalSupply:
                    revert with 'NH{q', 18
                return (stor1[address(arg1)] / stor9 / totalSupply)
            _128 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_128 + idx + 68] = mem[_125 + idx + 32]
                idx = idx + 32
                continue 
            mem[_128 + 94] = 0
            revert with memory
              from mem[64]
               len _128 + -mem[64] + 100
        if idx >= stor6.length:
            revert with 'NH{q', 50
        mem[0] = stor6[idx]
        mem[32] = 1
        _100 = mem[64]
        mem[64] = mem[64] + 64
        mem[_100] = 30
        mem[_100 + 32] = 'SafeMath: subtraction overflow'
        if stor1[stor6[idx]] > t:
            _103 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_103 + idx + 68] = mem[_100 + idx + 32]
                idx = idx + 32
                continue 
            mem[_103 + 98] = 0
            revert with memory
              from mem[64]
               len _103 + -mem[64] + 100
        if t < stor1[stor6[idx]]:
            revert with 'NH{q', 17
        if idx >= stor6.length:
            revert with 'NH{q', 50
        mem[0] = stor6[idx]
        mem[32] = 2
        _121 = mem[64]
        mem[64] = mem[64] + 64
        mem[_121] = 30
        mem[_121 + 32] = 'SafeMath: subtraction overflow'
        if stor2[stor6[idx]] <= s:
            if s < stor2[stor6[idx]]:
                revert with 'NH{q', 17
            if idx == -1:
                revert with 'NH{q', 17
            idx = idx + 1
            s = s - stor2[stor6[idx]]
            t = t - stor1[stor6[idx]]
            continue 
        _126 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[_126 + idx + 68] = mem[_121 + idx + 32]
            idx = idx + 32
            continue 
        mem[_126 + 98] = 0
        revert with memory
          from mem[64]
           len _126 + -mem[64] + 100
    if totalSupply <= 0:
        revert with 0, 'SafeMath: division by zero', 0
    if not totalSupply:
        revert with 'NH{q', 18
    if t >= stor9 / totalSupply:
        if s <= 0:
            revert with 0, 'SafeMath: division by zero', 0
        if not s:
            revert with 'NH{q', 18
        if t / s <= 0:
            revert with 0, 'SafeMath: division by zero', 0
        if not t / s:
            revert with 'NH{q', 18
        return (stor1[address(arg1)] / t / s)
    if totalSupply <= 0:
        revert with 0, 'SafeMath: division by zero', 0
    if not totalSupply:
        revert with 'NH{q', 18
    if stor9 / totalSupply <= 0:
        revert with 0, 'SafeMath: division by zero', 0
    if not stor9 / totalSupply:
        revert with 'NH{q', 18
    return (stor1[address(arg1)] / stor9 / totalSupply)
}

function excludeAccount(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg1 == 0x60ae616a2155ee3d9a68541ba4544862310933d4:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'We can not exclude TraderJoe router.'
    if stor4[address(arg1)]:
        revert with 0, 'Account is already excluded'
    if stor1[address(arg1)] > 0:
        mem[0] = arg1
        mem[32] = 1
        if stor1[address(arg1)] > stor9:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
        idx = 0
        s = totalSupply
        t = stor9
        while idx < stor6.length:
            mem[0] = stor6[idx]
            mem[32] = 1
            if stor1[stor6[idx]] > t:
                _107 = mem[64]
                mem[64] = mem[64] + 64
                mem[_107] = 26
                mem[_107 + 32] = 'SafeMath: division by zero'
                if totalSupply <= 0:
                    _111 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_111 + idx + 68] = mem[_107 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_111 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _111 + -mem[64] + 100
                if not totalSupply:
                    revert with 'NH{q', 18
                _127 = mem[64]
                mem[64] = mem[64] + 64
                mem[_127] = 26
                mem[_127 + 32] = 'SafeMath: division by zero'
                if stor9 / totalSupply > 0:
                    if not stor9 / totalSupply:
                        revert with 'NH{q', 18
                    stor2[address(arg1)] = stor1[address(arg1)] / stor9 / totalSupply
                    stor4[address(arg1)] = 1
                    stor6.length++
                    stor6[stor6.length] = arg1
                _134 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_134 + idx + 68] = mem[_127 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_134 + 94] = 0
                revert with memory
                  from mem[64]
                   len _134 + -mem[64] + 100
            if idx >= stor6.length:
                revert with 'NH{q', 50
            mem[0] = stor6[idx]
            mem[32] = 2
            if stor2[stor6[idx]] > s:
                _112 = mem[64]
                mem[64] = mem[64] + 64
                mem[_112] = 26
                mem[_112 + 32] = 'SafeMath: division by zero'
                if totalSupply <= 0:
                    _114 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_114 + idx + 68] = mem[_112 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_114 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _114 + -mem[64] + 100
                if not totalSupply:
                    revert with 'NH{q', 18
                _135 = mem[64]
                mem[64] = mem[64] + 64
                mem[_135] = 26
                mem[_135 + 32] = 'SafeMath: division by zero'
                if stor9 / totalSupply > 0:
                    if not stor9 / totalSupply:
                        revert with 'NH{q', 18
                    stor2[address(arg1)] = stor1[address(arg1)] / stor9 / totalSupply
                    stor4[address(arg1)] = 1
                    stor6.length++
                    stor6[stor6.length] = arg1
                _138 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_138 + idx + 68] = mem[_135 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_138 + 94] = 0
                revert with memory
                  from mem[64]
                   len _138 + -mem[64] + 100
            if idx >= stor6.length:
                revert with 'NH{q', 50
            mem[0] = stor6[idx]
            mem[32] = 1
            _110 = mem[64]
            mem[64] = mem[64] + 64
            mem[_110] = 30
            mem[_110 + 32] = 'SafeMath: subtraction overflow'
            if stor1[stor6[idx]] > t:
                _113 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_113 + idx + 68] = mem[_110 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_113 + 98] = 0
                revert with memory
                  from mem[64]
                   len _113 + -mem[64] + 100
            if t < stor1[stor6[idx]]:
                revert with 'NH{q', 17
            if idx >= stor6.length:
                revert with 'NH{q', 50
            mem[0] = stor6[idx]
            mem[32] = 2
            _131 = mem[64]
            mem[64] = mem[64] + 64
            mem[_131] = 30
            mem[_131 + 32] = 'SafeMath: subtraction overflow'
            if stor2[stor6[idx]] <= s:
                if s < stor2[stor6[idx]]:
                    revert with 'NH{q', 17
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                s = s - stor2[stor6[idx]]
                t = t - stor1[stor6[idx]]
                continue 
            _136 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_136 + idx + 68] = mem[_131 + idx + 32]
                idx = idx + 32
                continue 
            mem[_136 + 98] = 0
            revert with memory
              from mem[64]
               len _136 + -mem[64] + 100
        if totalSupply <= 0:
            revert with 0, 'SafeMath: division by zero', 0
        if not totalSupply:
            revert with 'NH{q', 18
        if t >= stor9 / totalSupply:
            if s <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            if not s:
                revert with 'NH{q', 18
            if t / s <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            if not t / s:
                revert with 'NH{q', 18
            stor2[address(arg1)] = stor1[address(arg1)] / t / s
        else:
            if totalSupply <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            if not totalSupply:
                revert with 'NH{q', 18
            if stor9 / totalSupply <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            if not stor9 / totalSupply:
                revert with 'NH{q', 18
            stor2[address(arg1)] = stor1[address(arg1)] / stor9 / totalSupply
    stor4[address(arg1)] = 1
    stor6.length++
    stor6[stor6.length] = arg1
}

function reflectionFromToken(uint256 arg1, bool arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if arg1 > totalSupply:
        revert with 0, 'Amount must be less than supply'
    if arg2:
        if not arg1:
            mem[96] = 26
            mem[128] = 'SafeMath: division by zero'
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            if not arg1:
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                mem[288] = 26
                mem[320] = 'SafeMath: division by zero'
                if not arg1:
                    mem[352] = 26
                    mem[384] = 'SafeMath: division by zero'
                    mem[416] = 26
                    mem[448] = 'SafeMath: division by zero'
                    mem[480] = 30
                    mem[512] = 'SafeMath: subtraction overflow'
                    if 0 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < 0:
                        revert with 'NH{q', 17
                    mem[544] = 30
                    mem[576] = 'SafeMath: subtraction overflow'
                    if 0 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < 0:
                        revert with 'NH{q', 17
                    mem[64] = 672
                    mem[608] = 30
                    mem[640] = 'SafeMath: subtraction overflow'
                    if 0 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < 0:
                        revert with 'NH{q', 17
                    idx = 0
                    s = totalSupply
                    t = stor9
                    while idx < stor6.length:
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        if stor1[stor6[idx]] > t:
                            _1253 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1253] = 26
                            mem[_1253 + 32] = 'SafeMath: division by zero'
                            if totalSupply <= 0:
                                _1443 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_1443 + idx + 68] = mem[_1253 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1443 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1443 + -mem[64] + 100
                            if not totalSupply:
                                revert with 'NH{q', 18
                            if not arg1:
                                return 0
                            if arg1 and stor9 / totalSupply > -1 / arg1:
                                revert with 'NH{q', 17
                            if not arg1:
                                revert with 'NH{q', 18
                            if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _3438 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3438] = 30
                            mem[_3438 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _3591 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_3591 + idx + 68] = mem[_3438 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3591 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3591 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _4761 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4761] = 30
                            mem[_4761 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _4971 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_4971 + idx + 68] = mem[_4761 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4971 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4971 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _6276 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6276] = 30
                            mem[_6276 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor9 / totalSupply)
                            _6454 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_6454 + idx + 68] = mem[_6276 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_6454 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _6454 + -mem[64] + 100
                        if idx >= stor6.length:
                            revert with 'NH{q', 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        if stor2[stor6[idx]] <= s:
                            if idx >= stor6.length:
                                revert with 'NH{q', 50
                            mem[0] = stor6[idx]
                            mem[32] = 1
                            _1378 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1378] = 30
                            mem[_1378 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor6[idx]] > t:
                                _1462 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_1462 + idx + 68] = mem[_1378 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1462 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1462 + -mem[64] + 100
                            if t < stor1[stor6[idx]]:
                                revert with 'NH{q', 17
                            if idx >= stor6.length:
                                revert with 'NH{q', 50
                            mem[0] = stor6[idx]
                            mem[32] = 2
                            _1716 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1716] = 30
                            mem[_1716 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor6[idx]] <= s:
                                if s < stor2[stor6[idx]]:
                                    revert with 'NH{q', 17
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                s = s - stor2[stor6[idx]]
                                t = t - stor1[stor6[idx]]
                                continue 
                            _1748 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_1748 + idx + 68] = mem[_1716 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1748 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _1748 + -mem[64] + 100
                        _1444 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1444] = 26
                        mem[_1444 + 32] = 'SafeMath: division by zero'
                        if totalSupply <= 0:
                            _1480 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1480 + idx + 68] = mem[_1444 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1480 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1480 + -mem[64] + 100
                        if not totalSupply:
                            revert with 'NH{q', 18
                        if not arg1:
                            return 0
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 'NH{q', 17
                        if not arg1:
                            revert with 'NH{q', 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3592 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3592] = 30
                        mem[_3592 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _3829 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_3829 + idx + 68] = mem[_3592 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3829 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3829 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _4972 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4972] = 30
                        mem[_4972 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _5194 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5194 + idx + 68] = mem[_4972 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5194 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5194 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _6455 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6455] = 30
                        mem[_6455 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor9 / totalSupply)
                        _6679 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_6679 + idx + 68] = mem[_6455 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_6679 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _6679 + -mem[64] + 100
                    if totalSupply <= 0:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not totalSupply:
                        revert with 'NH{q', 18
                    if t >= stor9 / totalSupply:
                        if s <= 0:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not s:
                            revert with 'NH{q', 18
                        if not arg1:
                            return 0
                        if arg1 and t / s > -1 / arg1:
                            revert with 'NH{q', 17
                        if not arg1:
                            revert with 'NH{q', 18
                        if arg1 * t / s / arg1 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        return (arg1 * t / s)
                    if totalSupply <= 0:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not totalSupply:
                        revert with 'NH{q', 18
                    if not arg1:
                        return 0
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    return (arg1 * stor9 / totalSupply)
                if arg1 and stor15 > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor15 / arg1 != stor15:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 'NH{q', 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 'NH{q', 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if arg1 * stor15 / 100 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 17
                idx = 0
                s = totalSupply
                t = stor9
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _9594 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9594] = 26
                        mem[_9594 + 32] = 'SafeMath: division by zero'
                        if totalSupply <= 0:
                            _9727 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_9727 + idx + 68] = mem[_9594 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_9727 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9727 + -mem[64] + 100
                        if not totalSupply:
                            revert with 'NH{q', 18
                        if not arg1:
                            if not arg1 * stor15 / 100 / 100:
                                return 0
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10527 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10527] = 30
                            mem[_10527 + 32] = 'SafeMath: subtraction overflow'
                            _11059 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11059] = 30
                            mem[_11059 + 32] = 'SafeMath: subtraction overflow'
                            _12029 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12029] = 30
                            mem[_12029 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                                if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                            _12262 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12262 + idx + 68] = mem[_12029 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12262 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12262 + -mem[64] + 100
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 'NH{q', 17
                        if not arg1:
                            revert with 'NH{q', 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _10526 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10526] = 30
                            mem[_10526 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10614 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_10614 + idx + 68] = mem[_10526 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10614 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10614 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _11058 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11058] = 30
                            mem[_11058 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11181 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11181 + idx + 68] = mem[_11058 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11181 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11181 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _12028 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12028] = 30
                            mem[_12028 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor9 / totalSupply)
                            _12261 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12261 + idx + 68] = mem[_12028 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12261 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12261 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11274 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11274] = 30
                        mem[_11274 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11421 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11421 + idx + 68] = mem[_11274 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11421 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11421 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _12445 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12445] = 30
                        mem[_12445 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _12737 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12737 + idx + 68] = mem[_12445 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12737 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12737 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _14071 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14071] = 30
                        mem[_14071 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                        _14446 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14446 + idx + 68] = mem[_14071 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14446 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14446 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 'NH{q', 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 'NH{q', 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _9669 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9669] = 30
                        mem[_9669 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _9749 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_9749 + idx + 68] = mem[_9669 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_9749 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9749 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 'NH{q', 17
                        if idx >= stor6.length:
                            revert with 'NH{q', 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _9987 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9987] = 30
                        mem[_9987 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 'NH{q', 17
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _10029 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_10029 + idx + 68] = mem[_9987 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10029 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _10029 + -mem[64] + 100
                    _9728 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9728] = 26
                    mem[_9728 + 32] = 'SafeMath: division by zero'
                    if totalSupply <= 0:
                        _9763 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_9763 + idx + 68] = mem[_9728 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_9763 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9763 + -mem[64] + 100
                    if not totalSupply:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * stor15 / 100 / 100:
                            return 0
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10616 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10616] = 30
                        mem[_10616 + 32] = 'SafeMath: subtraction overflow'
                        _11184 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11184] = 30
                        mem[_11184 + 32] = 'SafeMath: subtraction overflow'
                        _12264 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12264] = 30
                        mem[_12264 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                            if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                        _12609 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12609 + idx + 68] = mem[_12264 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12609 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12609 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _10615 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10615] = 30
                        mem[_10615 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10689 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_10689 + idx + 68] = mem[_10615 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_10689 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10689 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _11183 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11183] = 30
                        mem[_11183 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11343 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11343 + idx + 68] = mem[_11183 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11343 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11343 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _12263 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12263] = 30
                        mem[_12263 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor9 / totalSupply)
                        _12608 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12608 + idx + 68] = mem[_12263 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12608 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12608 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11424 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11424] = 30
                    mem[_11424 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _11596 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11596 + idx + 68] = mem[_11424 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11596 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11596 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _12741 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12741] = 30
                    mem[_12741 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _13021 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_13021 + idx + 68] = mem[_12741 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_13021 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13021 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _14449 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14449] = 30
                    mem[_14449 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                        if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _14828 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_14828 + idx + 68] = mem[_14449 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_14828 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14828 + -mem[64] + 100
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if t >= stor9 / totalSupply:
                    if s <= 0:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not s:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * stor15 / 100 / 100:
                            return 0
                        if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor15 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor15 / 100 / 100 * t / s:
                            revert with 'NH{q', 17
                        return (-1 * arg1 * stor15 / 100 / 100 * t / s)
                    if arg1 and t / s > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        return (arg1 * t / s)
                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 'NH{q', 17
                    if arg1 * stor15 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                        revert with 'NH{q', 17
                    return ((arg1 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if not arg1:
                    if not arg1 * stor15 / 100 / 100:
                        return 0
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    return (arg1 * stor9 / totalSupply)
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 'NH{q', 17
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 'NH{q', 17
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
            if arg1 and stor14 > -1 / arg1:
                revert with 'NH{q', 17
            if not arg1:
                revert with 'NH{q', 18
            if arg1 * stor14 / arg1 != stor14:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 'NH{q', 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if arg1 * stor14 / 100 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * stor14 / 100 / 100:
                    revert with 'NH{q', 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * stor14 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor14 / 100 / 100) < 0:
                    revert with 'NH{q', 17
                idx = 0
                s = totalSupply
                t = stor9
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _9590 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9590] = 26
                        mem[_9590 + 32] = 'SafeMath: division by zero'
                        if totalSupply <= 0:
                            _9725 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_9725 + idx + 68] = mem[_9590 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_9725 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9725 + -mem[64] + 100
                        if not totalSupply:
                            revert with 'NH{q', 18
                        if not arg1:
                            if not arg1 * stor14 / 100 / 100:
                                return 0
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10525 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10525] = 30
                            mem[_10525 + 32] = 'SafeMath: subtraction overflow'
                            _11054 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11054] = 30
                            mem[_11054 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                _11178 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11178 + idx + 68] = mem[_11054 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11178 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11178 + -mem[64] + 100
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            _12024 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12024] = 30
                            mem[_12024 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                            _12256 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12256 + idx + 68] = mem[_12024 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12256 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12256 + -mem[64] + 100
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 'NH{q', 17
                        if not arg1:
                            revert with 'NH{q', 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            _10524 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10524] = 30
                            mem[_10524 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10611 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_10611 + idx + 68] = mem[_10524 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10611 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10611 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _11053 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11053] = 30
                            mem[_11053 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11177 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11177 + idx + 68] = mem[_11053 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11177 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11177 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _12023 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12023] = 30
                            mem[_12023 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor9 / totalSupply)
                            _12255 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12255 + idx + 68] = mem[_12023 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12255 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12255 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11269 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11269] = 30
                        mem[_11269 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11416 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11416 + idx + 68] = mem[_11269 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11416 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11416 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _12438 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12438] = 30
                        mem[_12438 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _12731 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12731 + idx + 68] = mem[_12438 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12731 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12731 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _14060 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14060] = 30
                        mem[_14060 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                        _14440 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14440 + idx + 68] = mem[_14060 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14440 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14440 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 'NH{q', 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 'NH{q', 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _9668 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9668] = 30
                        mem[_9668 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _9748 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_9748 + idx + 68] = mem[_9668 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_9748 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9748 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 'NH{q', 17
                        if idx >= stor6.length:
                            revert with 'NH{q', 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _9986 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9986] = 30
                        mem[_9986 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 'NH{q', 17
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _10028 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_10028 + idx + 68] = mem[_9986 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10028 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _10028 + -mem[64] + 100
                    _9726 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9726] = 26
                    mem[_9726 + 32] = 'SafeMath: division by zero'
                    if totalSupply <= 0:
                        _9762 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_9762 + idx + 68] = mem[_9726 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_9762 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9762 + -mem[64] + 100
                    if not totalSupply:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * stor14 / 100 / 100:
                            return 0
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10613 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10613] = 30
                        mem[_10613 + 32] = 'SafeMath: subtraction overflow'
                        _11180 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11180] = 30
                        mem[_11180 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                            _11342 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11342 + idx + 68] = mem[_11180 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11342 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11342 + -mem[64] + 100
                        if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _12258 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12258] = 30
                        mem[_12258 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                        _12604 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12604 + idx + 68] = mem[_12258 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12604 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12604 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        _10612 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10612] = 30
                        mem[_10612 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10688 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_10688 + idx + 68] = mem[_10612 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_10688 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10688 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _11179 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11179] = 30
                        mem[_11179 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11341 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11341 + idx + 68] = mem[_11179 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11341 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11341 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _12257 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12257] = 30
                        mem[_12257 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor9 / totalSupply)
                        _12603 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12603 + idx + 68] = mem[_12257 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12603 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12603 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11420 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11420] = 30
                    mem[_11420 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _11590 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11590 + idx + 68] = mem[_11420 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11590 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11590 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _12736 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12736] = 30
                    mem[_12736 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _13016 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_13016 + idx + 68] = mem[_12736 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_13016 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13016 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    _14443 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14443] = 30
                    mem[_14443 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                    _14823 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_14823 + idx + 68] = mem[_14443 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_14823 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14823 + -mem[64] + 100
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if t >= stor9 / totalSupply:
                    if s <= 0:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not s:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * stor14 / 100 / 100:
                            return 0
                        if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor14 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor14 / 100 / 100 * t / s:
                            revert with 'NH{q', 17
                        if 0 > -1 * arg1 * stor14 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor14 / 100 / 100 * t / s < 0:
                            revert with 'NH{q', 17
                        return (-1 * arg1 * stor14 / 100 / 100 * t / s)
                    if arg1 and t / s > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        return (arg1 * t / s)
                    if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 'NH{q', 17
                    if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                        revert with 'NH{q', 17
                    if 0 > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                        revert with 'NH{q', 17
                    return ((arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s))
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if not arg1:
                    if not arg1 * stor14 / 100 / 100:
                        return 0
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    if 0 > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor14 / 100 / 100:
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    return (arg1 * stor9 / totalSupply)
                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 'NH{q', 17
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 'NH{q', 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
            if arg1 and stor15 > -1 / arg1:
                revert with 'NH{q', 17
            if not arg1:
                revert with 'NH{q', 18
            if arg1 * stor15 / arg1 != stor15:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[352] = 26
            mem[384] = 'SafeMath: division by zero'
            mem[416] = 26
            mem[448] = 'SafeMath: division by zero'
            mem[480] = 30
            mem[512] = 'SafeMath: subtraction overflow'
            if 0 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < 0:
                revert with 'NH{q', 17
            mem[544] = 30
            mem[576] = 'SafeMath: subtraction overflow'
            if arg1 * stor14 / 100 / 100 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < arg1 * stor14 / 100 / 100:
                revert with 'NH{q', 17
            mem[64] = 672
            mem[608] = 30
            mem[640] = 'SafeMath: subtraction overflow'
            if arg1 * stor15 / 100 / 100 > arg1 - (arg1 * stor14 / 100 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * stor14 / 100 / 100) < arg1 * stor15 / 100 / 100:
                revert with 'NH{q', 17
            idx = 0
            s = totalSupply
            t = stor9
            while idx < stor6.length:
                mem[0] = stor6[idx]
                mem[32] = 1
                if stor1[stor6[idx]] > t:
                    _9586 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9586] = 26
                    mem[_9586 + 32] = 'SafeMath: division by zero'
                    if totalSupply <= 0:
                        _9723 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_9723 + idx + 68] = mem[_9586 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_9723 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9723 + -mem[64] + 100
                    if not totalSupply:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * stor14 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                return 0
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10523 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10523] = 30
                            mem[_10523 + 32] = 'SafeMath: subtraction overflow'
                            _11050 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11050] = 30
                            mem[_11050 + 32] = 'SafeMath: subtraction overflow'
                            _12017 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12017] = 30
                            mem[_12017 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                                if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                            _12247 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12247 + idx + 68] = mem[_12017 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12247 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12247 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _10522 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10522] = 30
                            mem[_10522 + 32] = 'SafeMath: subtraction overflow'
                            _11049 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11049] = 30
                            mem[_11049 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                _11171 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11171 + idx + 68] = mem[_11049 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11171 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11171 + -mem[64] + 100
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            _12016 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12016] = 30
                            mem[_12016 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                            _12246 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12246 + idx + 68] = mem[_12016 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12246 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12246 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11266 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11266] = 30
                        mem[_11266 + 32] = 'SafeMath: subtraction overflow'
                        _12429 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12429] = 30
                        mem[_12429 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                            _12723 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12723 + idx + 68] = mem[_12429 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12723 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12723 + -mem[64] + 100
                        if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _14047 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14047] = 30
                        mem[_14047 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            return ((-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                        _14431 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14431 + idx + 68] = mem[_14047 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14431 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14431 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            _10521 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10521] = 30
                            mem[_10521 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10607 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_10607 + idx + 68] = mem[_10521 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10607 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10607 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _11047 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11047] = 30
                            mem[_11047 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11170 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11170 + idx + 68] = mem[_11047 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11170 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11170 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _12015 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12015] = 30
                            mem[_12015 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor9 / totalSupply)
                            _12245 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12245 + idx + 68] = mem[_12015 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12245 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12245 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11265 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11265] = 30
                        mem[_11265 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11409 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11409 + idx + 68] = mem[_11265 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11409 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11409 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _12428 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12428] = 30
                        mem[_12428 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _12720 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12720 + idx + 68] = mem[_12428 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12720 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12720 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _14045 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14045] = 30
                        mem[_14045 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                        _14429 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14429 + idx + 68] = mem[_14045 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14429 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14429 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _11264 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11264] = 30
                        mem[_11264 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11408 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11408 + idx + 68] = mem[_11264 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11408 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11408 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _12427 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12427] = 30
                        mem[_12427 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _12719 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12719 + idx + 68] = mem[_12427 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12719 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12719 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _14044 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14044] = 30
                        mem[_14044 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                        _14428 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14428 + idx + 68] = mem[_14044 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14428 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14428 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _12879 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12879] = 30
                    mem[_12879 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _13130 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_13130 + idx + 68] = mem[_12879 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_13130 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13130 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _14630 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14630] = 30
                    mem[_14630 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _14958 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14958 + idx + 68] = mem[_14630 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14958 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14958 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    _16192 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16192] = 30
                    mem[_16192 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _16522 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_16522 + idx + 68] = mem[_16192 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_16522 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16522 + -mem[64] + 100
                if idx >= stor6.length:
                    revert with 'NH{q', 50
                mem[0] = stor6[idx]
                mem[32] = 2
                if stor2[stor6[idx]] <= s:
                    if idx >= stor6.length:
                        revert with 'NH{q', 50
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    _9667 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9667] = 30
                    mem[_9667 + 32] = 'SafeMath: subtraction overflow'
                    if stor1[stor6[idx]] > t:
                        _9747 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_9747 + idx + 68] = mem[_9667 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_9747 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9747 + -mem[64] + 100
                    if t < stor1[stor6[idx]]:
                        revert with 'NH{q', 17
                    if idx >= stor6.length:
                        revert with 'NH{q', 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    _9985 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9985] = 30
                    mem[_9985 + 32] = 'SafeMath: subtraction overflow'
                    if stor2[stor6[idx]] <= s:
                        if s < stor2[stor6[idx]]:
                            revert with 'NH{q', 17
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        s = s - stor2[stor6[idx]]
                        t = t - stor1[stor6[idx]]
                        continue 
                    _10027 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_10027 + idx + 68] = mem[_9985 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_10027 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _10027 + -mem[64] + 100
                _9724 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9724] = 26
                mem[_9724 + 32] = 'SafeMath: division by zero'
                if totalSupply <= 0:
                    _9761 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_9761 + idx + 68] = mem[_9724 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_9761 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _9761 + -mem[64] + 100
                if not totalSupply:
                    revert with 'NH{q', 18
                if not arg1:
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            return 0
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10610 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10610] = 30
                        mem[_10610 + 32] = 'SafeMath: subtraction overflow'
                        _11176 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11176] = 30
                        mem[_11176 + 32] = 'SafeMath: subtraction overflow'
                        _12250 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12250] = 30
                        mem[_12250 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                            if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                        _12599 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12599 + idx + 68] = mem[_12250 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12599 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12599 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _10609 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10609] = 30
                        mem[_10609 + 32] = 'SafeMath: subtraction overflow'
                        _11175 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11175] = 30
                        mem[_11175 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                            _11339 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11339 + idx + 68] = mem[_11175 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11339 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11339 + -mem[64] + 100
                        if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _12249 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12249] = 30
                        mem[_12249 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                        _12598 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12598 + idx + 68] = mem[_12249 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12598 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12598 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11415 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11415] = 30
                    mem[_11415 + 32] = 'SafeMath: subtraction overflow'
                    _12730 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12730] = 30
                    mem[_12730 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                        _13012 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_13012 + idx + 68] = mem[_12730 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_13012 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13012 + -mem[64] + 100
                    if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    _14437 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14437] = 30
                    mem[_14437 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        return ((-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _14818 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_14818 + idx + 68] = mem[_14437 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_14818 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14818 + -mem[64] + 100
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor14 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        _10608 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10608] = 30
                        mem[_10608 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10687 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_10687 + idx + 68] = mem[_10608 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_10687 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10687 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _11173 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11173] = 30
                        mem[_11173 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11338 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11338 + idx + 68] = mem[_11173 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11338 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11338 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _12248 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12248] = 30
                        mem[_12248 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor9 / totalSupply)
                        _12597 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12597 + idx + 68] = mem[_12248 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12597 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12597 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11414 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11414] = 30
                    mem[_11414 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _11584 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11584 + idx + 68] = mem[_11414 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11584 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11584 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _12729 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12729] = 30
                    mem[_12729 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _13009 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_13009 + idx + 68] = mem[_12729 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_13009 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13009 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _14435 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14435] = 30
                    mem[_14435 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                        if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _14816 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_14816 + idx + 68] = mem[_14435 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_14816 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14816 + -mem[64] + 100
                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    _11413 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11413] = 30
                    mem[_11413 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _11583 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11583 + idx + 68] = mem[_11413 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11583 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11583 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _12728 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12728] = 30
                    mem[_12728 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _13008 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_13008 + idx + 68] = mem[_12728 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_13008 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13008 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    _14434 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14434] = 30
                    mem[_14434 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                    _14815 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_14815 + idx + 68] = mem[_14434 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_14815 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14815 + -mem[64] + 100
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _13136 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13136] = 30
                mem[_13136 + 32] = 'SafeMath: subtraction overflow'
                if 0 > arg1 * stor9 / totalSupply:
                    _13394 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_13394 + idx + 68] = mem[_13136 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_13394 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _13394 + -mem[64] + 100
                if arg1 * stor9 / totalSupply < 0:
                    revert with 'NH{q', 17
                _14965 = mem[64]
                mem[64] = mem[64] + 64
                mem[_14965] = 30
                mem[_14965 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    _15279 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_15279 + idx + 68] = mem[_14965 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_15279 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15279 + -mem[64] + 100
                if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                _16526 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16526] = 30
                mem[_16526 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                _16717 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_16717 + idx + 68] = mem[_16526 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_16717 + 98] = 0
                revert with memory
                  from mem[64]
                   len _16717 + -mem[64] + 100
            if totalSupply <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            if not totalSupply:
                revert with 'NH{q', 18
            if t >= stor9 / totalSupply:
                if s <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not s:
                    revert with 'NH{q', 18
                if not arg1:
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            return 0
                        if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor15 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor15 / 100 / 100 * t / s:
                            revert with 'NH{q', 17
                        return (-1 * arg1 * stor15 / 100 / 100 * t / s)
                    if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        if arg1 * stor14 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor14 / 100 / 100 * t / s:
                            revert with 'NH{q', 17
                        if 0 > -1 * arg1 * stor14 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor14 / 100 / 100 * t / s < 0:
                            revert with 'NH{q', 17
                        return (-1 * arg1 * stor14 / 100 / 100 * t / s)
                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor14 / 100 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor14 / 100 / 100 * t / s:
                        revert with 'NH{q', 17
                    if arg1 * stor15 / 100 / 100 * t / s > -1 * arg1 * stor14 / 100 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor14 / 100 / 100 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                        revert with 'NH{q', 17
                    return ((-1 * arg1 * stor14 / 100 / 100 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
                if arg1 and t / s > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor14 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        return (arg1 * t / s)
                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 'NH{q', 17
                    if arg1 * stor15 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                        revert with 'NH{q', 17
                    return ((arg1 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
                if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 'NH{q', 17
                    if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                        revert with 'NH{q', 17
                    if 0 > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                        revert with 'NH{q', 17
                    return ((arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s))
                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0:
                    revert with 'NH{q', 17
                if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                    revert with 'NH{q', 17
                if arg1 * stor15 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                    revert with 'NH{q', 17
                return ((arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
            if totalSupply <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            if not totalSupply:
                revert with 'NH{q', 18
            if not arg1:
                if not arg1 * stor14 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        return 0
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    if 0 > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                return ((-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
            if arg1 and stor9 / totalSupply > -1 / arg1:
                revert with 'NH{q', 17
            if not arg1:
                revert with 'NH{q', 18
            if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor14 / 100 / 100:
                if not arg1 * stor15 / 100 / 100:
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    return (arg1 * stor9 / totalSupply)
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 'NH{q', 17
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 'NH{q', 17
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                revert with 'NH{q', 17
            if not arg1 * stor14 / 100 / 100:
                revert with 'NH{q', 18
            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor15 / 100 / 100:
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 'NH{q', 17
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 'NH{q', 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                revert with 'NH{q', 17
            if not arg1 * stor15 / 100 / 100:
                revert with 'NH{q', 18
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if 0 > arg1 * stor9 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor9 / totalSupply < 0:
                revert with 'NH{q', 17
            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                revert with 'NH{q', 17
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                revert with 'NH{q', 17
            return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
        if arg1 and stor13 > -1 / arg1:
            revert with 'NH{q', 17
        if not arg1:
            revert with 'NH{q', 18
        if arg1 * stor13 / arg1 != stor13:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        mem[160] = 26
        mem[192] = 'SafeMath: division by zero'
        if not arg1:
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * stor13 / 100 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * stor13 / 100 / 100:
                    revert with 'NH{q', 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * stor13 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor13 / 100 / 100) < 0:
                    revert with 'NH{q', 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * stor13 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor13 / 100 / 100) < 0:
                    revert with 'NH{q', 17
                idx = 0
                s = totalSupply
                t = stor9
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _9582 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9582] = 26
                        mem[_9582 + 32] = 'SafeMath: division by zero'
                        if totalSupply <= 0:
                            _9721 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_9721 + idx + 68] = mem[_9582 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_9721 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9721 + -mem[64] + 100
                        if not totalSupply:
                            revert with 'NH{q', 18
                        if not arg1:
                            if not arg1 * stor13 / 100 / 100:
                                return 0
                            if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor13 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10520 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10520] = 30
                            mem[_10520 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _10604 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_10604 + idx + 68] = mem[_10520 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10604 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10604 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            _11042 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11042] = 30
                            mem[_11042 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _11167 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11167 + idx + 68] = mem[_11042 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11167 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11167 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _12009 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12009] = 30
                            mem[_12009 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                            _12237 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12237 + idx + 68] = mem[_12009 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12237 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12237 + -mem[64] + 100
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 'NH{q', 17
                        if not arg1:
                            revert with 'NH{q', 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor13 / 100 / 100:
                            _10519 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10519] = 30
                            mem[_10519 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10603 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_10603 + idx + 68] = mem[_10519 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10603 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10603 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _11041 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11041] = 30
                            mem[_11041 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11166 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11166 + idx + 68] = mem[_11041 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11166 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11166 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _12008 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12008] = 30
                            mem[_12008 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor9 / totalSupply)
                            _12236 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12236 + idx + 68] = mem[_12008 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12236 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12236 + -mem[64] + 100
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11259 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11259] = 30
                        mem[_11259 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _11402 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11402 + idx + 68] = mem[_11259 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11402 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11402 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _12415 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12415] = 30
                        mem[_12415 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _12713 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12713 + idx + 68] = mem[_12415 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12713 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12713 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        _14025 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14025] = 30
                        mem[_14025 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
                        _14421 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14421 + idx + 68] = mem[_14025 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14421 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14421 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 'NH{q', 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 'NH{q', 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _9666 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9666] = 30
                        mem[_9666 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _9746 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_9746 + idx + 68] = mem[_9666 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_9746 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9746 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 'NH{q', 17
                        if idx >= stor6.length:
                            revert with 'NH{q', 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _9984 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9984] = 30
                        mem[_9984 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 'NH{q', 17
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _10026 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_10026 + idx + 68] = mem[_9984 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10026 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _10026 + -mem[64] + 100
                    _9722 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9722] = 26
                    mem[_9722 + 32] = 'SafeMath: division by zero'
                    if totalSupply <= 0:
                        _9760 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_9760 + idx + 68] = mem[_9722 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_9760 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9760 + -mem[64] + 100
                    if not totalSupply:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * stor13 / 100 / 100:
                            return 0
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10606 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10606] = 30
                        mem[_10606 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _10686 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_10686 + idx + 68] = mem[_10606 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_10686 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10686 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _11169 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11169] = 30
                        mem[_11169 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _11336 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11336 + idx + 68] = mem[_11169 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11336 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11336 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _12239 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12239] = 30
                        mem[_12239 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                        _12592 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12592 + idx + 68] = mem[_12239 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12592 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12592 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        _10605 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10605] = 30
                        mem[_10605 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10685 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_10685 + idx + 68] = mem[_10605 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_10685 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10685 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _11168 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11168] = 30
                        mem[_11168 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11335 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11335 + idx + 68] = mem[_11168 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11335 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11335 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _12238 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12238] = 30
                        mem[_12238 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor9 / totalSupply)
                        _12591 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12591 + idx + 68] = mem[_12238 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12591 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12591 + -mem[64] + 100
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11407 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11407] = 30
                    mem[_11407 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _11576 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11576 + idx + 68] = mem[_11407 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11576 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11576 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    _12718 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12718] = 30
                    mem[_12718 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _13003 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_13003 + idx + 68] = mem[_12718 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_13003 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13003 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 'NH{q', 17
                    _14424 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14424] = 30
                    mem[_14424 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
                    _14807 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_14807 + idx + 68] = mem[_14424 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_14807 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14807 + -mem[64] + 100
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if t >= stor9 / totalSupply:
                    if s <= 0:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not s:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * stor13 / 100 / 100:
                            return 0
                        if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor13 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor13 / 100 / 100 * t / s:
                            revert with 'NH{q', 17
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                            revert with 'NH{q', 17
                        return (-1 * arg1 * stor13 / 100 / 100 * t / s)
                    if arg1 and t / s > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        return (arg1 * t / s)
                    if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                        revert with 'NH{q', 17
                    if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                        revert with 'NH{q', 17
                    if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                        revert with 'NH{q', 17
                    return ((arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s))
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if not arg1:
                    if not arg1 * stor13 / 100 / 100:
                        return 0
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor13 / 100 / 100:
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    return (arg1 * stor9 / totalSupply)
                if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor13 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 'NH{q', 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 'NH{q', 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
            if arg1 and stor15 > -1 / arg1:
                revert with 'NH{q', 17
            if not arg1:
                revert with 'NH{q', 18
            if arg1 * stor15 / arg1 != stor15:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[352] = 26
            mem[384] = 'SafeMath: division by zero'
            mem[416] = 26
            mem[448] = 'SafeMath: division by zero'
            mem[480] = 30
            mem[512] = 'SafeMath: subtraction overflow'
            if arg1 * stor13 / 100 / 100 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < arg1 * stor13 / 100 / 100:
                revert with 'NH{q', 17
            mem[544] = 30
            mem[576] = 'SafeMath: subtraction overflow'
            if 0 > arg1 - (arg1 * stor13 / 100 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * stor13 / 100 / 100) < 0:
                revert with 'NH{q', 17
            mem[64] = 672
            mem[608] = 30
            mem[640] = 'SafeMath: subtraction overflow'
            if arg1 * stor15 / 100 / 100 > arg1 - (arg1 * stor13 / 100 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * stor13 / 100 / 100) < arg1 * stor15 / 100 / 100:
                revert with 'NH{q', 17
            idx = 0
            s = totalSupply
            t = stor9
            while idx < stor6.length:
                mem[0] = stor6[idx]
                mem[32] = 1
                if stor1[stor6[idx]] > t:
                    _9578 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9578] = 26
                    mem[_9578 + 32] = 'SafeMath: division by zero'
                    if totalSupply <= 0:
                        _9719 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_9719 + idx + 68] = mem[_9578 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_9719 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9719 + -mem[64] + 100
                    if not totalSupply:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * stor13 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                return 0
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10518 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10518] = 30
                            mem[_10518 + 32] = 'SafeMath: subtraction overflow'
                            _11033 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11033] = 30
                            mem[_11033 + 32] = 'SafeMath: subtraction overflow'
                            _12002 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12002] = 30
                            mem[_12002 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                                if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                            _12230 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12230 + idx + 68] = mem[_12002 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12230 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12230 + -mem[64] + 100
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _10517 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10517] = 30
                            mem[_10517 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _10598 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_10598 + idx + 68] = mem[_10517 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10598 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10598 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            _11032 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11032] = 30
                            mem[_11032 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _11160 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11160 + idx + 68] = mem[_11032 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11160 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11160 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _12001 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12001] = 30
                            mem[_12001 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                            _12229 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12229 + idx + 68] = mem[_12001 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12229 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12229 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11254 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11254] = 30
                        mem[_11254 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _11396 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11396 + idx + 68] = mem[_11254 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11396 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11396 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _12404 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12404] = 30
                        mem[_12404 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _12705 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12705 + idx + 68] = mem[_12404 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12705 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12705 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _14012 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14012] = 30
                        mem[_14012 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                        _14412 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14412 + idx + 68] = mem[_14012 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14412 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14412 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            _10516 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10516] = 30
                            mem[_10516 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10597 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_10597 + idx + 68] = mem[_10516 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10597 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10597 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _11030 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11030] = 30
                            mem[_11030 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11159 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11159 + idx + 68] = mem[_11030 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11159 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11159 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _12000 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12000] = 30
                            mem[_12000 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor9 / totalSupply)
                            _12227 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12227 + idx + 68] = mem[_12000 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12227 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12227 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11253 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11253] = 30
                        mem[_11253 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11393 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11393 + idx + 68] = mem[_11253 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11393 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11393 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _12403 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12403] = 30
                        mem[_12403 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _12702 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12702 + idx + 68] = mem[_12403 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12702 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12702 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _14010 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14010] = 30
                        mem[_14010 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                        _14410 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14410 + idx + 68] = mem[_14010 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14410 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14410 + -mem[64] + 100
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _11252 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11252] = 30
                        mem[_11252 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _11392 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11392 + idx + 68] = mem[_11252 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11392 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11392 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _12402 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12402] = 30
                        mem[_12402 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _12701 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12701 + idx + 68] = mem[_12402 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12701 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12701 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        _14009 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14009] = 30
                        mem[_14009 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
                        _14409 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14409 + idx + 68] = mem[_14009 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14409 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14409 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _12862 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12862] = 30
                    mem[_12862 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _13114 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_13114 + idx + 68] = mem[_12862 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_13114 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13114 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    _14608 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14608] = 30
                    mem[_14608 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _14943 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14943 + idx + 68] = mem[_14608 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14943 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14943 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 'NH{q', 17
                    _16169 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16169] = 30
                    mem[_16169 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _16512 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_16512 + idx + 68] = mem[_16169 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_16512 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16512 + -mem[64] + 100
                if idx >= stor6.length:
                    revert with 'NH{q', 50
                mem[0] = stor6[idx]
                mem[32] = 2
                if stor2[stor6[idx]] <= s:
                    if idx >= stor6.length:
                        revert with 'NH{q', 50
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    _9665 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9665] = 30
                    mem[_9665 + 32] = 'SafeMath: subtraction overflow'
                    if stor1[stor6[idx]] > t:
                        _9745 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_9745 + idx + 68] = mem[_9665 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_9745 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9745 + -mem[64] + 100
                    if t < stor1[stor6[idx]]:
                        revert with 'NH{q', 17
                    if idx >= stor6.length:
                        revert with 'NH{q', 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    _9983 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9983] = 30
                    mem[_9983 + 32] = 'SafeMath: subtraction overflow'
                    if stor2[stor6[idx]] <= s:
                        if s < stor2[stor6[idx]]:
                            revert with 'NH{q', 17
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        s = s - stor2[stor6[idx]]
                        t = t - stor1[stor6[idx]]
                        continue 
                    _10025 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_10025 + idx + 68] = mem[_9983 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_10025 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _10025 + -mem[64] + 100
                _9720 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9720] = 26
                mem[_9720 + 32] = 'SafeMath: division by zero'
                if totalSupply <= 0:
                    _9759 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_9759 + idx + 68] = mem[_9720 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_9759 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _9759 + -mem[64] + 100
                if not totalSupply:
                    revert with 'NH{q', 18
                if not arg1:
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            return 0
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10601 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10601] = 30
                        mem[_10601 + 32] = 'SafeMath: subtraction overflow'
                        _11165 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11165] = 30
                        mem[_11165 + 32] = 'SafeMath: subtraction overflow'
                        _12233 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12233] = 30
                        mem[_12233 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                            if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                        _12585 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12585 + idx + 68] = mem[_12233 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12585 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12585 + -mem[64] + 100
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _10600 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10600] = 30
                        mem[_10600 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _10683 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_10683 + idx + 68] = mem[_10600 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_10683 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10683 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _11164 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11164] = 30
                        mem[_11164 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _11334 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11334 + idx + 68] = mem[_11164 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11334 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11334 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _12232 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12232] = 30
                        mem[_12232 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                        _12584 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12584 + idx + 68] = mem[_12232 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12584 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12584 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11401 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11401] = 30
                    mem[_11401 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                        _11571 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11571 + idx + 68] = mem[_11401 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11571 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11571 + -mem[64] + 100
                    if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    _12712 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12712] = 30
                    mem[_12712 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        _12999 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12999 + idx + 68] = mem[_12712 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12999 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12999 + -mem[64] + 100
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _14418 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14418] = 30
                    mem[_14418 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _14802 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_14802 + idx + 68] = mem[_14418 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_14802 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14802 + -mem[64] + 100
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        _10599 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10599] = 30
                        mem[_10599 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10682 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_10682 + idx + 68] = mem[_10599 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_10682 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10682 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _11162 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11162] = 30
                        mem[_11162 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11333 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11333 + idx + 68] = mem[_11162 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11333 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11333 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _12231 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12231] = 30
                        mem[_12231 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor9 / totalSupply)
                        _12582 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12582 + idx + 68] = mem[_12231 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12582 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12582 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11400 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11400] = 30
                    mem[_11400 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _11568 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11568 + idx + 68] = mem[_11400 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11568 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11568 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _12711 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12711] = 30
                    mem[_12711 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _12996 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12996 + idx + 68] = mem[_12711 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12996 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12996 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _14416 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14416] = 30
                    mem[_14416 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                        if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _14800 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_14800 + idx + 68] = mem[_14416 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_14800 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14800 + -mem[64] + 100
                if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor13 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    _11399 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11399] = 30
                    mem[_11399 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _11567 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11567 + idx + 68] = mem[_11399 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11567 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11567 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    _12710 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12710] = 30
                    mem[_12710 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _12995 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12995 + idx + 68] = mem[_12710 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12995 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12995 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 'NH{q', 17
                    _14415 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14415] = 30
                    mem[_14415 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
                    _14799 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_14799 + idx + 68] = mem[_14415 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_14799 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14799 + -mem[64] + 100
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _13121 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13121] = 30
                mem[_13121 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    _13371 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_13371 + idx + 68] = mem[_13121 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_13371 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _13371 + -mem[64] + 100
                if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                _14950 = mem[64]
                mem[64] = mem[64] + 64
                mem[_14950] = 30
                mem[_14950 + 32] = 'SafeMath: subtraction overflow'
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    _15270 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_15270 + idx + 68] = mem[_14950 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_15270 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15270 + -mem[64] + 100
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 'NH{q', 17
                _16516 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16516] = 30
                mem[_16516 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                _16710 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_16710 + idx + 68] = mem[_16516 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_16710 + 98] = 0
                revert with memory
                  from mem[64]
                   len _16710 + -mem[64] + 100
            if totalSupply <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            if not totalSupply:
                revert with 'NH{q', 18
            if t >= stor9 / totalSupply:
                if s <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not s:
                    revert with 'NH{q', 18
                if not arg1:
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            return 0
                        if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor15 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor15 / 100 / 100 * t / s:
                            revert with 'NH{q', 17
                        return (-1 * arg1 * stor15 / 100 / 100 * t / s)
                    if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        if arg1 * stor13 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor13 / 100 / 100 * t / s:
                            revert with 'NH{q', 17
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                            revert with 'NH{q', 17
                        return (-1 * arg1 * stor13 / 100 / 100 * t / s)
                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor13 / 100 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor13 / 100 / 100 * t / s:
                        revert with 'NH{q', 17
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                        revert with 'NH{q', 17
                    if arg1 * stor15 / 100 / 100 * t / s > -1 * arg1 * stor13 / 100 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                        revert with 'NH{q', 17
                    return ((-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
                if arg1 and t / s > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        return (arg1 * t / s)
                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 'NH{q', 17
                    if arg1 * stor15 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                        revert with 'NH{q', 17
                    return ((arg1 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
                if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor13 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                        revert with 'NH{q', 17
                    if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                        revert with 'NH{q', 17
                    if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                        revert with 'NH{q', 17
                    return ((arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s))
                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                    revert with 'NH{q', 17
                if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                    revert with 'NH{q', 17
                if arg1 * stor15 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                    revert with 'NH{q', 17
                return ((arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
            if totalSupply <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            if not totalSupply:
                revert with 'NH{q', 18
            if not arg1:
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        return 0
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor13 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                    revert with 'NH{q', 17
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
            if arg1 and stor9 / totalSupply > -1 / arg1:
                revert with 'NH{q', 17
            if not arg1:
                revert with 'NH{q', 18
            if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor13 / 100 / 100:
                if not arg1 * stor15 / 100 / 100:
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    return (arg1 * stor9 / totalSupply)
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 'NH{q', 17
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 'NH{q', 17
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                revert with 'NH{q', 17
            if not arg1 * stor13 / 100 / 100:
                revert with 'NH{q', 18
            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor15 / 100 / 100:
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 'NH{q', 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 'NH{q', 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                revert with 'NH{q', 17
            if not arg1 * stor15 / 100 / 100:
                revert with 'NH{q', 18
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                revert with 'NH{q', 17
            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                revert with 'NH{q', 17
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                revert with 'NH{q', 17
            return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
        if arg1 and stor14 > -1 / arg1:
            revert with 'NH{q', 17
        if not arg1:
            revert with 'NH{q', 18
        if arg1 * stor14 / arg1 != stor14:
            revert with 0, 'SafeMath: multiplication overflow'
        mem[224] = 26
        mem[256] = 'SafeMath: division by zero'
        mem[288] = 26
        mem[320] = 'SafeMath: division by zero'
        if not arg1:
            mem[352] = 26
            mem[384] = 'SafeMath: division by zero'
            mem[416] = 26
            mem[448] = 'SafeMath: division by zero'
            mem[480] = 30
            mem[512] = 'SafeMath: subtraction overflow'
            if arg1 * stor13 / 100 / 100 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < arg1 * stor13 / 100 / 100:
                revert with 'NH{q', 17
            mem[544] = 30
            mem[576] = 'SafeMath: subtraction overflow'
            if arg1 * stor14 / 100 / 100 > arg1 - (arg1 * stor13 / 100 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * stor13 / 100 / 100) < arg1 * stor14 / 100 / 100:
                revert with 'NH{q', 17
            mem[64] = 672
            mem[608] = 30
            mem[640] = 'SafeMath: subtraction overflow'
            if 0 > arg1 - (arg1 * stor13 / 100 / 100) - (arg1 * stor14 / 100 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * stor13 / 100 / 100) - (arg1 * stor14 / 100 / 100) < 0:
                revert with 'NH{q', 17
            idx = 0
            s = totalSupply
            t = stor9
            while idx < stor6.length:
                mem[0] = stor6[idx]
                mem[32] = 1
                if stor1[stor6[idx]] > t:
                    _9574 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9574] = 26
                    mem[_9574 + 32] = 'SafeMath: division by zero'
                    if totalSupply <= 0:
                        _9717 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_9717 + idx + 68] = mem[_9574 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_9717 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9717 + -mem[64] + 100
                    if not totalSupply:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * stor13 / 100 / 100:
                            if not arg1 * stor14 / 100 / 100:
                                return 0
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10515 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10515] = 30
                            mem[_10515 + 32] = 'SafeMath: subtraction overflow'
                            _11021 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11021] = 30
                            mem[_11021 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                _11155 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11155 + idx + 68] = mem[_11021 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11155 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11155 + -mem[64] + 100
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            _11994 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11994] = 30
                            mem[_11994 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                            _12220 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12220 + idx + 68] = mem[_11994 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12220 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12220 + -mem[64] + 100
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            _10514 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10514] = 30
                            mem[_10514 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _10592 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_10592 + idx + 68] = mem[_10514 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10592 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10592 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            _11020 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11020] = 30
                            mem[_11020 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _11154 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11154 + idx + 68] = mem[_11020 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11154 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11154 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _11993 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11993] = 30
                            mem[_11993 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                            _12219 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12219 + idx + 68] = mem[_11993 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12219 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12219 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11245 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11245] = 30
                        mem[_11245 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _11385 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11385 + idx + 68] = mem[_11245 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11385 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11385 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _12386 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12386] = 30
                        mem[_12386 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _12693 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12693 + idx + 68] = mem[_12386 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12693 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12693 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _13990 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13990] = 30
                        mem[_13990 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                        _14399 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14399 + idx + 68] = mem[_13990 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14399 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14399 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor14 / 100 / 100:
                            _10513 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10513] = 30
                            mem[_10513 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10591 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_10591 + idx + 68] = mem[_10513 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10591 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10591 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _11019 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11019] = 30
                            mem[_11019 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11153 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11153 + idx + 68] = mem[_11019 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11153 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11153 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _11992 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11992] = 30
                            mem[_11992 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor9 / totalSupply)
                            _12217 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12217 + idx + 68] = mem[_11992 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12217 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12217 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11244 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11244] = 30
                        mem[_11244 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11382 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11382 + idx + 68] = mem[_11244 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11382 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11382 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _12385 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12385] = 30
                        mem[_12385 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _12690 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12690 + idx + 68] = mem[_12385 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12690 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12690 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _13988 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13988] = 30
                        mem[_13988 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                        _14397 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14397 + idx + 68] = mem[_13988 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14397 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14397 + -mem[64] + 100
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        _11243 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11243] = 30
                        mem[_11243 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _11381 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11381 + idx + 68] = mem[_11243 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11381 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11381 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _12384 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12384] = 30
                        mem[_12384 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _12689 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12689 + idx + 68] = mem[_12384 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12689 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12689 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        _13987 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13987] = 30
                        mem[_13987 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
                        _14396 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14396 + idx + 68] = mem[_13987 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14396 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14396 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _12847 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12847] = 30
                    mem[_12847 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _13102 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_13102 + idx + 68] = mem[_12847 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_13102 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13102 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    _14590 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14590] = 30
                    mem[_14590 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _14932 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14932 + idx + 68] = mem[_14590 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14932 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14932 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    _16151 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16151] = 30
                    mem[_16151 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                    _16504 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_16504 + idx + 68] = mem[_16151 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_16504 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16504 + -mem[64] + 100
                if idx >= stor6.length:
                    revert with 'NH{q', 50
                mem[0] = stor6[idx]
                mem[32] = 2
                if stor2[stor6[idx]] <= s:
                    if idx >= stor6.length:
                        revert with 'NH{q', 50
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    _9664 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9664] = 30
                    mem[_9664 + 32] = 'SafeMath: subtraction overflow'
                    if stor1[stor6[idx]] > t:
                        _9744 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_9744 + idx + 68] = mem[_9664 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_9744 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9744 + -mem[64] + 100
                    if t < stor1[stor6[idx]]:
                        revert with 'NH{q', 17
                    if idx >= stor6.length:
                        revert with 'NH{q', 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    _9982 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9982] = 30
                    mem[_9982 + 32] = 'SafeMath: subtraction overflow'
                    if stor2[stor6[idx]] <= s:
                        if s < stor2[stor6[idx]]:
                            revert with 'NH{q', 17
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        s = s - stor2[stor6[idx]]
                        t = t - stor1[stor6[idx]]
                        continue 
                    _10024 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_10024 + idx + 68] = mem[_9982 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_10024 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _10024 + -mem[64] + 100
                _9718 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9718] = 26
                mem[_9718 + 32] = 'SafeMath: division by zero'
                if totalSupply <= 0:
                    _9758 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_9758 + idx + 68] = mem[_9718 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_9758 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _9758 + -mem[64] + 100
                if not totalSupply:
                    revert with 'NH{q', 18
                if not arg1:
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor14 / 100 / 100:
                            return 0
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10595 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10595] = 30
                        mem[_10595 + 32] = 'SafeMath: subtraction overflow'
                        _11158 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11158] = 30
                        mem[_11158 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                            _11332 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11332 + idx + 68] = mem[_11158 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11332 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11332 + -mem[64] + 100
                        if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _12223 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12223] = 30
                        mem[_12223 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                        _12575 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12575 + idx + 68] = mem[_12223 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12575 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12575 + -mem[64] + 100
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        _10594 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10594] = 30
                        mem[_10594 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _10680 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_10680 + idx + 68] = mem[_10594 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_10680 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10680 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _11157 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11157] = 30
                        mem[_11157 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _11331 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11331 + idx + 68] = mem[_11157 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11331 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11331 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _12222 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12222] = 30
                        mem[_12222 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                        _12574 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12574 + idx + 68] = mem[_12222 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12574 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12574 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11391 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11391] = 30
                    mem[_11391 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                        _11561 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11561 + idx + 68] = mem[_11391 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11561 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11561 + -mem[64] + 100
                    if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    _12700 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12700] = 30
                    mem[_12700 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        _12990 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12990 + idx + 68] = mem[_12700 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12990 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12990 + -mem[64] + 100
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    _14405 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14405] = 30
                    mem[_14405 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                    _14789 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_14789 + idx + 68] = mem[_14405 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_14789 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14789 + -mem[64] + 100
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor14 / 100 / 100:
                        _10593 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10593] = 30
                        mem[_10593 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10679 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_10679 + idx + 68] = mem[_10593 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_10679 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10679 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _11156 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11156] = 30
                        mem[_11156 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11330 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11330 + idx + 68] = mem[_11156 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11330 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11330 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _12221 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12221] = 30
                        mem[_12221 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor9 / totalSupply)
                        _12572 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12572 + idx + 68] = mem[_12221 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12572 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12572 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11390 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11390] = 30
                    mem[_11390 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _11558 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11558 + idx + 68] = mem[_11390 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11558 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11558 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _12699 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12699] = 30
                    mem[_12699 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _12987 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12987 + idx + 68] = mem[_12699 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12987 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12987 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    _14403 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14403] = 30
                    mem[_14403 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                    _14787 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_14787 + idx + 68] = mem[_14403 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_14787 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14787 + -mem[64] + 100
                if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor13 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor14 / 100 / 100:
                    _11389 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11389] = 30
                    mem[_11389 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _11557 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11557 + idx + 68] = mem[_11389 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11557 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11557 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    _12698 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12698] = 30
                    mem[_12698 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _12986 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12986 + idx + 68] = mem[_12698 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12986 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12986 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 'NH{q', 17
                    _14402 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14402] = 30
                    mem[_14402 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
                    _14786 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_14786 + idx + 68] = mem[_14402 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_14786 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14786 + -mem[64] + 100
                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _13109 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13109] = 30
                mem[_13109 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    _13356 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_13356 + idx + 68] = mem[_13109 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_13356 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _13356 + -mem[64] + 100
                if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                _14939 = mem[64]
                mem[64] = mem[64] + 64
                mem[_14939] = 30
                mem[_14939 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    _15263 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_15263 + idx + 68] = mem[_14939 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_15263 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15263 + -mem[64] + 100
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                _16508 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16508] = 30
                mem[_16508 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 'NH{q', 17
                    return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                _16704 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_16704 + idx + 68] = mem[_16508 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_16704 + 98] = 0
                revert with memory
                  from mem[64]
                   len _16704 + -mem[64] + 100
            if totalSupply <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            if not totalSupply:
                revert with 'NH{q', 18
            if t >= stor9 / totalSupply:
                if s <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not s:
                    revert with 'NH{q', 18
                if not arg1:
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor14 / 100 / 100:
                            return 0
                        if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor14 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor14 / 100 / 100 * t / s:
                            revert with 'NH{q', 17
                        if 0 > -1 * arg1 * stor14 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor14 / 100 / 100 * t / s < 0:
                            revert with 'NH{q', 17
                        return (-1 * arg1 * stor14 / 100 / 100 * t / s)
                    if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        if arg1 * stor13 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor13 / 100 / 100 * t / s:
                            revert with 'NH{q', 17
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                            revert with 'NH{q', 17
                        return (-1 * arg1 * stor13 / 100 / 100 * t / s)
                    if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor13 / 100 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor13 / 100 / 100 * t / s:
                        revert with 'NH{q', 17
                    if arg1 * stor14 / 100 / 100 * t / s > -1 * arg1 * stor13 / 100 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                        revert with 'NH{q', 17
                    if 0 > (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                        revert with 'NH{q', 17
                    return ((-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s))
                if arg1 and t / s > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor14 / 100 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        return (arg1 * t / s)
                    if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 'NH{q', 17
                    if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                        revert with 'NH{q', 17
                    if 0 > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                        revert with 'NH{q', 17
                    return ((arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s))
                if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor13 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor14 / 100 / 100:
                    if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                        revert with 'NH{q', 17
                    if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                        revert with 'NH{q', 17
                    if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                        revert with 'NH{q', 17
                    return ((arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s))
                if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                    revert with 'NH{q', 17
                if arg1 * stor14 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < arg1 * stor14 / 100 / 100 * t / s:
                    revert with 'NH{q', 17
                if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                    revert with 'NH{q', 17
                return ((arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s))
            if totalSupply <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            if not totalSupply:
                revert with 'NH{q', 18
            if not arg1:
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor14 / 100 / 100:
                        return 0
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    if 0 > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor13 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor14 / 100 / 100:
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                if 0 > (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 'NH{q', 17
                return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
            if arg1 and stor9 / totalSupply > -1 / arg1:
                revert with 'NH{q', 17
            if not arg1:
                revert with 'NH{q', 18
            if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor13 / 100 / 100:
                if not arg1 * stor14 / 100 / 100:
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    return (arg1 * stor9 / totalSupply)
                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 'NH{q', 17
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 'NH{q', 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                revert with 'NH{q', 17
            if not arg1 * stor13 / 100 / 100:
                revert with 'NH{q', 18
            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor14 / 100 / 100:
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 'NH{q', 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 'NH{q', 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                revert with 'NH{q', 17
            if not arg1 * stor14 / 100 / 100:
                revert with 'NH{q', 18
            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                revert with 'NH{q', 17
            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                revert with 'NH{q', 17
            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                revert with 'NH{q', 17
            return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
        if arg1 and stor15 > -1 / arg1:
            revert with 'NH{q', 17
        if not arg1:
            revert with 'NH{q', 18
        if arg1 * stor15 / arg1 != stor15:
            revert with 0, 'SafeMath: multiplication overflow'
        mem[352] = 26
        mem[384] = 'SafeMath: division by zero'
        mem[416] = 26
        mem[448] = 'SafeMath: division by zero'
        mem[480] = 30
        mem[512] = 'SafeMath: subtraction overflow'
        if arg1 * stor13 / 100 / 100 > arg1:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 < arg1 * stor13 / 100 / 100:
            revert with 'NH{q', 17
        mem[544] = 30
        mem[576] = 'SafeMath: subtraction overflow'
        if arg1 * stor14 / 100 / 100 > arg1 - (arg1 * stor13 / 100 / 100):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 - (arg1 * stor13 / 100 / 100) < arg1 * stor14 / 100 / 100:
            revert with 'NH{q', 17
        mem[64] = 672
        mem[608] = 30
        mem[640] = 'SafeMath: subtraction overflow'
        if arg1 * stor15 / 100 / 100 > arg1 - (arg1 * stor13 / 100 / 100) - (arg1 * stor14 / 100 / 100):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 - (arg1 * stor13 / 100 / 100) - (arg1 * stor14 / 100 / 100) < arg1 * stor15 / 100 / 100:
            revert with 'NH{q', 17
        idx = 0
        s = totalSupply
        t = stor9
        while idx < stor6.length:
            mem[0] = stor6[idx]
            mem[32] = 1
            if stor1[stor6[idx]] > t:
                _9570 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9570] = 26
                mem[_9570 + 32] = 'SafeMath: division by zero'
                if totalSupply <= 0:
                    _9715 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_9715 + idx + 68] = mem[_9570 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_9715 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _9715 + -mem[64] + 100
                if not totalSupply:
                    revert with 'NH{q', 18
                if not arg1:
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor14 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                return 0
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10512 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10512] = 30
                            mem[_10512 + 32] = 'SafeMath: subtraction overflow'
                            _11011 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11011] = 30
                            mem[_11011 + 32] = 'SafeMath: subtraction overflow'
                            _11984 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11984] = 30
                            mem[_11984 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                                if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                            _12205 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12205 + idx + 68] = mem[_11984 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12205 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12205 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _10511 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10511] = 30
                            mem[_10511 + 32] = 'SafeMath: subtraction overflow'
                            _11010 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11010] = 30
                            mem[_11010 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                _11145 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11145 + idx + 68] = mem[_11010 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11145 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11145 + -mem[64] + 100
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            _11983 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11983] = 30
                            mem[_11983 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                            _12204 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12204 + idx + 68] = mem[_11983 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12204 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12204 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11238 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11238] = 30
                        mem[_11238 + 32] = 'SafeMath: subtraction overflow'
                        _12367 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12367] = 30
                        mem[_12367 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                            _12676 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12676 + idx + 68] = mem[_12367 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12676 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12676 + -mem[64] + 100
                        if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _13966 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13966] = 30
                        mem[_13966 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            return ((-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                        _14380 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14380 + idx + 68] = mem[_13966 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14380 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14380 + -mem[64] + 100
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            _10510 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10510] = 30
                            mem[_10510 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _10585 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_10585 + idx + 68] = mem[_10510 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10585 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10585 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            _11008 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11008] = 30
                            mem[_11008 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _11144 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11144 + idx + 68] = mem[_11008 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11144 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11144 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _11982 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11982] = 30
                            mem[_11982 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                            _12203 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12203 + idx + 68] = mem[_11982 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12203 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12203 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11237 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11237] = 30
                        mem[_11237 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _11371 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11371 + idx + 68] = mem[_11237 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11371 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11371 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _12366 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12366] = 30
                        mem[_12366 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _12673 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12673 + idx + 68] = mem[_12366 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12673 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12673 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _13964 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13964] = 30
                        mem[_13964 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                        _14378 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14378 + idx + 68] = mem[_13964 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14378 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14378 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _11236 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11236] = 30
                        mem[_11236 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _11370 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11370 + idx + 68] = mem[_11236 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11370 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11370 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _12365 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12365] = 30
                        mem[_12365 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _12672 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12672 + idx + 68] = mem[_12365 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12672 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12672 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _13963 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13963] = 30
                        mem[_13963 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                        _14377 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14377 + idx + 68] = mem[_13963 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14377 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14377 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _12837 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12837] = 30
                    mem[_12837 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                        _13088 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_13088 + idx + 68] = mem[_12837 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_13088 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13088 + -mem[64] + 100
                    if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    _14572 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14572] = 30
                    mem[_14572 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        _14916 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14916 + idx + 68] = mem[_14572 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14916 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14916 + -mem[64] + 100
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    _16133 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16133] = 30
                    mem[_16133 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _16490 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_16490 + idx + 68] = mem[_16133 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_16490 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16490 + -mem[64] + 100
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            _10509 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10509] = 30
                            mem[_10509 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10584 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_10584 + idx + 68] = mem[_10509 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10584 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10584 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _11006 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11006] = 30
                            mem[_11006 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11143 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11143 + idx + 68] = mem[_11006 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11143 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11143 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _11981 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11981] = 30
                            mem[_11981 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor9 / totalSupply)
                            _12200 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12200 + idx + 68] = mem[_11981 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12200 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12200 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11235 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11235] = 30
                        mem[_11235 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11367 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11367 + idx + 68] = mem[_11235 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11367 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11367 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _12363 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12363] = 30
                        mem[_12363 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _12669 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12669 + idx + 68] = mem[_12363 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12669 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12669 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _13961 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13961] = 30
                        mem[_13961 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                        _14374 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14374 + idx + 68] = mem[_13961 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14374 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14374 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _11234 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11234] = 30
                        mem[_11234 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11366 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11366 + idx + 68] = mem[_11234 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11366 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11366 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _12362 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12362] = 30
                        mem[_12362 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _12668 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12668 + idx + 68] = mem[_12362 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12668 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12668 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _13960 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13960] = 30
                        mem[_13960 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                        _14373 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14373 + idx + 68] = mem[_13960 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14373 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14373 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _12835 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12835] = 30
                    mem[_12835 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _13083 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_13083 + idx + 68] = mem[_12835 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_13083 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13083 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _14570 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14570] = 30
                    mem[_14570 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _14911 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14911 + idx + 68] = mem[_14570 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14911 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14911 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    _16130 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16130] = 30
                    mem[_16130 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _16487 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_16487 + idx + 68] = mem[_16130 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_16487 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16487 + -mem[64] + 100
                if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor13 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor14 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        _11233 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11233] = 30
                        mem[_11233 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _11365 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11365 + idx + 68] = mem[_11233 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11365 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11365 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _12360 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12360] = 30
                        mem[_12360 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _12667 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12667 + idx + 68] = mem[_12360 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12667 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12667 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        _13959 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13959] = 30
                        mem[_13959 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
                        _14371 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14371 + idx + 68] = mem[_13959 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14371 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14371 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _12834 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12834] = 30
                    mem[_12834 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _13080 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_13080 + idx + 68] = mem[_12834 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_13080 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13080 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    _14569 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14569] = 30
                    mem[_14569 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _14908 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14908 + idx + 68] = mem[_14569 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14908 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14908 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 'NH{q', 17
                    _16128 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16128] = 30
                    mem[_16128 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _16485 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_16485 + idx + 68] = mem[_16128 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_16485 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16485 + -mem[64] + 100
                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    _12833 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12833] = 30
                    mem[_12833 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _13079 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_13079 + idx + 68] = mem[_12833 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_13079 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13079 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    _14568 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14568] = 30
                    mem[_14568 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _14907 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14907 + idx + 68] = mem[_14568 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14907 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14907 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    _16127 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16127] = 30
                    mem[_16127 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                    _16484 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_16484 + idx + 68] = mem[_16127 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_16484 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16484 + -mem[64] + 100
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _15069 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15069] = 30
                mem[_15069 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    _15333 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_15333 + idx + 68] = mem[_15069 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_15333 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15333 + -mem[64] + 100
                if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                _16603 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16603] = 30
                mem[_16603 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    _16763 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_16763 + idx + 68] = mem[_16603 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_16763 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16763 + -mem[64] + 100
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                _17409 = mem[64]
                mem[64] = mem[64] + 64
                mem[_17409] = 30
                mem[_17409 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                _17569 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_17569 + idx + 68] = mem[_17409 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_17569 + 98] = 0
                revert with memory
                  from mem[64]
                   len _17569 + -mem[64] + 100
            if idx >= stor6.length:
                revert with 'NH{q', 50
            mem[0] = stor6[idx]
            mem[32] = 2
            if stor2[stor6[idx]] <= s:
                if idx >= stor6.length:
                    revert with 'NH{q', 50
                mem[0] = stor6[idx]
                mem[32] = 1
                _9663 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9663] = 30
                mem[_9663 + 32] = 'SafeMath: subtraction overflow'
                if stor1[stor6[idx]] > t:
                    _9743 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_9743 + idx + 68] = mem[_9663 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_9743 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _9743 + -mem[64] + 100
                if t < stor1[stor6[idx]]:
                    revert with 'NH{q', 17
                if idx >= stor6.length:
                    revert with 'NH{q', 50
                mem[0] = stor6[idx]
                mem[32] = 2
                _9981 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9981] = 30
                mem[_9981 + 32] = 'SafeMath: subtraction overflow'
                if stor2[stor6[idx]] <= s:
                    if s < stor2[stor6[idx]]:
                        revert with 'NH{q', 17
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    s = s - stor2[stor6[idx]]
                    t = t - stor1[stor6[idx]]
                    continue 
                _10023 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_10023 + idx + 68] = mem[_9981 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_10023 + 98] = 0
                revert with memory
                  from mem[64]
                   len _10023 + -mem[64] + 100
            _9716 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9716] = 26
            mem[_9716 + 32] = 'SafeMath: division by zero'
            if totalSupply <= 0:
                _9757 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_9757 + idx + 68] = mem[_9716 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_9757 + 94] = 0
                revert with memory
                  from mem[64]
                   len _9757 + -mem[64] + 100
            if not totalSupply:
                revert with 'NH{q', 18
            if not arg1:
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            return 0
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10589 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10589] = 30
                        mem[_10589 + 32] = 'SafeMath: subtraction overflow'
                        _11152 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11152] = 30
                        mem[_11152 + 32] = 'SafeMath: subtraction overflow'
                        _12209 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12209] = 30
                        mem[_12209 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                            if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                        _12565 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12565 + idx + 68] = mem[_12209 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12565 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12565 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _10588 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10588] = 30
                        mem[_10588 + 32] = 'SafeMath: subtraction overflow'
                        _11151 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11151] = 30
                        mem[_11151 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                            _11327 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11327 + idx + 68] = mem[_11151 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11327 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11327 + -mem[64] + 100
                        if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _12208 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12208] = 30
                        mem[_12208 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                        _12564 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12564 + idx + 68] = mem[_12208 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12564 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12564 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11380 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11380] = 30
                    mem[_11380 + 32] = 'SafeMath: subtraction overflow'
                    _12688 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12688] = 30
                    mem[_12688 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                        _12981 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12981 + idx + 68] = mem[_12688 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12981 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12981 + -mem[64] + 100
                    if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    _14390 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14390] = 30
                    mem[_14390 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        return ((-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _14776 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_14776 + idx + 68] = mem[_14390 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_14776 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14776 + -mem[64] + 100
                if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor13 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor14 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        _10587 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10587] = 30
                        mem[_10587 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _10677 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_10677 + idx + 68] = mem[_10587 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_10677 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10677 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _11149 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11149] = 30
                        mem[_11149 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _11326 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11326 + idx + 68] = mem[_11149 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11326 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11326 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _12207 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12207] = 30
                        mem[_12207 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                        _12563 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12563 + idx + 68] = mem[_12207 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12563 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12563 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11379 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11379] = 30
                    mem[_11379 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                        _11551 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11551 + idx + 68] = mem[_11379 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11551 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11551 + -mem[64] + 100
                    if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    _12687 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12687] = 30
                    mem[_12687 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        _12978 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12978 + idx + 68] = mem[_12687 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12978 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12978 + -mem[64] + 100
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _14388 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14388] = 30
                    mem[_14388 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _14774 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_14774 + idx + 68] = mem[_14388 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_14774 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14774 + -mem[64] + 100
                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    _11378 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11378] = 30
                    mem[_11378 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                        _11550 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11550 + idx + 68] = mem[_11378 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11550 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11550 + -mem[64] + 100
                    if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    _12686 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12686] = 30
                    mem[_12686 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        _12977 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12977 + idx + 68] = mem[_12686 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12977 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12977 + -mem[64] + 100
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    _14387 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14387] = 30
                    mem[_14387 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                    _14773 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_14773 + idx + 68] = mem[_14387 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_14773 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14773 + -mem[64] + 100
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _13098 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13098] = 30
                mem[_13098 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                    _13342 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_13342 + idx + 68] = mem[_13098 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_13342 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _13342 + -mem[64] + 100
                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                _14928 = mem[64]
                mem[64] = mem[64] + 64
                mem[_14928] = 30
                mem[_14928 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    _15256 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_15256 + idx + 68] = mem[_14928 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_15256 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15256 + -mem[64] + 100
                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                _16500 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16500] = 30
                mem[_16500 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                _16698 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_16698 + idx + 68] = mem[_16500 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_16698 + 98] = 0
                revert with memory
                  from mem[64]
                   len _16698 + -mem[64] + 100
            if arg1 and stor9 / totalSupply > -1 / arg1:
                revert with 'NH{q', 17
            if not arg1:
                revert with 'NH{q', 18
            if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor13 / 100 / 100:
                if not arg1 * stor14 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        _10586 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10586] = 30
                        mem[_10586 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10676 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_10676 + idx + 68] = mem[_10586 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_10676 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10676 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _11147 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11147] = 30
                        mem[_11147 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11325 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11325 + idx + 68] = mem[_11147 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11325 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11325 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _12206 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12206] = 30
                        mem[_12206 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor9 / totalSupply)
                        _12560 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12560 + idx + 68] = mem[_12206 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12560 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12560 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11377 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11377] = 30
                    mem[_11377 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _11547 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11547 + idx + 68] = mem[_11377 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11547 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11547 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _12684 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12684] = 30
                    mem[_12684 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _12974 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12974 + idx + 68] = mem[_12684 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12974 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12974 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _14385 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14385] = 30
                    mem[_14385 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                        if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _14770 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_14770 + idx + 68] = mem[_14385 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_14770 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14770 + -mem[64] + 100
                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    _11376 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11376] = 30
                    mem[_11376 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _11546 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11546 + idx + 68] = mem[_11376 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11546 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11546 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _12683 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12683] = 30
                    mem[_12683 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _12973 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12973 + idx + 68] = mem[_12683 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12973 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12973 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    _14384 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14384] = 30
                    mem[_14384 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                    _14769 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_14769 + idx + 68] = mem[_14384 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_14769 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14769 + -mem[64] + 100
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _13096 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13096] = 30
                mem[_13096 + 32] = 'SafeMath: subtraction overflow'
                if 0 > arg1 * stor9 / totalSupply:
                    _13337 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_13337 + idx + 68] = mem[_13096 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_13337 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _13337 + -mem[64] + 100
                if arg1 * stor9 / totalSupply < 0:
                    revert with 'NH{q', 17
                _14926 = mem[64]
                mem[64] = mem[64] + 64
                mem[_14926] = 30
                mem[_14926 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    _15251 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_15251 + idx + 68] = mem[_14926 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_15251 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15251 + -mem[64] + 100
                if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                _16497 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16497] = 30
                mem[_16497 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                _16695 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_16695 + idx + 68] = mem[_16497 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_16695 + 98] = 0
                revert with memory
                  from mem[64]
                   len _16695 + -mem[64] + 100
            if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                revert with 'NH{q', 17
            if not arg1 * stor13 / 100 / 100:
                revert with 'NH{q', 18
            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor14 / 100 / 100:
                if not arg1 * stor15 / 100 / 100:
                    _11375 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11375] = 30
                    mem[_11375 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _11545 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11545 + idx + 68] = mem[_11375 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11545 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11545 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    _12681 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12681] = 30
                    mem[_12681 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _12972 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12972 + idx + 68] = mem[_12681 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12972 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12972 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 'NH{q', 17
                    _14383 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14383] = 30
                    mem[_14383 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
                    _14767 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_14767 + idx + 68] = mem[_14383 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_14767 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14767 + -mem[64] + 100
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _13095 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13095] = 30
                mem[_13095 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    _13334 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_13334 + idx + 68] = mem[_13095 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_13334 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _13334 + -mem[64] + 100
                if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                _14925 = mem[64]
                mem[64] = mem[64] + 64
                mem[_14925] = 30
                mem[_14925 + 32] = 'SafeMath: subtraction overflow'
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    _15248 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_15248 + idx + 68] = mem[_14925 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_15248 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15248 + -mem[64] + 100
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 'NH{q', 17
                _16495 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16495] = 30
                mem[_16495 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                _16693 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_16693 + idx + 68] = mem[_16495 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_16693 + 98] = 0
                revert with memory
                  from mem[64]
                   len _16693 + -mem[64] + 100
            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                revert with 'NH{q', 17
            if not arg1 * stor14 / 100 / 100:
                revert with 'NH{q', 18
            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor15 / 100 / 100:
                _13094 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13094] = 30
                mem[_13094 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    _13333 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_13333 + idx + 68] = mem[_13094 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_13333 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _13333 + -mem[64] + 100
                if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                _14924 = mem[64]
                mem[64] = mem[64] + 64
                mem[_14924] = 30
                mem[_14924 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    _15247 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_15247 + idx + 68] = mem[_14924 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_15247 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15247 + -mem[64] + 100
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                _16494 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16494] = 30
                mem[_16494 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 'NH{q', 17
                    return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                _16692 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_16692 + idx + 68] = mem[_16494 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_16692 + 98] = 0
                revert with memory
                  from mem[64]
                   len _16692 + -mem[64] + 100
            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                revert with 'NH{q', 17
            if not arg1 * stor15 / 100 / 100:
                revert with 'NH{q', 18
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            _15342 = mem[64]
            mem[64] = mem[64] + 64
            mem[_15342] = 30
            mem[_15342 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                _15545 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_15545 + idx + 68] = mem[_15342 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_15545 + 98] = 0
                revert with memory
                  from mem[64]
                   len _15545 + -mem[64] + 100
            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                revert with 'NH{q', 17
            _16772 = mem[64]
            mem[64] = mem[64] + 64
            mem[_16772] = 30
            mem[_16772 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                _16961 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_16961 + idx + 68] = mem[_16772 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_16961 + 98] = 0
                revert with memory
                  from mem[64]
                   len _16961 + -mem[64] + 100
            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                revert with 'NH{q', 17
            _17574 = mem[64]
            mem[64] = mem[64] + 64
            mem[_17574] = 30
            mem[_17574 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
            _17625 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_17625 + idx + 68] = mem[_17574 + idx + 32]
                idx = idx + 32
                continue 
            mem[_17625 + 98] = 0
            revert with memory
              from mem[64]
               len _17625 + -mem[64] + 100
        if totalSupply <= 0:
            revert with 0, 'SafeMath: division by zero', 0
        if not totalSupply:
            revert with 'NH{q', 18
        if t >= stor9 / totalSupply:
            if s <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            if not s:
                revert with 'NH{q', 18
            if not arg1:
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            return 0
                        if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor15 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor15 / 100 / 100 * t / s:
                            revert with 'NH{q', 17
                        return (-1 * arg1 * stor15 / 100 / 100 * t / s)
                    if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        if arg1 * stor14 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor14 / 100 / 100 * t / s:
                            revert with 'NH{q', 17
                        if 0 > -1 * arg1 * stor14 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor14 / 100 / 100 * t / s < 0:
                            revert with 'NH{q', 17
                        return (-1 * arg1 * stor14 / 100 / 100 * t / s)
                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor14 / 100 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor14 / 100 / 100 * t / s:
                        revert with 'NH{q', 17
                    if arg1 * stor15 / 100 / 100 * t / s > -1 * arg1 * stor14 / 100 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor14 / 100 / 100 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                        revert with 'NH{q', 17
                    return ((-1 * arg1 * stor14 / 100 / 100 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
                if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor13 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor14 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        if arg1 * stor13 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor13 / 100 / 100 * t / s:
                            revert with 'NH{q', 17
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                            revert with 'NH{q', 17
                        return (-1 * arg1 * stor13 / 100 / 100 * t / s)
                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor13 / 100 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor13 / 100 / 100 * t / s:
                        revert with 'NH{q', 17
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                        revert with 'NH{q', 17
                    if arg1 * stor15 / 100 / 100 * t / s > -1 * arg1 * stor13 / 100 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                        revert with 'NH{q', 17
                    return ((-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
                if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    if arg1 * stor13 / 100 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor13 / 100 / 100 * t / s:
                        revert with 'NH{q', 17
                    if arg1 * stor14 / 100 / 100 * t / s > -1 * arg1 * stor13 / 100 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                        revert with 'NH{q', 17
                    if 0 > (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                        revert with 'NH{q', 17
                    return ((-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s))
                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor13 / 100 / 100 * t / s > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * stor13 / 100 / 100 * t / s:
                    revert with 'NH{q', 17
                if arg1 * stor14 / 100 / 100 * t / s > -1 * arg1 * stor13 / 100 / 100 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * stor13 / 100 / 100 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                    revert with 'NH{q', 17
                if arg1 * stor15 / 100 / 100 * t / s > (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                    revert with 'NH{q', 17
                return ((-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
            if arg1 and t / s > -1 / arg1:
                revert with 'NH{q', 17
            if not arg1:
                revert with 'NH{q', 18
            if arg1 * t / s / arg1 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor13 / 100 / 100:
                if not arg1 * stor14 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        return (arg1 * t / s)
                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 'NH{q', 17
                    if arg1 * stor15 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                        revert with 'NH{q', 17
                    return ((arg1 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
                if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 'NH{q', 17
                    if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                        revert with 'NH{q', 17
                    if 0 > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                        revert with 'NH{q', 17
                    return ((arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s))
                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0:
                    revert with 'NH{q', 17
                if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                    revert with 'NH{q', 17
                if arg1 * stor15 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                    revert with 'NH{q', 17
                return ((arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
            if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                revert with 'NH{q', 17
            if not arg1 * stor13 / 100 / 100:
                revert with 'NH{q', 18
            if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor14 / 100 / 100:
                if not arg1 * stor15 / 100 / 100:
                    if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                        revert with 'NH{q', 17
                    if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                        revert with 'NH{q', 17
                    if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                        revert with 'NH{q', 17
                    return ((arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s))
                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                    revert with 'NH{q', 17
                if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                    revert with 'NH{q', 17
                if arg1 * stor15 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                    revert with 'NH{q', 17
                return ((arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
            if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                revert with 'NH{q', 17
            if not arg1 * stor14 / 100 / 100:
                revert with 'NH{q', 18
            if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor15 / 100 / 100:
                if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                    revert with 'NH{q', 17
                if arg1 * stor14 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < arg1 * stor14 / 100 / 100 * t / s:
                    revert with 'NH{q', 17
                if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                    revert with 'NH{q', 17
                return ((arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s))
            if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                revert with 'NH{q', 17
            if not arg1 * stor15 / 100 / 100:
                revert with 'NH{q', 18
            if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                revert with 'NH{q', 17
            if arg1 * stor14 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < arg1 * stor14 / 100 / 100 * t / s:
                revert with 'NH{q', 17
            if arg1 * stor15 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                revert with 'NH{q', 17
            return ((arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
        if totalSupply <= 0:
            revert with 0, 'SafeMath: division by zero', 0
        if not totalSupply:
            revert with 'NH{q', 18
        if not arg1:
            if not arg1 * stor13 / 100 / 100:
                if not arg1 * stor14 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        return 0
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    if 0 > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                return ((-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                revert with 'NH{q', 17
            if not arg1 * stor13 / 100 / 100:
                revert with 'NH{q', 18
            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor14 / 100 / 100:
                if not arg1 * stor15 / 100 / 100:
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                    revert with 'NH{q', 17
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                revert with 'NH{q', 17
            if not arg1 * stor14 / 100 / 100:
                revert with 'NH{q', 18
            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor15 / 100 / 100:
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                if 0 > (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 'NH{q', 17
                return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                revert with 'NH{q', 17
            if not arg1 * stor15 / 100 / 100:
                revert with 'NH{q', 18
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                revert with 'NH{q', 17
            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                revert with 'NH{q', 17
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                revert with 'NH{q', 17
            return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
        if arg1 and stor9 / totalSupply > -1 / arg1:
            revert with 'NH{q', 17
        if not arg1:
            revert with 'NH{q', 18
        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if not arg1 * stor13 / 100 / 100:
            if not arg1 * stor14 / 100 / 100:
                if not arg1 * stor15 / 100 / 100:
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    return (arg1 * stor9 / totalSupply)
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 'NH{q', 17
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 'NH{q', 17
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                revert with 'NH{q', 17
            if not arg1 * stor14 / 100 / 100:
                revert with 'NH{q', 18
            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor15 / 100 / 100:
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 'NH{q', 17
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 'NH{q', 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                revert with 'NH{q', 17
            if not arg1 * stor15 / 100 / 100:
                revert with 'NH{q', 18
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if 0 > arg1 * stor9 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor9 / totalSupply < 0:
                revert with 'NH{q', 17
            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                revert with 'NH{q', 17
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                revert with 'NH{q', 17
            return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
            revert with 'NH{q', 17
        if not arg1 * stor13 / 100 / 100:
            revert with 'NH{q', 18
        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if not arg1 * stor14 / 100 / 100:
            if not arg1 * stor15 / 100 / 100:
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 'NH{q', 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 'NH{q', 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 'NH{q', 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                revert with 'NH{q', 17
            if not arg1 * stor15 / 100 / 100:
                revert with 'NH{q', 18
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                revert with 'NH{q', 17
            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                revert with 'NH{q', 17
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                revert with 'NH{q', 17
            return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
            revert with 'NH{q', 17
        if not arg1 * stor14 / 100 / 100:
            revert with 'NH{q', 18
        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if not arg1 * stor15 / 100 / 100:
            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                revert with 'NH{q', 17
            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                revert with 'NH{q', 17
            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                revert with 'NH{q', 17
            return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
            revert with 'NH{q', 17
        if not arg1 * stor15 / 100 / 100:
            revert with 'NH{q', 18
        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
            revert with 'NH{q', 17
        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
            revert with 'NH{q', 17
        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
            revert with 'NH{q', 17
        return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
    if not arg1:
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        mem[160] = 26
        mem[192] = 'SafeMath: division by zero'
        if not arg1:
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 'NH{q', 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 'NH{q', 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 'NH{q', 17
                idx = 0
                s = totalSupply
                t = stor9
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _1315 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1315] = 26
                        mem[_1315 + 32] = 'SafeMath: division by zero'
                        if totalSupply <= 0:
                            _1445 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1445 + idx + 68] = mem[_1315 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1445 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1445 + -mem[64] + 100
                        if not totalSupply:
                            revert with 'NH{q', 18
                        if not arg1:
                            return 0
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 'NH{q', 17
                        if not arg1:
                            revert with 'NH{q', 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3496 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3496] = 30
                        mem[_3496 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _3657 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_3657 + idx + 68] = mem[_3496 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3657 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3657 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _4838 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4838] = 30
                        mem[_4838 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _5029 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_5029 + idx + 68] = mem[_4838 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5029 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5029 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _6315 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6315] = 30
                        mem[_6315 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor9 / totalSupply)
                        _6492 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_6492 + idx + 68] = mem[_6315 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_6492 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _6492 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 'NH{q', 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 'NH{q', 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _1439 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1439] = 30
                        mem[_1439 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _1478 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_1478 + idx + 68] = mem[_1439 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1478 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _1478 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 'NH{q', 17
                        if idx >= stor6.length:
                            revert with 'NH{q', 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _1726 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1726] = 30
                        mem[_1726 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 'NH{q', 17
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _1752 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_1752 + idx + 68] = mem[_1726 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1752 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _1752 + -mem[64] + 100
                    _1446 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1446] = 26
                    mem[_1446 + 32] = 'SafeMath: division by zero'
                    if totalSupply <= 0:
                        _1482 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1482 + idx + 68] = mem[_1446 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1482 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1482 + -mem[64] + 100
                    if not totalSupply:
                        revert with 'NH{q', 18
                    if not arg1:
                        return 0
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _3658 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3658] = 30
                    mem[_3658 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _3888 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_3888 + idx + 68] = mem[_3658 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3888 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _3888 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _5030 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5030] = 30
                    mem[_5030 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _5208 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_5208 + idx + 68] = mem[_5030 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5208 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5208 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _6493 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6493] = 30
                    mem[_6493 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor9 / totalSupply:
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        return (arg1 * stor9 / totalSupply)
                    _6710 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_6710 + idx + 68] = mem[_6493 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_6710 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _6710 + -mem[64] + 100
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if t >= stor9 / totalSupply:
                    if s <= 0:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not s:
                        revert with 'NH{q', 18
                    if not arg1:
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 'NH{q', 17
                    return (arg1 * t / s)
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if not arg1:
                    return 0
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 'NH{q', 17
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 'NH{q', 17
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 'NH{q', 17
            else:
                if arg1 and stor15 > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor15 / arg1 != stor15:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 'NH{q', 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 'NH{q', 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if arg1 * stor15 / 100 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 17
                idx = 0
                s = totalSupply
                t = stor9
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _9641 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9641] = 26
                        mem[_9641 + 32] = 'SafeMath: division by zero'
                        if totalSupply <= 0:
                            _9741 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_9741 + idx + 68] = mem[_9641 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_9741 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9741 + -mem[64] + 100
                        if not totalSupply:
                            revert with 'NH{q', 18
                        if not arg1:
                            if not arg1 * stor15 / 100 / 100:
                                return 0
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10546 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10546] = 30
                            mem[_10546 + 32] = 'SafeMath: subtraction overflow'
                            _11120 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11120] = 30
                            mem[_11120 + 32] = 'SafeMath: subtraction overflow'
                            _12085 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12085] = 30
                            mem[_12085 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                                if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                else:
                                    return 0
                            _12335 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12335 + idx + 68] = mem[_12085 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12335 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12335 + -mem[64] + 100
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 'NH{q', 17
                        if not arg1:
                            revert with 'NH{q', 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _10545 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10545] = 30
                            mem[_10545 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10648 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_10648 + idx + 68] = mem[_10545 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10648 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10648 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _11119 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11119] = 30
                            mem[_11119 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11223 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11223 + idx + 68] = mem[_11119 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11223 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11223 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _12084 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12084] = 30
                            mem[_12084 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor9 / totalSupply)
                            _12334 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12334 + idx + 68] = mem[_12084 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12334 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12334 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11322 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11322] = 30
                        mem[_11322 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11481 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11481 + idx + 68] = mem[_11322 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11481 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11481 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _12552 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12552] = 30
                        mem[_12552 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _12812 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12812 + idx + 68] = mem[_12552 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12812 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12812 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _14212 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14212] = 30
                        mem[_14212 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            return (arg1 * stor9 / totalSupply)
                        _14531 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14531 + idx + 68] = mem[_14212 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14531 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14531 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 'NH{q', 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 'NH{q', 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _9695 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9695] = 30
                        mem[_9695 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _9756 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_9756 + idx + 68] = mem[_9695 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_9756 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9756 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 'NH{q', 17
                        if idx >= stor6.length:
                            revert with 'NH{q', 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _9994 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9994] = 30
                        mem[_9994 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 'NH{q', 17
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _10036 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_10036 + idx + 68] = mem[_9994 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10036 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _10036 + -mem[64] + 100
                    _9742 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9742] = 26
                    mem[_9742 + 32] = 'SafeMath: division by zero'
                    if totalSupply <= 0:
                        _9770 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_9770 + idx + 68] = mem[_9742 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_9770 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9770 + -mem[64] + 100
                    if not totalSupply:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * stor15 / 100 / 100:
                            return 0
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10650 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10650] = 30
                        mem[_10650 + 32] = 'SafeMath: subtraction overflow'
                        _11226 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11226] = 30
                        mem[_11226 + 32] = 'SafeMath: subtraction overflow'
                        _12337 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12337] = 30
                        mem[_12337 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                            if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            else:
                                return 0
                        _12666 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12666 + idx + 68] = mem[_12337 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12666 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12666 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _10649 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10649] = 30
                        mem[_10649 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10704 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_10704 + idx + 68] = mem[_10649 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_10704 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10704 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _11225 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11225] = 30
                        mem[_11225 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11364 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11364 + idx + 68] = mem[_11225 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11364 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11364 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _12336 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12336] = 30
                        mem[_12336 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor9 / totalSupply)
                        _12665 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12665 + idx + 68] = mem[_12336 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12665 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12665 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11484 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11484] = 30
                    mem[_11484 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _11652 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11652 + idx + 68] = mem[_11484 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11652 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11652 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _12816 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12816] = 30
                    mem[_12816 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _13075 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_13075 + idx + 68] = mem[_12816 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_13075 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13075 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _14534 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14534] = 30
                    mem[_14534 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                        if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        return (arg1 * stor9 / totalSupply)
                    _14904 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_14904 + idx + 68] = mem[_14534 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_14904 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14904 + -mem[64] + 100
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if t >= stor9 / totalSupply:
                    if s <= 0:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not s:
                        revert with 'NH{q', 18
                    if not arg1:
                        if arg1 * stor15 / 100 / 100:
                            if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor15 / 100 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor15 / 100 / 100 * t / s:
                                revert with 'NH{q', 17
                            else:
                                return 0
                        else:
                            return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                    else:
                        if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if arg1 * stor15 / 100 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                            revert with 'NH{q', 17
                    return (arg1 * t / s)
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if not arg1:
                    if arg1 * stor15 / 100 / 100:
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        else:
                            return 0
                    else:
                        return 0
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                else:
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
        else:
            if arg1 and stor14 > -1 / arg1:
                revert with 'NH{q', 17
            if not arg1:
                revert with 'NH{q', 18
            if arg1 * stor14 / arg1 != stor14:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 'NH{q', 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if arg1 * stor14 / 100 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * stor14 / 100 / 100:
                    revert with 'NH{q', 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * stor14 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor14 / 100 / 100) < 0:
                    revert with 'NH{q', 17
                idx = 0
                s = totalSupply
                t = stor9
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _9637 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9637] = 26
                        mem[_9637 + 32] = 'SafeMath: division by zero'
                        if totalSupply <= 0:
                            _9739 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_9739 + idx + 68] = mem[_9637 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_9739 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9739 + -mem[64] + 100
                        if not totalSupply:
                            revert with 'NH{q', 18
                        if not arg1:
                            if not arg1 * stor14 / 100 / 100:
                                return 0
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10544 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10544] = 30
                            mem[_10544 + 32] = 'SafeMath: subtraction overflow'
                            _11115 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11115] = 30
                            mem[_11115 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                _11220 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11220 + idx + 68] = mem[_11115 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11220 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11220 + -mem[64] + 100
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            _12080 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12080] = 30
                            mem[_12080 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                else:
                                    return 0
                            _12329 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12329 + idx + 68] = mem[_12080 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12329 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12329 + -mem[64] + 100
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 'NH{q', 17
                        if not arg1:
                            revert with 'NH{q', 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            _10543 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10543] = 30
                            mem[_10543 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10645 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_10645 + idx + 68] = mem[_10543 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10645 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10645 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _11114 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11114] = 30
                            mem[_11114 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11219 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11219 + idx + 68] = mem[_11114 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11219 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11219 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _12079 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12079] = 30
                            mem[_12079 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor9 / totalSupply)
                            _12328 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12328 + idx + 68] = mem[_12079 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12328 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12328 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11317 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11317] = 30
                        mem[_11317 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11476 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11476 + idx + 68] = mem[_11317 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11476 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11476 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _12545 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12545] = 30
                        mem[_12545 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _12806 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12806 + idx + 68] = mem[_12545 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12806 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12806 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _14201 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14201] = 30
                        mem[_14201 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor9 / totalSupply)
                        _14525 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14525 + idx + 68] = mem[_14201 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14525 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14525 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 'NH{q', 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 'NH{q', 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _9694 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9694] = 30
                        mem[_9694 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _9755 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_9755 + idx + 68] = mem[_9694 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_9755 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9755 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 'NH{q', 17
                        if idx >= stor6.length:
                            revert with 'NH{q', 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _9993 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9993] = 30
                        mem[_9993 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 'NH{q', 17
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _10035 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_10035 + idx + 68] = mem[_9993 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10035 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _10035 + -mem[64] + 100
                    _9740 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9740] = 26
                    mem[_9740 + 32] = 'SafeMath: division by zero'
                    if totalSupply <= 0:
                        _9769 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_9769 + idx + 68] = mem[_9740 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_9769 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9769 + -mem[64] + 100
                    if not totalSupply:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * stor14 / 100 / 100:
                            return 0
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10647 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10647] = 30
                        mem[_10647 + 32] = 'SafeMath: subtraction overflow'
                        _11222 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11222] = 30
                        mem[_11222 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                            _11363 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11363 + idx + 68] = mem[_11222 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11363 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11363 + -mem[64] + 100
                        if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _12331 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12331] = 30
                        mem[_12331 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            else:
                                return 0
                        _12661 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12661 + idx + 68] = mem[_12331 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12661 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12661 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        _10646 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10646] = 30
                        mem[_10646 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10703 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_10703 + idx + 68] = mem[_10646 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_10703 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10703 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _11221 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11221] = 30
                        mem[_11221 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11362 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11362 + idx + 68] = mem[_11221 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11362 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11362 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _12330 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12330] = 30
                        mem[_12330 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor9 / totalSupply)
                        _12660 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12660 + idx + 68] = mem[_12330 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12660 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12660 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11480 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11480] = 30
                    mem[_11480 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _11646 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11646 + idx + 68] = mem[_11480 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11646 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11646 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _12811 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12811] = 30
                    mem[_12811 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _13070 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_13070 + idx + 68] = mem[_12811 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_13070 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13070 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    _14528 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14528] = 30
                    mem[_14528 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        return (arg1 * stor9 / totalSupply)
                    _14899 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_14899 + idx + 68] = mem[_14528 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_14899 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14899 + -mem[64] + 100
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if t >= stor9 / totalSupply:
                    if s <= 0:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not s:
                        revert with 'NH{q', 18
                    if not arg1:
                        if arg1 * stor14 / 100 / 100:
                            if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor14 / 100 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor14 / 100 / 100 * t / s:
                                revert with 'NH{q', 17
                            if 0 > -1 * arg1 * stor14 / 100 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor14 / 100 / 100 * t / s < 0:
                                revert with 'NH{q', 17
                            else:
                                return 0
                        else:
                            return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                    else:
                        if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                            revert with 'NH{q', 17
                        if 0 > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                            revert with 'NH{q', 17
                    return (arg1 * t / s)
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if not arg1:
                    if arg1 * stor14 / 100 / 100:
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        if 0 > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        else:
                            return 0
                    else:
                        return 0
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor14 / 100 / 100:
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                else:
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 'NH{q', 17
            else:
                if arg1 and stor15 > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor15 / arg1 != stor15:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 'NH{q', 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if arg1 * stor14 / 100 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * stor14 / 100 / 100:
                    revert with 'NH{q', 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if arg1 * stor15 / 100 / 100 > arg1 - (arg1 * stor14 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor14 / 100 / 100) < arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 17
                idx = 0
                s = totalSupply
                t = stor9
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _9633 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9633] = 26
                        mem[_9633 + 32] = 'SafeMath: division by zero'
                        if totalSupply <= 0:
                            _9737 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_9737 + idx + 68] = mem[_9633 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_9737 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9737 + -mem[64] + 100
                        if not totalSupply:
                            revert with 'NH{q', 18
                        if not arg1:
                            if not arg1 * stor14 / 100 / 100:
                                if not arg1 * stor15 / 100 / 100:
                                    return 0
                                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 18
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _10542 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10542] = 30
                                mem[_10542 + 32] = 'SafeMath: subtraction overflow'
                                _11111 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11111] = 30
                                mem[_11111 + 32] = 'SafeMath: subtraction overflow'
                                _12073 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12073] = 30
                                mem[_12073 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                                    if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                        revert with 'NH{q', 17
                                    else:
                                        return 0
                                _12320 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12320 + idx + 68] = mem[_12073 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12320 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12320 + -mem[64] + 100
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor15 / 100 / 100:
                                _10541 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10541] = 30
                                mem[_10541 + 32] = 'SafeMath: subtraction overflow'
                                _11110 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11110] = 30
                                mem[_11110 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                    _11213 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11213 + idx + 68] = mem[_11110 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11213 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11213 + -mem[64] + 100
                                if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                _12072 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12072] = 30
                                mem[_12072 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                        revert with 'NH{q', 17
                                    else:
                                        return 0
                                _12319 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12319 + idx + 68] = mem[_12072 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12319 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12319 + -mem[64] + 100
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _11314 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11314] = 30
                            mem[_11314 + 32] = 'SafeMath: subtraction overflow'
                            _12536 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12536] = 30
                            mem[_12536 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                _12798 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12798 + idx + 68] = mem[_12536 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12798 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12798 + -mem[64] + 100
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            _14188 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14188] = 30
                            mem[_14188 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                else:
                                    return 0
                            _14516 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14516 + idx + 68] = mem[_14188 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14516 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14516 + -mem[64] + 100
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 'NH{q', 17
                        if not arg1:
                            revert with 'NH{q', 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                _10540 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10540] = 30
                                mem[_10540 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor9 / totalSupply:
                                    _10641 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_10641 + idx + 68] = mem[_10540 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_10641 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _10641 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                _11108 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11108] = 30
                                mem[_11108 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor9 / totalSupply:
                                    _11212 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11212 + idx + 68] = mem[_11108 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11212 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11212 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                _12071 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12071] = 30
                                mem[_12071 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor9 / totalSupply:
                                    if arg1 * stor9 / totalSupply < 0:
                                        revert with 'NH{q', 17
                                    return (arg1 * stor9 / totalSupply)
                                _12318 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12318 + idx + 68] = mem[_12071 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12318 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12318 + -mem[64] + 100
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _11313 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11313] = 30
                            mem[_11313 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11469 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11469 + idx + 68] = mem[_11313 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11469 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11469 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _12535 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12535] = 30
                            mem[_12535 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _12795 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12795 + idx + 68] = mem[_12535 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12795 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12795 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _14186 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14186] = 30
                            mem[_14186 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                return (arg1 * stor9 / totalSupply)
                            _14514 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14514 + idx + 68] = mem[_14186 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14514 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14514 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _11312 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11312] = 30
                            mem[_11312 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11468 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11468 + idx + 68] = mem[_11312 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11468 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11468 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _12534 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12534] = 30
                            mem[_12534 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                _12794 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12794 + idx + 68] = mem[_12534 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12794 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12794 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            _14185 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14185] = 30
                            mem[_14185 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor9 / totalSupply)
                            _14513 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14513 + idx + 68] = mem[_14185 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14513 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14513 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _12956 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12956] = 30
                        mem[_12956 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _13200 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_13200 + idx + 68] = mem[_12956 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_13200 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13200 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _14739 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14739] = 30
                        mem[_14739 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _15028 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_15028 + idx + 68] = mem[_14739 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_15028 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15028 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _16303 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16303] = 30
                        mem[_16303 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            return (arg1 * stor9 / totalSupply)
                        _16573 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_16573 + idx + 68] = mem[_16303 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_16573 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16573 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 'NH{q', 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 'NH{q', 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _9693 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9693] = 30
                        mem[_9693 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _9754 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_9754 + idx + 68] = mem[_9693 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_9754 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9754 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 'NH{q', 17
                        if idx >= stor6.length:
                            revert with 'NH{q', 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _9992 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9992] = 30
                        mem[_9992 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 'NH{q', 17
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _10034 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_10034 + idx + 68] = mem[_9992 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10034 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _10034 + -mem[64] + 100
                    _9738 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9738] = 26
                    mem[_9738 + 32] = 'SafeMath: division by zero'
                    if totalSupply <= 0:
                        _9768 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_9768 + idx + 68] = mem[_9738 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_9768 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9768 + -mem[64] + 100
                    if not totalSupply:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * stor14 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                return 0
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10644 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10644] = 30
                            mem[_10644 + 32] = 'SafeMath: subtraction overflow'
                            _11218 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11218] = 30
                            mem[_11218 + 32] = 'SafeMath: subtraction overflow'
                            _12323 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12323] = 30
                            mem[_12323 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                                if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                else:
                                    return 0
                            _12656 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12656 + idx + 68] = mem[_12323 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12656 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12656 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _10643 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10643] = 30
                            mem[_10643 + 32] = 'SafeMath: subtraction overflow'
                            _11217 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11217] = 30
                            mem[_11217 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                _11360 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11360 + idx + 68] = mem[_11217 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11360 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11360 + -mem[64] + 100
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            _12322 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12322] = 30
                            mem[_12322 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                else:
                                    return 0
                            _12655 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12655 + idx + 68] = mem[_12322 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12655 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12655 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11475 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11475] = 30
                        mem[_11475 + 32] = 'SafeMath: subtraction overflow'
                        _12805 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12805] = 30
                        mem[_12805 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                            _13066 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_13066 + idx + 68] = mem[_12805 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_13066 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13066 + -mem[64] + 100
                        if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _14522 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14522] = 30
                        mem[_14522 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            else:
                                return 0
                        _14894 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14894 + idx + 68] = mem[_14522 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14894 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14894 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            _10642 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10642] = 30
                            mem[_10642 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10702 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_10702 + idx + 68] = mem[_10642 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10702 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10702 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _11215 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11215] = 30
                            mem[_11215 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11359 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11359 + idx + 68] = mem[_11215 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11359 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11359 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _12321 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12321] = 30
                            mem[_12321 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor9 / totalSupply)
                            _12654 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12654 + idx + 68] = mem[_12321 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12654 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12654 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11474 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11474] = 30
                        mem[_11474 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11640 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11640 + idx + 68] = mem[_11474 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11640 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11640 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _12804 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12804] = 30
                        mem[_12804 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _13063 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_13063 + idx + 68] = mem[_12804 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_13063 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13063 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _14520 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14520] = 30
                        mem[_14520 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            return (arg1 * stor9 / totalSupply)
                        _14892 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14892 + idx + 68] = mem[_14520 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14892 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14892 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _11473 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11473] = 30
                        mem[_11473 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11639 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11639 + idx + 68] = mem[_11473 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11639 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11639 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _12803 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12803] = 30
                        mem[_12803 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _13062 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_13062 + idx + 68] = mem[_12803 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_13062 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13062 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _14519 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14519] = 30
                        mem[_14519 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor9 / totalSupply)
                        _14891 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14891 + idx + 68] = mem[_14519 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14891 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14891 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _13206 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13206] = 30
                    mem[_13206 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _13487 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_13487 + idx + 68] = mem[_13206 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_13487 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13487 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    _15035 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15035] = 30
                    mem[_15035 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _15322 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_15322 + idx + 68] = mem[_15035 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_15322 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15322 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    _16577 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16577] = 30
                    mem[_16577 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        return (arg1 * stor9 / totalSupply)
                    _16757 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_16757 + idx + 68] = mem[_16577 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_16757 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16757 + -mem[64] + 100
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if t >= stor9 / totalSupply:
                    if s <= 0:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not s:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * stor14 / 100 / 100:
                            if arg1 * stor15 / 100 / 100:
                                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 18
                                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor15 / 100 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor15 / 100 / 100 * t / s:
                                    revert with 'NH{q', 17
                        else:
                            if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor15 / 100 / 100:
                                if arg1 * stor14 / 100 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor14 / 100 / 100 * t / s:
                                    revert with 'NH{q', 17
                                if 0 > -1 * arg1 * stor14 / 100 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor14 / 100 / 100 * t / s < 0:
                                    revert with 'NH{q', 17
                            else:
                                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 18
                                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor14 / 100 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor14 / 100 / 100 * t / s:
                                    revert with 'NH{q', 17
                                if arg1 * stor15 / 100 / 100 * t / s > -1 * arg1 * stor14 / 100 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor14 / 100 / 100 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                                    revert with 'NH{q', 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 'NH{q', 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 'NH{q', 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 'NH{q', 17
                        else:
                            if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 'NH{q', 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 'NH{q', 17
                            if arg1 * stor15 / 100 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                                revert with 'NH{q', 17
                    else:
                        if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 'NH{q', 17
                            if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                                revert with 'NH{q', 17
                            if 0 > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                                revert with 'NH{q', 17
                        else:
                            if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 'NH{q', 17
                            if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                                revert with 'NH{q', 17
                            if arg1 * stor15 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                                revert with 'NH{q', 17
                    return (arg1 * t / s)
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if not arg1:
                    if not arg1 * stor14 / 100 / 100:
                        if arg1 * stor15 / 100 / 100:
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                    else:
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            if 0 > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                        else:
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                    return 0
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor14 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                    else:
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                else:
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 'NH{q', 17
                    else:
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
    else:
        if arg1 and stor13 > -1 / arg1:
            revert with 'NH{q', 17
        if not arg1:
            revert with 'NH{q', 18
        if arg1 * stor13 / arg1 != stor13:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        mem[160] = 26
        mem[192] = 'SafeMath: division by zero'
        if not arg1:
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * stor13 / 100 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * stor13 / 100 / 100:
                    revert with 'NH{q', 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * stor13 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor13 / 100 / 100) < 0:
                    revert with 'NH{q', 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * stor13 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor13 / 100 / 100) < 0:
                    revert with 'NH{q', 17
                idx = 0
                s = totalSupply
                t = stor9
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _9629 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9629] = 26
                        mem[_9629 + 32] = 'SafeMath: division by zero'
                        if totalSupply <= 0:
                            _9735 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_9735 + idx + 68] = mem[_9629 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_9735 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9735 + -mem[64] + 100
                        if not totalSupply:
                            revert with 'NH{q', 18
                        if not arg1:
                            if not arg1 * stor13 / 100 / 100:
                                return 0
                            if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor13 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10539 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10539] = 30
                            mem[_10539 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _10638 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_10638 + idx + 68] = mem[_10539 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10638 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10638 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            _11103 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11103] = 30
                            mem[_11103 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _11209 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11209 + idx + 68] = mem[_11103 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11209 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11209 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _12065 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12065] = 30
                            mem[_12065 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                else:
                                    return 0
                            _12310 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12310 + idx + 68] = mem[_12065 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12310 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12310 + -mem[64] + 100
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 'NH{q', 17
                        if not arg1:
                            revert with 'NH{q', 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor13 / 100 / 100:
                            _10538 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10538] = 30
                            mem[_10538 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10637 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_10637 + idx + 68] = mem[_10538 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10637 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10637 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _11102 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11102] = 30
                            mem[_11102 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11208 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11208 + idx + 68] = mem[_11102 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11208 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11208 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _12064 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12064] = 30
                            mem[_12064 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor9 / totalSupply)
                            _12309 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12309 + idx + 68] = mem[_12064 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12309 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12309 + -mem[64] + 100
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11307 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11307] = 30
                        mem[_11307 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _11462 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11462 + idx + 68] = mem[_11307 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11462 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11462 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _12522 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12522] = 30
                        mem[_12522 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _12788 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12788 + idx + 68] = mem[_12522 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12788 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12788 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        _14166 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14166] = 30
                        mem[_14166 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor9 / totalSupply)
                        _14506 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14506 + idx + 68] = mem[_14166 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14506 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14506 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 'NH{q', 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 'NH{q', 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _9692 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9692] = 30
                        mem[_9692 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _9753 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_9753 + idx + 68] = mem[_9692 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_9753 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9753 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 'NH{q', 17
                        if idx >= stor6.length:
                            revert with 'NH{q', 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _9991 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9991] = 30
                        mem[_9991 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 'NH{q', 17
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _10033 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_10033 + idx + 68] = mem[_9991 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10033 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _10033 + -mem[64] + 100
                    _9736 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9736] = 26
                    mem[_9736 + 32] = 'SafeMath: division by zero'
                    if totalSupply <= 0:
                        _9767 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_9767 + idx + 68] = mem[_9736 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_9767 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9767 + -mem[64] + 100
                    if not totalSupply:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * stor13 / 100 / 100:
                            return 0
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10640 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10640] = 30
                        mem[_10640 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _10701 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_10701 + idx + 68] = mem[_10640 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_10701 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10701 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _11211 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11211] = 30
                        mem[_11211 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _11357 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11357 + idx + 68] = mem[_11211 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11357 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11357 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _12312 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12312] = 30
                        mem[_12312 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            else:
                                return 0
                        _12649 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12649 + idx + 68] = mem[_12312 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12649 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12649 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        _10639 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10639] = 30
                        mem[_10639 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10700 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_10700 + idx + 68] = mem[_10639 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_10700 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10700 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _11210 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11210] = 30
                        mem[_11210 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11356 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11356 + idx + 68] = mem[_11210 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11356 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11356 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _12311 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12311] = 30
                        mem[_12311 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor9 / totalSupply)
                        _12648 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12648 + idx + 68] = mem[_12311 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12648 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12648 + -mem[64] + 100
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11467 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11467] = 30
                    mem[_11467 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _11632 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11632 + idx + 68] = mem[_11467 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11632 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11632 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    _12793 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12793] = 30
                    mem[_12793 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _13057 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_13057 + idx + 68] = mem[_12793 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_13057 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13057 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 'NH{q', 17
                    _14509 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14509] = 30
                    mem[_14509 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        return (arg1 * stor9 / totalSupply)
                    _14883 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_14883 + idx + 68] = mem[_14509 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_14883 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14883 + -mem[64] + 100
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if t >= stor9 / totalSupply:
                    if s <= 0:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not s:
                        revert with 'NH{q', 18
                    if not arg1:
                        if arg1 * stor13 / 100 / 100:
                            if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor13 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor13 / 100 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor13 / 100 / 100 * t / s:
                                revert with 'NH{q', 17
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                                revert with 'NH{q', 17
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                                revert with 'NH{q', 17
                            else:
                                return 0
                        else:
                            return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 'NH{q', 17
                    else:
                        if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                            revert with 'NH{q', 17
                        if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                            revert with 'NH{q', 17
                        if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                            revert with 'NH{q', 17
                    return (arg1 * t / s)
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if not arg1:
                    if arg1 * stor13 / 100 / 100:
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        else:
                            return 0
                    else:
                        return 0
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor13 / 100 / 100:
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 'NH{q', 17
                else:
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 'NH{q', 17
                    if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 'NH{q', 17
            else:
                if arg1 and stor15 > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor15 / arg1 != stor15:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * stor13 / 100 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * stor13 / 100 / 100:
                    revert with 'NH{q', 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * stor13 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor13 / 100 / 100) < 0:
                    revert with 'NH{q', 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if arg1 * stor15 / 100 / 100 > arg1 - (arg1 * stor13 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor13 / 100 / 100) < arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 17
                idx = 0
                s = totalSupply
                t = stor9
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _9625 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9625] = 26
                        mem[_9625 + 32] = 'SafeMath: division by zero'
                        if totalSupply <= 0:
                            _9733 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_9733 + idx + 68] = mem[_9625 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_9733 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9733 + -mem[64] + 100
                        if not totalSupply:
                            revert with 'NH{q', 18
                        if not arg1:
                            if not arg1 * stor13 / 100 / 100:
                                if not arg1 * stor15 / 100 / 100:
                                    return 0
                                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 18
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _10537 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10537] = 30
                                mem[_10537 + 32] = 'SafeMath: subtraction overflow'
                                _11094 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11094] = 30
                                mem[_11094 + 32] = 'SafeMath: subtraction overflow'
                                _12058 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12058] = 30
                                mem[_12058 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                                    if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                        revert with 'NH{q', 17
                                    else:
                                        return 0
                                _12303 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12303 + idx + 68] = mem[_12058 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12303 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12303 + -mem[64] + 100
                            if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor13 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor15 / 100 / 100:
                                _10536 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10536] = 30
                                mem[_10536 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                    _10632 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_10632 + idx + 68] = mem[_10536 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_10632 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _10632 + -mem[64] + 100
                                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                _11093 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11093] = 30
                                mem[_11093 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    _11202 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11202 + idx + 68] = mem[_11093 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11202 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11202 + -mem[64] + 100
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                _12057 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12057] = 30
                                mem[_12057 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                        revert with 'NH{q', 17
                                    else:
                                        return 0
                                _12302 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12302 + idx + 68] = mem[_12057 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12302 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12302 + -mem[64] + 100
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _11302 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11302] = 30
                            mem[_11302 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _11456 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11456 + idx + 68] = mem[_11302 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11456 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11456 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            _12511 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12511] = 30
                            mem[_12511 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _12780 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12780 + idx + 68] = mem[_12511 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12780 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12780 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _14153 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14153] = 30
                            mem[_14153 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                else:
                                    return 0
                            _14497 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14497 + idx + 68] = mem[_14153 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14497 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14497 + -mem[64] + 100
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 'NH{q', 17
                        if not arg1:
                            revert with 'NH{q', 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor13 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                _10535 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10535] = 30
                                mem[_10535 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor9 / totalSupply:
                                    _10631 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_10631 + idx + 68] = mem[_10535 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_10631 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _10631 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                _11091 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11091] = 30
                                mem[_11091 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor9 / totalSupply:
                                    _11201 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11201 + idx + 68] = mem[_11091 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11201 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11201 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                _12056 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12056] = 30
                                mem[_12056 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor9 / totalSupply:
                                    if arg1 * stor9 / totalSupply < 0:
                                        revert with 'NH{q', 17
                                    return (arg1 * stor9 / totalSupply)
                                _12300 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12300 + idx + 68] = mem[_12056 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12300 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12300 + -mem[64] + 100
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _11301 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11301] = 30
                            mem[_11301 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11453 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11453 + idx + 68] = mem[_11301 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11453 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11453 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _12510 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12510] = 30
                            mem[_12510 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _12777 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12777 + idx + 68] = mem[_12510 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12777 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12777 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _14151 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14151] = 30
                            mem[_14151 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                return (arg1 * stor9 / totalSupply)
                            _14495 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14495 + idx + 68] = mem[_14151 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14495 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14495 + -mem[64] + 100
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _11300 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11300] = 30
                            mem[_11300 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                _11452 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11452 + idx + 68] = mem[_11300 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11452 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11452 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            _12509 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12509] = 30
                            mem[_12509 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                _12776 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12776 + idx + 68] = mem[_12509 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12776 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12776 + -mem[64] + 100
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            _14150 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14150] = 30
                            mem[_14150 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor9 / totalSupply)
                            _14494 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14494 + idx + 68] = mem[_14150 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14494 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14494 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _12939 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12939] = 30
                        mem[_12939 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _13184 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_13184 + idx + 68] = mem[_12939 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_13184 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13184 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _14717 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14717] = 30
                        mem[_14717 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _15013 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_15013 + idx + 68] = mem[_14717 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_15013 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15013 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        _16280 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16280] = 30
                        mem[_16280 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            return (arg1 * stor9 / totalSupply)
                        _16563 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_16563 + idx + 68] = mem[_16280 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_16563 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16563 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 'NH{q', 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 'NH{q', 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _9691 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9691] = 30
                        mem[_9691 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _9752 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_9752 + idx + 68] = mem[_9691 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_9752 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9752 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 'NH{q', 17
                        if idx >= stor6.length:
                            revert with 'NH{q', 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _9990 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9990] = 30
                        mem[_9990 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 'NH{q', 17
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _10032 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_10032 + idx + 68] = mem[_9990 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10032 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _10032 + -mem[64] + 100
                    _9734 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9734] = 26
                    mem[_9734 + 32] = 'SafeMath: division by zero'
                    if totalSupply <= 0:
                        _9766 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_9766 + idx + 68] = mem[_9734 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_9766 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9766 + -mem[64] + 100
                    if not totalSupply:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * stor13 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                return 0
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10635 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10635] = 30
                            mem[_10635 + 32] = 'SafeMath: subtraction overflow'
                            _11207 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11207] = 30
                            mem[_11207 + 32] = 'SafeMath: subtraction overflow'
                            _12306 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12306] = 30
                            mem[_12306 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                                if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                else:
                                    return 0
                            _12642 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12642 + idx + 68] = mem[_12306 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12642 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12642 + -mem[64] + 100
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _10634 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10634] = 30
                            mem[_10634 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _10698 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_10698 + idx + 68] = mem[_10634 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10698 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10698 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            _11206 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11206] = 30
                            mem[_11206 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _11355 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11355 + idx + 68] = mem[_11206 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11355 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11355 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _12305 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12305] = 30
                            mem[_12305 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                else:
                                    return 0
                            _12641 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12641 + idx + 68] = mem[_12305 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12641 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12641 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11461 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11461] = 30
                        mem[_11461 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _11627 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11627 + idx + 68] = mem[_11461 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11627 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11627 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _12787 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12787] = 30
                        mem[_12787 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _13053 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_13053 + idx + 68] = mem[_12787 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_13053 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13053 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _14503 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14503] = 30
                        mem[_14503 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            else:
                                return 0
                        _14878 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14878 + idx + 68] = mem[_14503 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14878 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14878 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            _10633 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10633] = 30
                            mem[_10633 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10697 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_10697 + idx + 68] = mem[_10633 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10697 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10697 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _11204 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11204] = 30
                            mem[_11204 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11354 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11354 + idx + 68] = mem[_11204 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11354 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11354 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _12304 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12304] = 30
                            mem[_12304 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor9 / totalSupply)
                            _12639 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12639 + idx + 68] = mem[_12304 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12639 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12639 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11460 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11460] = 30
                        mem[_11460 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11624 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11624 + idx + 68] = mem[_11460 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11624 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11624 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _12786 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12786] = 30
                        mem[_12786 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _13050 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_13050 + idx + 68] = mem[_12786 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_13050 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13050 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _14501 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14501] = 30
                        mem[_14501 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            return (arg1 * stor9 / totalSupply)
                        _14876 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14876 + idx + 68] = mem[_14501 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14876 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14876 + -mem[64] + 100
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _11459 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11459] = 30
                        mem[_11459 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _11623 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11623 + idx + 68] = mem[_11459 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11623 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11623 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _12785 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12785] = 30
                        mem[_12785 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _13049 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_13049 + idx + 68] = mem[_12785 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_13049 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13049 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        _14500 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14500] = 30
                        mem[_14500 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor9 / totalSupply)
                        _14875 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14875 + idx + 68] = mem[_14500 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14875 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14875 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _13191 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13191] = 30
                    mem[_13191 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _13464 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_13464 + idx + 68] = mem[_13191 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_13464 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13464 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    _15020 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15020] = 30
                    mem[_15020 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _15313 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_15313 + idx + 68] = mem[_15020 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_15313 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15313 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 'NH{q', 17
                    _16567 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16567] = 30
                    mem[_16567 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        return (arg1 * stor9 / totalSupply)
                    _16750 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_16750 + idx + 68] = mem[_16567 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_16750 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16750 + -mem[64] + 100
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if t >= stor9 / totalSupply:
                    if s <= 0:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not s:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * stor13 / 100 / 100:
                            if arg1 * stor15 / 100 / 100:
                                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 18
                                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor15 / 100 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor15 / 100 / 100 * t / s:
                                    revert with 'NH{q', 17
                        else:
                            if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor13 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor15 / 100 / 100:
                                if arg1 * stor13 / 100 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 'NH{q', 17
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                                    revert with 'NH{q', 17
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                                    revert with 'NH{q', 17
                            else:
                                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 18
                                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor13 / 100 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 'NH{q', 17
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                                    revert with 'NH{q', 17
                                if arg1 * stor15 / 100 / 100 * t / s > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                                    revert with 'NH{q', 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 'NH{q', 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 'NH{q', 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 'NH{q', 17
                        else:
                            if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 'NH{q', 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 'NH{q', 17
                            if arg1 * stor15 / 100 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                                revert with 'NH{q', 17
                    else:
                        if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                                revert with 'NH{q', 17
                            if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                                revert with 'NH{q', 17
                            if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                                revert with 'NH{q', 17
                        else:
                            if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                                revert with 'NH{q', 17
                            if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                                revert with 'NH{q', 17
                            if arg1 * stor15 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                                revert with 'NH{q', 17
                    return (arg1 * t / s)
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if not arg1:
                    if not arg1 * stor13 / 100 / 100:
                        if arg1 * stor15 / 100 / 100:
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                    else:
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                        else:
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                    return 0
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                    else:
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                else:
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 'NH{q', 17
                    else:
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
        else:
            if arg1 and stor14 > -1 / arg1:
                revert with 'NH{q', 17
            if not arg1:
                revert with 'NH{q', 18
            if arg1 * stor14 / arg1 != stor14:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * stor13 / 100 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * stor13 / 100 / 100:
                    revert with 'NH{q', 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if arg1 * stor14 / 100 / 100 > arg1 - (arg1 * stor13 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor13 / 100 / 100) < arg1 * stor14 / 100 / 100:
                    revert with 'NH{q', 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * stor13 / 100 / 100) - (arg1 * stor14 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor13 / 100 / 100) - (arg1 * stor14 / 100 / 100) < 0:
                    revert with 'NH{q', 17
                idx = 0
                s = totalSupply
                t = stor9
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _9621 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9621] = 26
                        mem[_9621 + 32] = 'SafeMath: division by zero'
                        if totalSupply <= 0:
                            _9731 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_9731 + idx + 68] = mem[_9621 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_9731 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9731 + -mem[64] + 100
                        if not totalSupply:
                            revert with 'NH{q', 18
                        if not arg1:
                            if not arg1 * stor13 / 100 / 100:
                                if not arg1 * stor14 / 100 / 100:
                                    return 0
                                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                    revert with 'NH{q', 17
                                if not arg1 * stor14 / 100 / 100:
                                    revert with 'NH{q', 18
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _10534 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10534] = 30
                                mem[_10534 + 32] = 'SafeMath: subtraction overflow'
                                _11082 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11082] = 30
                                mem[_11082 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                    _11197 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11197 + idx + 68] = mem[_11082 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11197 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11197 + -mem[64] + 100
                                if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                _12050 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12050] = 30
                                mem[_12050 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                        revert with 'NH{q', 17
                                    else:
                                        return 0
                                _12293 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12293 + idx + 68] = mem[_12050 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12293 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12293 + -mem[64] + 100
                            if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor13 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor14 / 100 / 100:
                                _10533 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10533] = 30
                                mem[_10533 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                    _10626 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_10626 + idx + 68] = mem[_10533 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_10626 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _10626 + -mem[64] + 100
                                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                _11081 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11081] = 30
                                mem[_11081 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    _11196 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11196 + idx + 68] = mem[_11081 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11196 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11196 + -mem[64] + 100
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                _12049 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12049] = 30
                                mem[_12049 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                        revert with 'NH{q', 17
                                    else:
                                        return 0
                                _12292 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12292 + idx + 68] = mem[_12049 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12292 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12292 + -mem[64] + 100
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _11293 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11293] = 30
                            mem[_11293 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _11445 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11445 + idx + 68] = mem[_11293 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11445 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11445 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            _12493 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12493] = 30
                            mem[_12493 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _12768 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12768 + idx + 68] = mem[_12493 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12768 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12768 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            _14131 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14131] = 30
                            mem[_14131 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                    revert with 'NH{q', 17
                                else:
                                    return 0
                            _14484 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14484 + idx + 68] = mem[_14131 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14484 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14484 + -mem[64] + 100
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 'NH{q', 17
                        if not arg1:
                            revert with 'NH{q', 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor13 / 100 / 100:
                            if not arg1 * stor14 / 100 / 100:
                                _10532 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10532] = 30
                                mem[_10532 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor9 / totalSupply:
                                    _10625 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_10625 + idx + 68] = mem[_10532 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_10625 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _10625 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                _11080 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11080] = 30
                                mem[_11080 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor9 / totalSupply:
                                    _11195 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11195 + idx + 68] = mem[_11080 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11195 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11195 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                _12048 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12048] = 30
                                mem[_12048 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor9 / totalSupply:
                                    if arg1 * stor9 / totalSupply < 0:
                                        revert with 'NH{q', 17
                                    return (arg1 * stor9 / totalSupply)
                                _12290 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12290 + idx + 68] = mem[_12048 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12290 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12290 + -mem[64] + 100
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _11292 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11292] = 30
                            mem[_11292 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11442 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11442 + idx + 68] = mem[_11292 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11442 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11442 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _12492 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12492] = 30
                            mem[_12492 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                _12765 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12765 + idx + 68] = mem[_12492 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12765 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12765 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            _14129 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14129] = 30
                            mem[_14129 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor9 / totalSupply)
                            _14482 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14482 + idx + 68] = mem[_14129 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14482 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14482 + -mem[64] + 100
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            _11291 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11291] = 30
                            mem[_11291 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                _11441 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11441 + idx + 68] = mem[_11291 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11441 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11441 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            _12491 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12491] = 30
                            mem[_12491 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                _12764 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12764 + idx + 68] = mem[_12491 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12764 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12764 + -mem[64] + 100
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            _14128 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14128] = 30
                            mem[_14128 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor9 / totalSupply)
                            _14481 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14481 + idx + 68] = mem[_14128 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14481 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14481 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _12924 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12924] = 30
                        mem[_12924 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _13172 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_13172 + idx + 68] = mem[_12924 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_13172 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13172 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _14699 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14699] = 30
                        mem[_14699 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _15002 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_15002 + idx + 68] = mem[_14699 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_15002 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15002 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _16262 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16262] = 30
                        mem[_16262 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor9 / totalSupply)
                        _16555 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_16555 + idx + 68] = mem[_16262 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_16555 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16555 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 'NH{q', 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 'NH{q', 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _9690 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9690] = 30
                        mem[_9690 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _9751 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_9751 + idx + 68] = mem[_9690 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_9751 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9751 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 'NH{q', 17
                        if idx >= stor6.length:
                            revert with 'NH{q', 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _9989 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9989] = 30
                        mem[_9989 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 'NH{q', 17
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _10031 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_10031 + idx + 68] = mem[_9989 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10031 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _10031 + -mem[64] + 100
                    _9732 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9732] = 26
                    mem[_9732 + 32] = 'SafeMath: division by zero'
                    if totalSupply <= 0:
                        _9765 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_9765 + idx + 68] = mem[_9732 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_9765 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9765 + -mem[64] + 100
                    if not totalSupply:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * stor13 / 100 / 100:
                            if not arg1 * stor14 / 100 / 100:
                                return 0
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10629 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10629] = 30
                            mem[_10629 + 32] = 'SafeMath: subtraction overflow'
                            _11200 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11200] = 30
                            mem[_11200 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                _11353 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11353 + idx + 68] = mem[_11200 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11353 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11353 + -mem[64] + 100
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            _12296 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12296] = 30
                            mem[_12296 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                else:
                                    return 0
                            _12632 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12632 + idx + 68] = mem[_12296 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12632 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12632 + -mem[64] + 100
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            _10628 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10628] = 30
                            mem[_10628 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _10695 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_10695 + idx + 68] = mem[_10628 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10695 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10695 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            _11199 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11199] = 30
                            mem[_11199 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _11352 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11352 + idx + 68] = mem[_11199 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11352 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11352 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _12295 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12295] = 30
                            mem[_12295 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                else:
                                    return 0
                            _12631 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12631 + idx + 68] = mem[_12295 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12631 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12631 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11451 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11451] = 30
                        mem[_11451 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _11617 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11617 + idx + 68] = mem[_11451 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11617 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11617 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _12775 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12775] = 30
                        mem[_12775 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _13044 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_13044 + idx + 68] = mem[_12775 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_13044 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13044 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _14490 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14490] = 30
                        mem[_14490 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            else:
                                return 0
                        _14865 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14865 + idx + 68] = mem[_14490 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14865 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14865 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor14 / 100 / 100:
                            _10627 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10627] = 30
                            mem[_10627 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10694 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_10694 + idx + 68] = mem[_10627 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10694 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10694 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _11198 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11198] = 30
                            mem[_11198 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11351 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11351 + idx + 68] = mem[_11198 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11351 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11351 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _12294 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12294] = 30
                            mem[_12294 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor9 / totalSupply)
                            _12629 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12629 + idx + 68] = mem[_12294 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12629 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12629 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11450 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11450] = 30
                        mem[_11450 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11614 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11614 + idx + 68] = mem[_11450 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11614 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11614 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _12774 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12774] = 30
                        mem[_12774 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _13041 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_13041 + idx + 68] = mem[_12774 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_13041 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13041 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _14488 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14488] = 30
                        mem[_14488 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor9 / totalSupply)
                        _14863 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14863 + idx + 68] = mem[_14488 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14863 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14863 + -mem[64] + 100
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        _11449 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11449] = 30
                        mem[_11449 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _11613 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11613 + idx + 68] = mem[_11449 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11613 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11613 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _12773 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12773] = 30
                        mem[_12773 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _13040 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_13040 + idx + 68] = mem[_12773 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_13040 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13040 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        _14487 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14487] = 30
                        mem[_14487 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor9 / totalSupply)
                        _14862 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14862 + idx + 68] = mem[_14487 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14862 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14862 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _13179 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13179] = 30
                    mem[_13179 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _13449 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_13449 + idx + 68] = mem[_13179 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_13449 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13449 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    _15009 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15009] = 30
                    mem[_15009 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _15306 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_15306 + idx + 68] = mem[_15009 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_15306 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15306 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    _16559 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16559] = 30
                    mem[_16559 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        return (arg1 * stor9 / totalSupply)
                    _16744 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_16744 + idx + 68] = mem[_16559 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_16744 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16744 + -mem[64] + 100
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if t >= stor9 / totalSupply:
                    if s <= 0:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not s:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * stor13 / 100 / 100:
                            if arg1 * stor14 / 100 / 100:
                                if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                                    revert with 'NH{q', 17
                                if not arg1 * stor14 / 100 / 100:
                                    revert with 'NH{q', 18
                                if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor14 / 100 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor14 / 100 / 100 * t / s:
                                    revert with 'NH{q', 17
                                if 0 > -1 * arg1 * stor14 / 100 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor14 / 100 / 100 * t / s < 0:
                                    revert with 'NH{q', 17
                        else:
                            if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor13 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor14 / 100 / 100:
                                if arg1 * stor13 / 100 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 'NH{q', 17
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                                    revert with 'NH{q', 17
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                                    revert with 'NH{q', 17
                            else:
                                if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                                    revert with 'NH{q', 17
                                if not arg1 * stor14 / 100 / 100:
                                    revert with 'NH{q', 18
                                if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor13 / 100 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 'NH{q', 17
                                if arg1 * stor14 / 100 / 100 * t / s > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                                    revert with 'NH{q', 17
                                if 0 > (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                                    revert with 'NH{q', 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor14 / 100 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 'NH{q', 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 'NH{q', 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 'NH{q', 17
                        else:
                            if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 'NH{q', 17
                            if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                                revert with 'NH{q', 17
                            if 0 > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                                revert with 'NH{q', 17
                    else:
                        if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                                revert with 'NH{q', 17
                            if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                                revert with 'NH{q', 17
                            if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                                revert with 'NH{q', 17
                        else:
                            if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                                revert with 'NH{q', 17
                            if arg1 * stor14 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < arg1 * stor14 / 100 / 100 * t / s:
                                revert with 'NH{q', 17
                            if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                                revert with 'NH{q', 17
                    return (arg1 * t / s)
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if not arg1:
                    if not arg1 * stor13 / 100 / 100:
                        if arg1 * stor14 / 100 / 100:
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            if 0 > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                    else:
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                        else:
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            if 0 > (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 'NH{q', 17
                    return 0
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor14 / 100 / 100:
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                    else:
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 'NH{q', 17
                else:
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 'NH{q', 17
                    else:
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 'NH{q', 17
            else:
                if arg1 and stor15 > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor15 / arg1 != stor15:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * stor13 / 100 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * stor13 / 100 / 100:
                    revert with 'NH{q', 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if arg1 * stor14 / 100 / 100 > arg1 - (arg1 * stor13 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor13 / 100 / 100) < arg1 * stor14 / 100 / 100:
                    revert with 'NH{q', 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if arg1 * stor15 / 100 / 100 > arg1 - (arg1 * stor13 / 100 / 100) - (arg1 * stor14 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor13 / 100 / 100) - (arg1 * stor14 / 100 / 100) < arg1 * stor15 / 100 / 100:
                    revert with 'NH{q', 17
                idx = 0
                s = totalSupply
                t = stor9
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _9617 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9617] = 26
                        mem[_9617 + 32] = 'SafeMath: division by zero'
                        if totalSupply <= 0:
                            _9729 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_9729 + idx + 68] = mem[_9617 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_9729 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9729 + -mem[64] + 100
                        if not totalSupply:
                            revert with 'NH{q', 18
                        if not arg1:
                            if not arg1 * stor13 / 100 / 100:
                                if not arg1 * stor14 / 100 / 100:
                                    if not arg1 * stor15 / 100 / 100:
                                        return 0
                                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                        revert with 'NH{q', 17
                                    if not arg1 * stor15 / 100 / 100:
                                        revert with 'NH{q', 18
                                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _10531 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10531] = 30
                                    mem[_10531 + 32] = 'SafeMath: subtraction overflow'
                                    _11072 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11072] = 30
                                    mem[_11072 + 32] = 'SafeMath: subtraction overflow'
                                    _12040 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12040] = 30
                                    mem[_12040 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                                        if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                            revert with 'NH{q', 17
                                        else:
                                            return 0
                                    _12278 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12278 + idx + 68] = mem[_12040 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12278 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12278 + -mem[64] + 100
                                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                    revert with 'NH{q', 17
                                if not arg1 * stor14 / 100 / 100:
                                    revert with 'NH{q', 18
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * stor15 / 100 / 100:
                                    _10530 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10530] = 30
                                    mem[_10530 + 32] = 'SafeMath: subtraction overflow'
                                    _11071 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11071] = 30
                                    mem[_11071 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                        _11187 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_11187 + idx + 68] = mem[_11071 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_11187 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _11187 + -mem[64] + 100
                                    if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                        revert with 'NH{q', 17
                                    _12039 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12039] = 30
                                    mem[_12039 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                        if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                            revert with 'NH{q', 17
                                        else:
                                            return 0
                                    _12277 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12277 + idx + 68] = mem[_12039 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12277 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12277 + -mem[64] + 100
                                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 18
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _11286 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11286] = 30
                                mem[_11286 + 32] = 'SafeMath: subtraction overflow'
                                _12474 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12474] = 30
                                mem[_12474 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                    _12751 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12751 + idx + 68] = mem[_12474 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12751 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12751 + -mem[64] + 100
                                if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                _14107 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14107] = 30
                                mem[_14107 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                        revert with 'NH{q', 17
                                    else:
                                        return 0
                                _14465 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14465 + idx + 68] = mem[_14107 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14465 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14465 + -mem[64] + 100
                            if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor13 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor14 / 100 / 100:
                                if not arg1 * stor15 / 100 / 100:
                                    _10529 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10529] = 30
                                    mem[_10529 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                        _10619 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_10619 + idx + 68] = mem[_10529 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_10619 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _10619 + -mem[64] + 100
                                    if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                        revert with 'NH{q', 17
                                    _11069 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11069] = 30
                                    mem[_11069 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                        _11186 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_11186 + idx + 68] = mem[_11069 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_11186 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _11186 + -mem[64] + 100
                                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                        revert with 'NH{q', 17
                                    _12038 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12038] = 30
                                    mem[_12038 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                            revert with 'NH{q', 17
                                        else:
                                            return 0
                                    _12276 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12276 + idx + 68] = mem[_12038 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12276 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12276 + -mem[64] + 100
                                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 18
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _11285 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11285] = 30
                                mem[_11285 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                    _11431 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11431 + idx + 68] = mem[_11285 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11431 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11431 + -mem[64] + 100
                                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                _12473 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12473] = 30
                                mem[_12473 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    _12748 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12748 + idx + 68] = mem[_12473 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12748 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12748 + -mem[64] + 100
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                _14105 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14105] = 30
                                mem[_14105 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                        revert with 'NH{q', 17
                                    else:
                                        return 0
                                _14463 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14463 + idx + 68] = mem[_14105 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14463 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14463 + -mem[64] + 100
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor15 / 100 / 100:
                                _11284 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11284] = 30
                                mem[_11284 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                    _11430 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11430 + idx + 68] = mem[_11284 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11430 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11430 + -mem[64] + 100
                                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                _12472 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12472] = 30
                                mem[_12472 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    _12747 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12747 + idx + 68] = mem[_12472 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12747 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12747 + -mem[64] + 100
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                _14104 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14104] = 30
                                mem[_14104 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                    if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                        revert with 'NH{q', 17
                                    else:
                                        return 0
                                _14462 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14462 + idx + 68] = mem[_14104 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14462 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14462 + -mem[64] + 100
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _12914 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12914] = 30
                            mem[_12914 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _13158 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_13158 + idx + 68] = mem[_12914 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13158 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13158 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            _14681 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14681] = 30
                            mem[_14681 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _14986 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14986 + idx + 68] = mem[_14681 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14986 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14986 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            _16244 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16244] = 30
                            mem[_16244 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                else:
                                    return 0
                            _16541 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_16541 + idx + 68] = mem[_16244 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_16541 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16541 + -mem[64] + 100
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 'NH{q', 17
                        if not arg1:
                            revert with 'NH{q', 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor13 / 100 / 100:
                            if not arg1 * stor14 / 100 / 100:
                                if not arg1 * stor15 / 100 / 100:
                                    _10528 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10528] = 30
                                    mem[_10528 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor9 / totalSupply:
                                        _10618 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_10618 + idx + 68] = mem[_10528 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_10618 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _10618 + -mem[64] + 100
                                    if arg1 * stor9 / totalSupply < 0:
                                        revert with 'NH{q', 17
                                    _11067 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11067] = 30
                                    mem[_11067 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor9 / totalSupply:
                                        _11185 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_11185 + idx + 68] = mem[_11067 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_11185 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _11185 + -mem[64] + 100
                                    if arg1 * stor9 / totalSupply < 0:
                                        revert with 'NH{q', 17
                                    _12037 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12037] = 30
                                    mem[_12037 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= arg1 * stor9 / totalSupply:
                                        if arg1 * stor9 / totalSupply < 0:
                                            revert with 'NH{q', 17
                                        return (arg1 * stor9 / totalSupply)
                                    _12273 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12273 + idx + 68] = mem[_12037 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12273 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12273 + -mem[64] + 100
                                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 18
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _11283 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11283] = 30
                                mem[_11283 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor9 / totalSupply:
                                    _11427 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11427 + idx + 68] = mem[_11283 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11427 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11427 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                _12470 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12470] = 30
                                mem[_12470 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor9 / totalSupply:
                                    _12744 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12744 + idx + 68] = mem[_12470 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12744 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12744 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                _14102 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14102] = 30
                                mem[_14102 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                                    if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                        revert with 'NH{q', 17
                                    return (arg1 * stor9 / totalSupply)
                                _14459 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14459 + idx + 68] = mem[_14102 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14459 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14459 + -mem[64] + 100
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor15 / 100 / 100:
                                _11282 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11282] = 30
                                mem[_11282 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor9 / totalSupply:
                                    _11426 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11426 + idx + 68] = mem[_11282 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11426 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11426 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                _12469 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12469] = 30
                                mem[_12469 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                    _12743 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12743 + idx + 68] = mem[_12469 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12743 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12743 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                _14101 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14101] = 30
                                mem[_14101 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                    if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                        revert with 'NH{q', 17
                                    return (arg1 * stor9 / totalSupply)
                                _14458 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14458 + idx + 68] = mem[_14101 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14458 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14458 + -mem[64] + 100
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _12912 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12912] = 30
                            mem[_12912 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _13153 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_13153 + idx + 68] = mem[_12912 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13153 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13153 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _14679 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14679] = 30
                            mem[_14679 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                _14981 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14981 + idx + 68] = mem[_14679 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14981 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14981 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            _16241 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16241] = 30
                            mem[_16241 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                return (arg1 * stor9 / totalSupply)
                            _16538 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_16538 + idx + 68] = mem[_16241 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_16538 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16538 + -mem[64] + 100
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                _11281 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11281] = 30
                                mem[_11281 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                    _11425 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11425 + idx + 68] = mem[_11281 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11425 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11425 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                _12467 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12467] = 30
                                mem[_12467 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                    _12742 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12742 + idx + 68] = mem[_12467 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12742 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12742 + -mem[64] + 100
                                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                    revert with 'NH{q', 17
                                _14100 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14100] = 30
                                mem[_14100 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                        revert with 'NH{q', 17
                                    return (arg1 * stor9 / totalSupply)
                                _14456 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14456 + idx + 68] = mem[_14100 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14456 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14456 + -mem[64] + 100
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _12911 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12911] = 30
                            mem[_12911 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                _13150 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_13150 + idx + 68] = mem[_12911 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13150 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13150 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            _14678 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14678] = 30
                            mem[_14678 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                _14978 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14978 + idx + 68] = mem[_14678 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14978 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14978 + -mem[64] + 100
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            _16239 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16239] = 30
                            mem[_16239 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                return (arg1 * stor9 / totalSupply)
                            _16536 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_16536 + idx + 68] = mem[_16239 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_16536 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16536 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _12910 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12910] = 30
                            mem[_12910 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                _13149 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_13149 + idx + 68] = mem[_12910 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13149 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13149 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            _14677 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14677] = 30
                            mem[_14677 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                _14977 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14977 + idx + 68] = mem[_14677 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14977 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14977 + -mem[64] + 100
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            _16238 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16238] = 30
                            mem[_16238 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor9 / totalSupply)
                            _16535 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_16535 + idx + 68] = mem[_16238 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_16535 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16535 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _15169 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15169] = 30
                        mem[_15169 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _15386 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_15386 + idx + 68] = mem[_15169 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_15386 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15386 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _16652 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16652] = 30
                        mem[_16652 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _16797 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_16797 + idx + 68] = mem[_16652 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_16797 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16797 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _17447 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17447] = 30
                        mem[_17447 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            return (arg1 * stor9 / totalSupply)
                        _17585 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_17585 + idx + 68] = mem[_17447 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_17585 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _17585 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 'NH{q', 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 'NH{q', 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _9689 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9689] = 30
                        mem[_9689 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _9750 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_9750 + idx + 68] = mem[_9689 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_9750 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9750 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 'NH{q', 17
                        if idx >= stor6.length:
                            revert with 'NH{q', 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _9988 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9988] = 30
                        mem[_9988 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 'NH{q', 17
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _10030 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_10030 + idx + 68] = mem[_9988 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10030 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _10030 + -mem[64] + 100
                    _9730 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9730] = 26
                    mem[_9730 + 32] = 'SafeMath: division by zero'
                    if totalSupply <= 0:
                        _9764 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_9764 + idx + 68] = mem[_9730 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_9764 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9764 + -mem[64] + 100
                    if not totalSupply:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * stor13 / 100 / 100:
                            if not arg1 * stor14 / 100 / 100:
                                if not arg1 * stor15 / 100 / 100:
                                    return 0
                                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 18
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _10623 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10623] = 30
                                mem[_10623 + 32] = 'SafeMath: subtraction overflow'
                                _11194 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11194] = 30
                                mem[_11194 + 32] = 'SafeMath: subtraction overflow'
                                _12282 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12282] = 30
                                mem[_12282 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                                    if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                        revert with 'NH{q', 17
                                    else:
                                        return 0
                                _12622 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12622 + idx + 68] = mem[_12282 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12622 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12622 + -mem[64] + 100
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor15 / 100 / 100:
                                _10622 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10622] = 30
                                mem[_10622 + 32] = 'SafeMath: subtraction overflow'
                                _11193 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11193] = 30
                                mem[_11193 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                    _11348 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11348 + idx + 68] = mem[_11193 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11348 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11348 + -mem[64] + 100
                                if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                _12281 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12281] = 30
                                mem[_12281 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                        revert with 'NH{q', 17
                                    else:
                                        return 0
                                _12621 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12621 + idx + 68] = mem[_12281 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12621 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12621 + -mem[64] + 100
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _11440 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11440] = 30
                            mem[_11440 + 32] = 'SafeMath: subtraction overflow'
                            _12763 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12763] = 30
                            mem[_12763 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                _13035 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_13035 + idx + 68] = mem[_12763 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13035 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13035 + -mem[64] + 100
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            _14475 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14475] = 30
                            mem[_14475 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                else:
                                    return 0
                            _14852 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14852 + idx + 68] = mem[_14475 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14852 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14852 + -mem[64] + 100
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                _10621 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10621] = 30
                                mem[_10621 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                    _10692 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_10692 + idx + 68] = mem[_10621 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_10692 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _10692 + -mem[64] + 100
                                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                _11191 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11191] = 30
                                mem[_11191 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    _11347 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11347 + idx + 68] = mem[_11191 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11347 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11347 + -mem[64] + 100
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                _12280 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12280] = 30
                                mem[_12280 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                        revert with 'NH{q', 17
                                    else:
                                        return 0
                                _12620 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12620 + idx + 68] = mem[_12280 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12620 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12620 + -mem[64] + 100
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _11439 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11439] = 30
                            mem[_11439 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _11607 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11607 + idx + 68] = mem[_11439 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11607 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11607 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            _12762 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12762] = 30
                            mem[_12762 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _13032 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_13032 + idx + 68] = mem[_12762 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13032 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13032 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _14473 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14473] = 30
                            mem[_14473 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                else:
                                    return 0
                            _14850 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14850 + idx + 68] = mem[_14473 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14850 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14850 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _11438 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11438] = 30
                            mem[_11438 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _11606 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11606 + idx + 68] = mem[_11438 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11606 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11606 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            _12761 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12761] = 30
                            mem[_12761 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _13031 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_13031 + idx + 68] = mem[_12761 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13031 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13031 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            _14472 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14472] = 30
                            mem[_14472 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                    revert with 'NH{q', 17
                                else:
                                    return 0
                            _14849 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14849 + idx + 68] = mem[_14472 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14849 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14849 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _13168 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13168] = 30
                        mem[_13168 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _13435 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_13435 + idx + 68] = mem[_13168 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_13435 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13435 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _14998 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14998] = 30
                        mem[_14998 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _15299 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_15299 + idx + 68] = mem[_14998 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_15299 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15299 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _16551 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16551] = 30
                        mem[_16551 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            else:
                                return 0
                        _16738 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_16738 + idx + 68] = mem[_16551 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_16738 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16738 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor14 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                _10620 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10620] = 30
                                mem[_10620 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor9 / totalSupply:
                                    _10691 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_10691 + idx + 68] = mem[_10620 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_10691 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _10691 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                _11189 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11189] = 30
                                mem[_11189 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor9 / totalSupply:
                                    _11346 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11346 + idx + 68] = mem[_11189 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11346 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11346 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                _12279 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12279] = 30
                                mem[_12279 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor9 / totalSupply:
                                    if arg1 * stor9 / totalSupply < 0:
                                        revert with 'NH{q', 17
                                    return (arg1 * stor9 / totalSupply)
                                _12617 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12617 + idx + 68] = mem[_12279 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12617 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12617 + -mem[64] + 100
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _11437 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11437] = 30
                            mem[_11437 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11603 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11603 + idx + 68] = mem[_11437 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11603 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11603 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _12759 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12759] = 30
                            mem[_12759 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _13028 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_13028 + idx + 68] = mem[_12759 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13028 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13028 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _14470 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14470] = 30
                            mem[_14470 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                return (arg1 * stor9 / totalSupply)
                            _14846 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14846 + idx + 68] = mem[_14470 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14846 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14846 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _11436 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11436] = 30
                            mem[_11436 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11602 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11602 + idx + 68] = mem[_11436 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11602 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11602 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            _12758 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12758] = 30
                            mem[_12758 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                _13027 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_13027 + idx + 68] = mem[_12758 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13027 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13027 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            _14469 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14469] = 30
                            mem[_14469 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor9 / totalSupply)
                            _14845 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14845 + idx + 68] = mem[_14469 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14845 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14845 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _13166 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13166] = 30
                        mem[_13166 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _13430 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_13430 + idx + 68] = mem[_13166 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_13430 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13430 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 'NH{q', 17
                        _14996 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14996] = 30
                        mem[_14996 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _15294 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_15294 + idx + 68] = mem[_14996 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_15294 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15294 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _16548 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16548] = 30
                        mem[_16548 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            return (arg1 * stor9 / totalSupply)
                        _16735 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_16735 + idx + 68] = mem[_16548 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_16735 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16735 + -mem[64] + 100
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            _11435 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11435] = 30
                            mem[_11435 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                _11601 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11601 + idx + 68] = mem[_11435 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11601 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11601 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            _12756 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12756] = 30
                            mem[_12756 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                _13026 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_13026 + idx + 68] = mem[_12756 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13026 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13026 + -mem[64] + 100
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            _14468 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14468] = 30
                            mem[_14468 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                    revert with 'NH{q', 17
                                return (arg1 * stor9 / totalSupply)
                            _14843 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14843 + idx + 68] = mem[_14468 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14843 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14843 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _13165 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13165] = 30
                        mem[_13165 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _13427 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_13427 + idx + 68] = mem[_13165 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_13427 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13427 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _14995 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14995] = 30
                        mem[_14995 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _15291 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_15291 + idx + 68] = mem[_14995 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_15291 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15291 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 'NH{q', 17
                        _16546 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16546] = 30
                        mem[_16546 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            return (arg1 * stor9 / totalSupply)
                        _16733 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_16733 + idx + 68] = mem[_16546 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_16733 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16733 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _13164 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13164] = 30
                        mem[_13164 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _13426 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_13426 + idx + 68] = mem[_13164 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_13426 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13426 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _14994 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14994] = 30
                        mem[_14994 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _15290 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_15290 + idx + 68] = mem[_14994 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_15290 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15290 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        _16545 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16545] = 30
                        mem[_16545 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            return (arg1 * stor9 / totalSupply)
                        _16732 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_16732 + idx + 68] = mem[_16545 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_16732 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16732 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _15395 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15395] = 30
                    mem[_15395 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _15634 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_15634 + idx + 68] = mem[_15395 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_15634 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15634 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    _16806 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16806] = 30
                    mem[_16806 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _16976 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_16976 + idx + 68] = mem[_16806 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_16976 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16976 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 'NH{q', 17
                    _17590 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_17590] = 30
                    mem[_17590 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 'NH{q', 17
                        return (arg1 * stor9 / totalSupply)
                    _17635 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_17635 + idx + 68] = mem[_17590 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_17635 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _17635 + -mem[64] + 100
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if t >= stor9 / totalSupply:
                    if s <= 0:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not s:
                        revert with 'NH{q', 18
                    if not arg1:
                        if not arg1 * stor13 / 100 / 100:
                            if not arg1 * stor14 / 100 / 100:
                                if arg1 * stor15 / 100 / 100:
                                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                        revert with 'NH{q', 17
                                    if not arg1 * stor15 / 100 / 100:
                                        revert with 'NH{q', 18
                                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * stor15 / 100 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * stor15 / 100 / 100 * t / s:
                                        revert with 'NH{q', 17
                            else:
                                if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                                    revert with 'NH{q', 17
                                if not arg1 * stor14 / 100 / 100:
                                    revert with 'NH{q', 18
                                if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * stor15 / 100 / 100:
                                    if arg1 * stor14 / 100 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * stor14 / 100 / 100 * t / s:
                                        revert with 'NH{q', 17
                                    if 0 > -1 * arg1 * stor14 / 100 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * stor14 / 100 / 100 * t / s < 0:
                                        revert with 'NH{q', 17
                                else:
                                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                        revert with 'NH{q', 17
                                    if not arg1 * stor15 / 100 / 100:
                                        revert with 'NH{q', 18
                                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * stor14 / 100 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * stor14 / 100 / 100 * t / s:
                                        revert with 'NH{q', 17
                                    if arg1 * stor15 / 100 / 100 * t / s > -1 * arg1 * stor14 / 100 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * stor14 / 100 / 100 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                                        revert with 'NH{q', 17
                        else:
                            if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor13 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor14 / 100 / 100:
                                if not arg1 * stor15 / 100 / 100:
                                    if arg1 * stor13 / 100 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * stor13 / 100 / 100 * t / s:
                                        revert with 'NH{q', 17
                                    if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                                        revert with 'NH{q', 17
                                    if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                                        revert with 'NH{q', 17
                                else:
                                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                        revert with 'NH{q', 17
                                    if not arg1 * stor15 / 100 / 100:
                                        revert with 'NH{q', 18
                                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * stor13 / 100 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * stor13 / 100 / 100 * t / s:
                                        revert with 'NH{q', 17
                                    if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                                        revert with 'NH{q', 17
                                    if arg1 * stor15 / 100 / 100 * t / s > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * stor13 / 100 / 100 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                                        revert with 'NH{q', 17
                            else:
                                if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                                    revert with 'NH{q', 17
                                if not arg1 * stor14 / 100 / 100:
                                    revert with 'NH{q', 18
                                if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * stor15 / 100 / 100:
                                    if arg1 * stor13 / 100 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * stor13 / 100 / 100 * t / s:
                                        revert with 'NH{q', 17
                                    if arg1 * stor14 / 100 / 100 * t / s > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * stor13 / 100 / 100 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                                        revert with 'NH{q', 17
                                    if 0 > (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                                        revert with 'NH{q', 17
                                else:
                                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                        revert with 'NH{q', 17
                                    if not arg1 * stor15 / 100 / 100:
                                        revert with 'NH{q', 18
                                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * stor13 / 100 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * stor13 / 100 / 100 * t / s:
                                        revert with 'NH{q', 17
                                    if arg1 * stor14 / 100 / 100 * t / s > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * stor13 / 100 / 100 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                                        revert with 'NH{q', 17
                                    if arg1 * stor15 / 100 / 100 * t / s > (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                                        revert with 'NH{q', 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor14 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 'NH{q', 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 'NH{q', 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 'NH{q', 17
                            else:
                                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 18
                                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 'NH{q', 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 'NH{q', 17
                                if arg1 * stor15 / 100 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                                    revert with 'NH{q', 17
                        else:
                            if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor15 / 100 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 'NH{q', 17
                                if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                                    revert with 'NH{q', 17
                                if 0 > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                                    revert with 'NH{q', 17
                            else:
                                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 18
                                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 'NH{q', 17
                                if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                                    revert with 'NH{q', 17
                                if arg1 * stor15 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                                    revert with 'NH{q', 17
                    else:
                        if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 'NH{q', 17
                                if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                                    revert with 'NH{q', 17
                                if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                                    revert with 'NH{q', 17
                            else:
                                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 18
                                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 'NH{q', 17
                                if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                                    revert with 'NH{q', 17
                                if arg1 * stor15 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                                    revert with 'NH{q', 17
                        else:
                            if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor15 / 100 / 100:
                                if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 'NH{q', 17
                                if arg1 * stor14 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < arg1 * stor14 / 100 / 100 * t / s:
                                    revert with 'NH{q', 17
                                if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                                    revert with 'NH{q', 17
                            else:
                                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 18
                                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 'NH{q', 17
                                if arg1 * stor14 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < arg1 * stor14 / 100 / 100 * t / s:
                                    revert with 'NH{q', 17
                                if arg1 * stor15 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                                    revert with 'NH{q', 17
                    return (arg1 * t / s)
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not totalSupply:
                    revert with 'NH{q', 18
                if not arg1:
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor14 / 100 / 100:
                            if arg1 * stor15 / 100 / 100:
                                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 18
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                        else:
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor15 / 100 / 100:
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                if 0 > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                            else:
                                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 18
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                    else:
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                            else:
                                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 18
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 'NH{q', 17
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                        else:
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor15 / 100 / 100:
                                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                if 0 > (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                    revert with 'NH{q', 17
                            else:
                                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 'NH{q', 18
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 'NH{q', 17
                    return 0
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            if 0 > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            if 0 > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            if 0 > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                        else:
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            if 0 > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                    else:
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            if 0 > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 'NH{q', 17
                        else:
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 'NH{q', 17
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                else:
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 'NH{q', 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 'NH{q', 17
                        else:
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 'NH{q', 17
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                    else:
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 'NH{q', 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 'NH{q', 17
                        else:
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 'NH{q', 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 'NH{q', 17
    return (arg1 * stor9 / totalSupply)
}



}
